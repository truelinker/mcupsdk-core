<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="shortcut icon" href="favicon.png" type="image/png">    
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<title>AM64x MCU+ SDK: APIs for FSI RX</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<style>
.tinav {
    background: #c00;
    /* height: 41.375px; */
    height: 30px;
    }
</style>    
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
  /* @license-end */
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="AM64x MCU+ SDK"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 40px;">
  <td id="projectlogo"><a href="https://www.ti.com"><img alt="Logo" src="ti_logo.svg"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AM64x MCU+ SDK
   &#160;<span id="projectnumber">10.00.00</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.html" method="get">
              <img id="MSearchSelect" src="search/mag.svg" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
</td>
 </tr>
 </tbody>
</table>
<div class=tinav></div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__DRV__FSI__RX__MODULE.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">APIs for FSI RX<div class="ingroups"><a class="el" href="group__DRV__MODULE.html">APIs for SOC Specific Device Drivers</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Introduction</h2>
<p>This module contains APIs to program and use the FSI RX module. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:fsi__rx_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsi__rx_8h.html">fsi_rx.h</a></td></tr>
<tr class="memdesc:fsi__rx_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Header file containing various enumerations, structure definitions and function declarations for the FSI RX IP. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9170cb7041f53ce30ef98b43e93f0341"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga9170cb7041f53ce30ef98b43e93f0341">FSI_enableRxInternalLoopback</a> (uint32_t base)</td></tr>
<tr class="memdesc:ga9170cb7041f53ce30ef98b43e93f0341"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enables internal loopback where mux will select internal pins coming from RX module instead of what comes from pins.  <a href="group__DRV__FSI__RX__MODULE.html#ga9170cb7041f53ce30ef98b43e93f0341">More...</a><br /></td></tr>
<tr class="separator:ga9170cb7041f53ce30ef98b43e93f0341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b7a943ddcbf826956eefbf695de389f"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga1b7a943ddcbf826956eefbf695de389f">FSI_disableRxInternalLoopback</a> (uint32_t base)</td></tr>
<tr class="memdesc:ga1b7a943ddcbf826956eefbf695de389f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API disables internal loopback where mux will not use internal pins coming from RX module.  <a href="group__DRV__FSI__RX__MODULE.html#ga1b7a943ddcbf826956eefbf695de389f">More...</a><br /></td></tr>
<tr class="separator:ga1b7a943ddcbf826956eefbf695de389f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa95f308ee65bdd9c1affeb8c8c795c0b"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#gaa95f308ee65bdd9c1affeb8c8c795c0b">FSI_enableRxSPIPairing</a> (uint32_t base)</td></tr>
<tr class="memdesc:gaa95f308ee65bdd9c1affeb8c8c795c0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enables SPI clock paring, receive clock is selected from the internal port coming from RX module.  <a href="group__DRV__FSI__RX__MODULE.html#gaa95f308ee65bdd9c1affeb8c8c795c0b">More...</a><br /></td></tr>
<tr class="separator:gaa95f308ee65bdd9c1affeb8c8c795c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1e82e3b939a5b67d609fa53792cb6a5"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#gaa1e82e3b939a5b67d609fa53792cb6a5">FSI_disableRxSPIPairing</a> (uint32_t base)</td></tr>
<tr class="memdesc:gaa1e82e3b939a5b67d609fa53792cb6a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API disables SPI clock paring, selects regular receive clock coming from the pins.  <a href="group__DRV__FSI__RX__MODULE.html#gaa1e82e3b939a5b67d609fa53792cb6a5">More...</a><br /></td></tr>
<tr class="separator:gaa1e82e3b939a5b67d609fa53792cb6a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb4886595a1ec142928bc4bd3f23a3fe"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#gadb4886595a1ec142928bc4bd3f23a3fe">FSI_setRxDataWidth</a> (uint32_t base, <a class="el" href="group__DRV__FSI__MODULE.html#ga5dbdfd7ff13523f74955cbb7707726f2">FSI_DataWidth</a> dataWidth)</td></tr>
<tr class="memdesc:gadb4886595a1ec142928bc4bd3f23a3fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API selects number of data lines used for receiving.  <a href="group__DRV__FSI__RX__MODULE.html#gadb4886595a1ec142928bc4bd3f23a3fe">More...</a><br /></td></tr>
<tr class="separator:gadb4886595a1ec142928bc4bd3f23a3fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga799d369814a32f0f8feea6f7162b565d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga799d369814a32f0f8feea6f7162b565d">FSI_enableRxSPIMode</a> (uint32_t base)</td></tr>
<tr class="memdesc:ga799d369814a32f0f8feea6f7162b565d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enables SPI compatible mode in FSI RX.  <a href="group__DRV__FSI__RX__MODULE.html#ga799d369814a32f0f8feea6f7162b565d">More...</a><br /></td></tr>
<tr class="separator:ga799d369814a32f0f8feea6f7162b565d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92dfc172f14081ef48cd952268761d64"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga92dfc172f14081ef48cd952268761d64">FSI_disableRxSPIMode</a> (uint32_t base)</td></tr>
<tr class="memdesc:ga92dfc172f14081ef48cd952268761d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API disables SPI compatible mode in FSI RX.  <a href="group__DRV__FSI__RX__MODULE.html#ga92dfc172f14081ef48cd952268761d64">More...</a><br /></td></tr>
<tr class="separator:ga92dfc172f14081ef48cd952268761d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2ae3a2c55ebc558548d25592f603063"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#gae2ae3a2c55ebc558548d25592f603063">FSI_setRxSoftwareFrameSize</a> (uint32_t base, uint16_t nWords)</td></tr>
<tr class="memdesc:gae2ae3a2c55ebc558548d25592f603063"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API sets the RX frame size if frame type is user/software defined frame.  <a href="group__DRV__FSI__RX__MODULE.html#gae2ae3a2c55ebc558548d25592f603063">More...</a><br /></td></tr>
<tr class="separator:gae2ae3a2c55ebc558548d25592f603063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga082dd17b9a156637bf7a1be67f132a08"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga082dd17b9a156637bf7a1be67f132a08">FSI_setRxECCComputeWidth</a> (uint32_t base, <a class="el" href="fsi_2v0_2fsi_8h.html#aa3bcb498544ab9219714d4531ebcadb9">FSI_ECCComputeWidth</a> eccComputeWidth)</td></tr>
<tr class="memdesc:ga082dd17b9a156637bf7a1be67f132a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API select between 16-bit and 32-bit ECC computation for FSI RX.  <a href="group__DRV__FSI__RX__MODULE.html#ga082dd17b9a156637bf7a1be67f132a08">More...</a><br /></td></tr>
<tr class="separator:ga082dd17b9a156637bf7a1be67f132a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga341c89644305e257e0bf0146aefbce07"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga341c89644305e257e0bf0146aefbce07">FSI_setRxPingTimeoutMode</a> (uint32_t base, <a class="el" href="fsi_2v0_2fsi_8h.html#a3008502af132b9be684563c208957180">FSI_PingTimeoutMode</a> pingTimeoutMode)</td></tr>
<tr class="memdesc:ga341c89644305e257e0bf0146aefbce07"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API sets HW/SW initiated RX ping timeout mode.  <a href="group__DRV__FSI__RX__MODULE.html#ga341c89644305e257e0bf0146aefbce07">More...</a><br /></td></tr>
<tr class="separator:ga341c89644305e257e0bf0146aefbce07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa302e1bdee44a932faa9ad9b84e1a7d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#gafa302e1bdee44a932faa9ad9b84e1a7d">FSI_getRxFrameType</a> (uint32_t base, <a class="el" href="fsi_2v0_2fsi_8h.html#a5d351d5afbe8aa861a52ebcd12a91b38">FSI_FrameType</a> *pFrameType)</td></tr>
<tr class="memdesc:gafa302e1bdee44a932faa9ad9b84e1a7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API gets frame type received in the last successful frame.  <a href="group__DRV__FSI__RX__MODULE.html#gafa302e1bdee44a932faa9ad9b84e1a7d">More...</a><br /></td></tr>
<tr class="separator:gafa302e1bdee44a932faa9ad9b84e1a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2adadf70ac8a389cd9254113687a426f"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga2adadf70ac8a389cd9254113687a426f">FSI_getRxFrameTag</a> (uint32_t base, uint16_t *pFrameTag)</td></tr>
<tr class="memdesc:ga2adadf70ac8a389cd9254113687a426f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API gets frame tag received for the last successful frame.  <a href="group__DRV__FSI__RX__MODULE.html#ga2adadf70ac8a389cd9254113687a426f">More...</a><br /></td></tr>
<tr class="separator:ga2adadf70ac8a389cd9254113687a426f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0eb1f3b88ec70f6ace95e281df77436"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#gae0eb1f3b88ec70f6ace95e281df77436">FSI_getRxUserDefinedData</a> (uint32_t base, uint16_t *pUserData)</td></tr>
<tr class="memdesc:gae0eb1f3b88ec70f6ace95e281df77436"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API gets User-Data (8-bit) field for received data frame.  <a href="group__DRV__FSI__RX__MODULE.html#gae0eb1f3b88ec70f6ace95e281df77436">More...</a><br /></td></tr>
<tr class="separator:gae0eb1f3b88ec70f6ace95e281df77436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3283e8dbd6bb4d2a8be106a568555429"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga3283e8dbd6bb4d2a8be106a568555429">FSI_getRxEventStatus</a> (uint32_t base, uint16_t *pEvtFlags)</td></tr>
<tr class="memdesc:ga3283e8dbd6bb4d2a8be106a568555429"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API gets current status of all the event/error flags.  <a href="group__DRV__FSI__RX__MODULE.html#ga3283e8dbd6bb4d2a8be106a568555429">More...</a><br /></td></tr>
<tr class="separator:ga3283e8dbd6bb4d2a8be106a568555429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79226282f5a52b140a6db84c1249e8d3"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga79226282f5a52b140a6db84c1249e8d3">FSI_forceRxEvents</a> (uint32_t base, uint16_t evtFlags)</td></tr>
<tr class="memdesc:ga79226282f5a52b140a6db84c1249e8d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enables user to set RX event/error flags.  <a href="group__DRV__FSI__RX__MODULE.html#ga79226282f5a52b140a6db84c1249e8d3">More...</a><br /></td></tr>
<tr class="separator:ga79226282f5a52b140a6db84c1249e8d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f1e7abd5645688b2e6b9c2af0ecfad2"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga7f1e7abd5645688b2e6b9c2af0ecfad2">FSI_clearRxEvents</a> (uint32_t base, uint16_t evtFlags)</td></tr>
<tr class="memdesc:ga7f1e7abd5645688b2e6b9c2af0ecfad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enables user to clear RX event/error flags.  <a href="group__DRV__FSI__RX__MODULE.html#ga7f1e7abd5645688b2e6b9c2af0ecfad2">More...</a><br /></td></tr>
<tr class="separator:ga7f1e7abd5645688b2e6b9c2af0ecfad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47a14b1ff5bf952b0ccd69773420cc56"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga47a14b1ff5bf952b0ccd69773420cc56">FSI_getRxReceivedCRC</a> (uint32_t base, uint16_t *pCrcVal)</td></tr>
<tr class="memdesc:ga47a14b1ff5bf952b0ccd69773420cc56"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API gets CRC value received in data frame/frame.  <a href="group__DRV__FSI__RX__MODULE.html#ga47a14b1ff5bf952b0ccd69773420cc56">More...</a><br /></td></tr>
<tr class="separator:ga47a14b1ff5bf952b0ccd69773420cc56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb532f34d758864d0c4d5c129f852940"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#gadb532f34d758864d0c4d5c129f852940">FSI_getRxComputedCRC</a> (uint32_t base, uint16_t *pCrcVal)</td></tr>
<tr class="memdesc:gadb532f34d758864d0c4d5c129f852940"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API gets CRC value computed for data received.  <a href="group__DRV__FSI__RX__MODULE.html#gadb532f34d758864d0c4d5c129f852940">More...</a><br /></td></tr>
<tr class="separator:gadb532f34d758864d0c4d5c129f852940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44b4cb2f8cc74371fbef6f8812460d5d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga44b4cb2f8cc74371fbef6f8812460d5d">FSI_setRxBufferPtr</a> (uint32_t base, uint16_t bufPtrOff)</td></tr>
<tr class="memdesc:ga44b4cb2f8cc74371fbef6f8812460d5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API sets the value for receive buffer pointer at desired location.  <a href="group__DRV__FSI__RX__MODULE.html#ga44b4cb2f8cc74371fbef6f8812460d5d">More...</a><br /></td></tr>
<tr class="separator:ga44b4cb2f8cc74371fbef6f8812460d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fe90c3f09affc730820643a3005d5a2"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga9fe90c3f09affc730820643a3005d5a2">FSI_getRxBufferPtr</a> (uint32_t base, uint16_t *pBufPtrLoc)</td></tr>
<tr class="memdesc:ga9fe90c3f09affc730820643a3005d5a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API gets current buffer pointer location.  <a href="group__DRV__FSI__RX__MODULE.html#ga9fe90c3f09affc730820643a3005d5a2">More...</a><br /></td></tr>
<tr class="separator:ga9fe90c3f09affc730820643a3005d5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12c3900957d62d91e52f804596cacc82"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga12c3900957d62d91e52f804596cacc82">FSI_getRxWordCount</a> (uint32_t base, uint16_t *pWordCnt)</td></tr>
<tr class="memdesc:ga12c3900957d62d91e52f804596cacc82"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API gets valid number of data words present in buffer which have not been read out yet.  <a href="group__DRV__FSI__RX__MODULE.html#ga12c3900957d62d91e52f804596cacc82">More...</a><br /></td></tr>
<tr class="separator:ga12c3900957d62d91e52f804596cacc82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fe38e8b22684c6400a05692aa56e8c3"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga6fe38e8b22684c6400a05692aa56e8c3">FSI_enableRxFrameWatchdog</a> (uint32_t base, uint32_t wdRef)</td></tr>
<tr class="memdesc:ga6fe38e8b22684c6400a05692aa56e8c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enables the frame watchdog counter logic to count every time it start to receive a frame.  <a href="group__DRV__FSI__RX__MODULE.html#ga6fe38e8b22684c6400a05692aa56e8c3">More...</a><br /></td></tr>
<tr class="separator:ga6fe38e8b22684c6400a05692aa56e8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga405729ef78cb96a329e2890d7ab74c35"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga405729ef78cb96a329e2890d7ab74c35">FSI_disableRxFrameWatchdog</a> (uint32_t base)</td></tr>
<tr class="memdesc:ga405729ef78cb96a329e2890d7ab74c35"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API disables the frame watchdog counter logic.  <a href="group__DRV__FSI__RX__MODULE.html#ga405729ef78cb96a329e2890d7ab74c35">More...</a><br /></td></tr>
<tr class="separator:ga405729ef78cb96a329e2890d7ab74c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01346af9ba768810f6caeb29775698be"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga01346af9ba768810f6caeb29775698be">FSI_getRxFrameWatchdogCounter</a> (uint32_t base, uint32_t *pWdCnt)</td></tr>
<tr class="memdesc:ga01346af9ba768810f6caeb29775698be"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API gets current value of frame watchdog counter.  <a href="group__DRV__FSI__RX__MODULE.html#ga01346af9ba768810f6caeb29775698be">More...</a><br /></td></tr>
<tr class="separator:ga01346af9ba768810f6caeb29775698be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1cc3fbc0a5c12d8f1cbde53afb7b7bb"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#gac1cc3fbc0a5c12d8f1cbde53afb7b7bb">FSI_enableRxPingWatchdog</a> (uint32_t base, uint32_t wdRef)</td></tr>
<tr class="memdesc:gac1cc3fbc0a5c12d8f1cbde53afb7b7bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enables the ping watchdog counter logic and once the set time elapses it will indicate ping watchdog time-out has occurred.  <a href="group__DRV__FSI__RX__MODULE.html#gac1cc3fbc0a5c12d8f1cbde53afb7b7bb">More...</a><br /></td></tr>
<tr class="separator:gac1cc3fbc0a5c12d8f1cbde53afb7b7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0aaa3527c9181a56c93cb2701dbe7b73"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga0aaa3527c9181a56c93cb2701dbe7b73">FSI_disableRxPingWatchdog</a> (uint32_t base)</td></tr>
<tr class="memdesc:ga0aaa3527c9181a56c93cb2701dbe7b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API disables the ping watchdog counter logic.  <a href="group__DRV__FSI__RX__MODULE.html#ga0aaa3527c9181a56c93cb2701dbe7b73">More...</a><br /></td></tr>
<tr class="separator:ga0aaa3527c9181a56c93cb2701dbe7b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab15bffd0c7133f8a98909c251324e43"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#gaab15bffd0c7133f8a98909c251324e43">FSI_getRxPingWatchdogCounter</a> (uint32_t base, uint32_t *pWdCnt)</td></tr>
<tr class="memdesc:gaab15bffd0c7133f8a98909c251324e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API gets current value of ping watchdog counter.  <a href="group__DRV__FSI__RX__MODULE.html#gaab15bffd0c7133f8a98909c251324e43">More...</a><br /></td></tr>
<tr class="separator:gaab15bffd0c7133f8a98909c251324e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga263b308924c40f1bb4102527f4edf8ea"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga263b308924c40f1bb4102527f4edf8ea">FSI_getRxPingTag</a> (uint32_t base, uint16_t *pPingTag)</td></tr>
<tr class="memdesc:ga263b308924c40f1bb4102527f4edf8ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API gets the value of tag received for last ping frame.  <a href="group__DRV__FSI__RX__MODULE.html#ga263b308924c40f1bb4102527f4edf8ea">More...</a><br /></td></tr>
<tr class="separator:ga263b308924c40f1bb4102527f4edf8ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2761253b24833ec34428bf0b6aa96b6d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga2761253b24833ec34428bf0b6aa96b6d">FSI_lockRxCtrl</a> (uint32_t base)</td></tr>
<tr class="memdesc:ga2761253b24833ec34428bf0b6aa96b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API locks the control of all receive control registers, once locked further writes will not take effect until system reset occurs.  <a href="group__DRV__FSI__RX__MODULE.html#ga2761253b24833ec34428bf0b6aa96b6d">More...</a><br /></td></tr>
<tr class="separator:ga2761253b24833ec34428bf0b6aa96b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8f814eba73aa210f74de7d9a5964609"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#gaa8f814eba73aa210f74de7d9a5964609">FSI_setRxECCData</a> (uint32_t base, uint32_t rxECCdata)</td></tr>
<tr class="memdesc:gaa8f814eba73aa210f74de7d9a5964609"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API sets RX ECC data on which ECC (SEC-DED) computaion logic runs.  <a href="group__DRV__FSI__RX__MODULE.html#gaa8f814eba73aa210f74de7d9a5964609">More...</a><br /></td></tr>
<tr class="separator:gaa8f814eba73aa210f74de7d9a5964609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9842c1684646d5d1be7d7b54fcfb9f5"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#gae9842c1684646d5d1be7d7b54fcfb9f5">FSI_setRxReceivedECCValue</a> (uint32_t base, uint16_t rxECCvalue)</td></tr>
<tr class="memdesc:gae9842c1684646d5d1be7d7b54fcfb9f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API sets received ECC value on which ECC (SEC-DED) computaion logic runs.  <a href="group__DRV__FSI__RX__MODULE.html#gae9842c1684646d5d1be7d7b54fcfb9f5">More...</a><br /></td></tr>
<tr class="separator:gae9842c1684646d5d1be7d7b54fcfb9f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga299a4d417435db13121de988d89d4b5e"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga299a4d417435db13121de988d89d4b5e">FSI_getRxECCCorrectedData</a> (uint32_t base, uint32_t *pEccData)</td></tr>
<tr class="memdesc:ga299a4d417435db13121de988d89d4b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API gets ECC corrected data.  <a href="group__DRV__FSI__RX__MODULE.html#ga299a4d417435db13121de988d89d4b5e">More...</a><br /></td></tr>
<tr class="separator:ga299a4d417435db13121de988d89d4b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38ec620ec2c4148b393a7a816652c447"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga38ec620ec2c4148b393a7a816652c447">FSI_getRxECCLog</a> (uint32_t base, uint16_t *pEccLog)</td></tr>
<tr class="memdesc:ga38ec620ec2c4148b393a7a816652c447"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API gets ECC Log details.  <a href="group__DRV__FSI__RX__MODULE.html#ga38ec620ec2c4148b393a7a816652c447">More...</a><br /></td></tr>
<tr class="separator:ga38ec620ec2c4148b393a7a816652c447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab84bef42f754fed3e890c000371e502b"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#gab84bef42f754fed3e890c000371e502b">FSI_enableRxInterrupt</a> (uint32_t base, <a class="el" href="fsi_2v0_2fsi_8h.html#ad3a8bd4711243054c29b3215a9f05b6c">FSI_InterruptNum</a> intNum, uint16_t intFlags)</td></tr>
<tr class="memdesc:gab84bef42f754fed3e890c000371e502b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enables user to generate interrupt on occurrence of RX events.  <a href="group__DRV__FSI__RX__MODULE.html#gab84bef42f754fed3e890c000371e502b">More...</a><br /></td></tr>
<tr class="separator:gab84bef42f754fed3e890c000371e502b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2e03ccc8d65b92e55858315e9ba58a3"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#gac2e03ccc8d65b92e55858315e9ba58a3">FSI_disableRxInterrupt</a> (uint32_t base, <a class="el" href="fsi_2v0_2fsi_8h.html#ad3a8bd4711243054c29b3215a9f05b6c">FSI_InterruptNum</a> intNum, uint16_t intFlags)</td></tr>
<tr class="memdesc:gac2e03ccc8d65b92e55858315e9ba58a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enables user to disable interrupt generation on RX events.  <a href="group__DRV__FSI__RX__MODULE.html#gac2e03ccc8d65b92e55858315e9ba58a3">More...</a><br /></td></tr>
<tr class="separator:gac2e03ccc8d65b92e55858315e9ba58a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadacfefc8afd7e970166dae171c24e0d9"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#gadacfefc8afd7e970166dae171c24e0d9">FSI_getRxBufferAddress</a> (uint32_t base, uint32_t *pAddr)</td></tr>
<tr class="memdesc:gadacfefc8afd7e970166dae171c24e0d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API gets address of RX data buffer.  <a href="group__DRV__FSI__RX__MODULE.html#gadacfefc8afd7e970166dae171c24e0d9">More...</a><br /></td></tr>
<tr class="separator:gadacfefc8afd7e970166dae171c24e0d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeed6850f729199549e7c1ed7c412dd6a"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#gaeed6850f729199549e7c1ed7c412dd6a">FSI_resetRxModule</a> (uint32_t base, <a class="el" href="group__DRV__FSI__RX__MODULE.html#ga978e5625bbdab7e0a3532158e18642de">FSI_RxSubmoduleInReset</a> submodule)</td></tr>
<tr class="memdesc:gaeed6850f729199549e7c1ed7c412dd6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API resets frame watchdog, ping watchdog or entire RX module.  <a href="group__DRV__FSI__RX__MODULE.html#gaeed6850f729199549e7c1ed7c412dd6a">More...</a><br /></td></tr>
<tr class="separator:gaeed6850f729199549e7c1ed7c412dd6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71df7339698c1595b844f1306480823c"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga71df7339698c1595b844f1306480823c">FSI_clearRxModuleReset</a> (uint32_t base, <a class="el" href="group__DRV__FSI__RX__MODULE.html#ga978e5625bbdab7e0a3532158e18642de">FSI_RxSubmoduleInReset</a> submodule)</td></tr>
<tr class="memdesc:ga71df7339698c1595b844f1306480823c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API clears resets on frame watchdog, ping watchdog or entire RX module.  <a href="group__DRV__FSI__RX__MODULE.html#ga71df7339698c1595b844f1306480823c">More...</a><br /></td></tr>
<tr class="separator:ga71df7339698c1595b844f1306480823c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1fd9f043ea2d3ee6fc51c1bd5ac7407"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#gaa1fd9f043ea2d3ee6fc51c1bd5ac7407">FSI_readRxBuffer</a> (uint32_t base, uint16_t *pArray, uint16_t length, uint16_t bufOffset)</td></tr>
<tr class="memdesc:gaa1fd9f043ea2d3ee6fc51c1bd5ac7407"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API reads data from FSI RX buffer.  <a href="group__DRV__FSI__RX__MODULE.html#gaa1fd9f043ea2d3ee6fc51c1bd5ac7407">More...</a><br /></td></tr>
<tr class="separator:gaa1fd9f043ea2d3ee6fc51c1bd5ac7407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e5e647e8af2ab66e1137578d3876823"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga1e5e647e8af2ab66e1137578d3876823">FSI_configRxDelayLine</a> (uint32_t base, <a class="el" href="group__DRV__FSI__RX__MODULE.html#ga1fbb4d66e61b47962982c0fe4369a311">FSI_RxDelayTapType</a> delayTapType, uint16_t tapValue)</td></tr>
<tr class="memdesc:ga1e5e647e8af2ab66e1137578d3876823"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API adds delay for selected RX tap line.  <a href="group__DRV__FSI__RX__MODULE.html#ga1e5e647e8af2ab66e1137578d3876823">More...</a><br /></td></tr>
<tr class="separator:ga1e5e647e8af2ab66e1137578d3876823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98518d233fe2f79b8e3ed84248f13a97"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga98518d233fe2f79b8e3ed84248f13a97">FSI_performRxInitialization</a> (uint32_t base)</td></tr>
<tr class="memdesc:ga98518d233fe2f79b8e3ed84248f13a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API initializes FSI RX module.  <a href="group__DRV__FSI__RX__MODULE.html#ga98518d233fe2f79b8e3ed84248f13a97">More...</a><br /></td></tr>
<tr class="separator:ga98518d233fe2f79b8e3ed84248f13a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
FSI RX Enum type</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp577033fb0e668980d4b76545d706d7dd"></a><a class="anchor" id="FSI_RxEnum"></a></p>
</td></tr>
<tr class="memitem:gafdfea7397b8c8492c1d5fdc5d54b70c5"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#gafdfea7397b8c8492c1d5fdc5d54b70c5">FSI_RxEnumType</a></td></tr>
<tr class="memdesc:gafdfea7397b8c8492c1d5fdc5d54b70c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This enumerator defines the types of possible FSI RX events.  <a href="group__DRV__FSI__RX__MODULE.html#gafdfea7397b8c8492c1d5fdc5d54b70c5">More...</a><br /></td></tr>
<tr class="separator:gafdfea7397b8c8492c1d5fdc5d54b70c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3bb15cce2a6c3d21dc8675314aff8e7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#gae3bb15cce2a6c3d21dc8675314aff8e7">FSI_RX_EVT_PING_WD_TIMEOUT</a>&#160;&#160;&#160;((uint16_t)0x0001U)</td></tr>
<tr class="separator:gae3bb15cce2a6c3d21dc8675314aff8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf37e2100563594ba98f5fd4dc6cec58a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#gaf37e2100563594ba98f5fd4dc6cec58a">FSI_RX_EVT_FRAME_WD_TIMEOUT</a>&#160;&#160;&#160;((uint16_t)0x0002U)</td></tr>
<tr class="separator:gaf37e2100563594ba98f5fd4dc6cec58a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga519b5c3a9034340583a257de0d7b2a0e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga519b5c3a9034340583a257de0d7b2a0e">FSI_RX_EVT_CRC_ERR</a>&#160;&#160;&#160;((uint16_t)0x0004U)</td></tr>
<tr class="separator:ga519b5c3a9034340583a257de0d7b2a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef37e9b0b90f8e9c9d3fce61a27f119a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#gaef37e9b0b90f8e9c9d3fce61a27f119a">FSI_RX_EVT_TYPE_ERR</a>&#160;&#160;&#160;((uint16_t)0x0008U)</td></tr>
<tr class="separator:gaef37e9b0b90f8e9c9d3fce61a27f119a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga331545bce87a7270854ee570ae311fba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga331545bce87a7270854ee570ae311fba">FSI_RX_EVT_EOF_ERR</a>&#160;&#160;&#160;((uint16_t)0x0010U)</td></tr>
<tr class="separator:ga331545bce87a7270854ee570ae311fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade40ca98877b5d0e5b28f5894df5771a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#gade40ca98877b5d0e5b28f5894df5771a">FSI_RX_EVT_OVERRUN</a>&#160;&#160;&#160;((uint16_t)0x0020U)</td></tr>
<tr class="separator:gade40ca98877b5d0e5b28f5894df5771a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80eac65dc15f94d3004aca64a87b78ae"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga80eac65dc15f94d3004aca64a87b78ae">FSI_RX_EVT_FRAME_DONE</a>&#160;&#160;&#160;((uint16_t)0x0040U)</td></tr>
<tr class="separator:ga80eac65dc15f94d3004aca64a87b78ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fbdd2d396b247098d76bf23c0e60ef6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga8fbdd2d396b247098d76bf23c0e60ef6">FSI_RX_EVT_UNDERRUN</a>&#160;&#160;&#160;((uint16_t)0x0080U)</td></tr>
<tr class="separator:ga8fbdd2d396b247098d76bf23c0e60ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga486c57de7a46db41a0067dcd670b9619"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga486c57de7a46db41a0067dcd670b9619">FSI_RX_EVT_ERR_FRAME</a>&#160;&#160;&#160;((uint16_t)0x0100U)</td></tr>
<tr class="separator:ga486c57de7a46db41a0067dcd670b9619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa833bd7b609e4af00e2032189315ce41"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#gaa833bd7b609e4af00e2032189315ce41">FSI_RX_EVT_PING_FRAME</a>&#160;&#160;&#160;((uint16_t)0x0200U)</td></tr>
<tr class="separator:gaa833bd7b609e4af00e2032189315ce41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b119b290f62d80390fcdc31c90d129f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga2b119b290f62d80390fcdc31c90d129f">FSI_RX_EVT_FRAME_OVERRUN</a>&#160;&#160;&#160;((uint16_t)0x0400U)</td></tr>
<tr class="separator:ga2b119b290f62d80390fcdc31c90d129f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga868e7e7f1f8b5ec5d02698e068c01531"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga868e7e7f1f8b5ec5d02698e068c01531">FSI_RX_EVT_DATA_FRAME</a>&#160;&#160;&#160;((uint16_t)0x0800U)</td></tr>
<tr class="separator:ga868e7e7f1f8b5ec5d02698e068c01531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5da05b6c193739df52190e07f1f7b9d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#gad5da05b6c193739df52190e07f1f7b9d">FSI_RX_EVTMASK</a>&#160;&#160;&#160;((uint16_t)0x0FFFU)</td></tr>
<tr class="memdesc:gad5da05b6c193739df52190e07f1f7b9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask of all RX Events, ORing all event defines.  <a href="group__DRV__FSI__RX__MODULE.html#gad5da05b6c193739df52190e07f1f7b9d">More...</a><br /></td></tr>
<tr class="separator:gad5da05b6c193739df52190e07f1f7b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60101da363a483b3f313afb4a39e4aac"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga60101da363a483b3f313afb4a39e4aac">FSI_RX_MAX_DELAY_LINE_VAL</a>&#160;&#160;&#160;((uint16_t)0x001FU)</td></tr>
<tr class="memdesc:ga60101da363a483b3f313afb4a39e4aac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum value in RX delay line tap control.  <a href="group__DRV__FSI__RX__MODULE.html#ga60101da363a483b3f313afb4a39e4aac">More...</a><br /></td></tr>
<tr class="separator:ga60101da363a483b3f313afb4a39e4aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
FSI RX submodues that can be reset</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpfd8efabb489e5280fcc473566be205a9"></a><a class="anchor" id="FSI_RxSubmoduleInReset"></a></p>
</td></tr>
<tr class="memitem:ga978e5625bbdab7e0a3532158e18642de"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga978e5625bbdab7e0a3532158e18642de">FSI_RxSubmoduleInReset</a></td></tr>
<tr class="memdesc:ga978e5625bbdab7e0a3532158e18642de"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of RX modules that can be reset, can be used with reset APIs.  <a href="group__DRV__FSI__RX__MODULE.html#ga978e5625bbdab7e0a3532158e18642de">More...</a><br /></td></tr>
<tr class="separator:ga978e5625bbdab7e0a3532158e18642de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d9d8f05d9476fe75cbd83e5529db856"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga1d9d8f05d9476fe75cbd83e5529db856">FSI_RX_MAIN_CORE_RESET</a>&#160;&#160;&#160;((uint32_t)0x0U)</td></tr>
<tr class="separator:ga1d9d8f05d9476fe75cbd83e5529db856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c4e028a2ef8ea33b43d591e2a750ed2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga3c4e028a2ef8ea33b43d591e2a750ed2">FSI_RX_FRAME_WD_CNT_RESET</a>&#160;&#160;&#160;((uint32_t)0x1U)</td></tr>
<tr class="separator:ga3c4e028a2ef8ea33b43d591e2a750ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01f0d38edcb6ee489c2099a4db596a48"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga01f0d38edcb6ee489c2099a4db596a48">FSI_RX_PING_WD_CNT_RESET</a>&#160;&#160;&#160;((uint32_t)0x2U)</td></tr>
<tr class="separator:ga01f0d38edcb6ee489c2099a4db596a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
FSI RX delay tap type</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp13e46c36971d432f2a05fb4478e933cb"></a><a class="anchor" id="FSI_RxDelayTapType"></a></p>
</td></tr>
<tr class="memitem:ga1fbb4d66e61b47962982c0fe4369a311"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga1fbb4d66e61b47962982c0fe4369a311">FSI_RxDelayTapType</a></td></tr>
<tr class="memdesc:ga1fbb4d66e61b47962982c0fe4369a311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Available RX lines for delay tap selection.  <a href="group__DRV__FSI__RX__MODULE.html#ga1fbb4d66e61b47962982c0fe4369a311">More...</a><br /></td></tr>
<tr class="separator:ga1fbb4d66e61b47962982c0fe4369a311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga422246cd0a7f942e98e4a8dbd324cb23"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga422246cd0a7f942e98e4a8dbd324cb23">FSI_RX_DELAY_CLK</a>&#160;&#160;&#160;((uint32_t)0x0U)</td></tr>
<tr class="separator:ga422246cd0a7f942e98e4a8dbd324cb23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a8832e1ee2f13e0614ab7764190b16b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga3a8832e1ee2f13e0614ab7764190b16b">FSI_RX_DELAY_D0</a>&#160;&#160;&#160;((uint32_t)0x1U)</td></tr>
<tr class="separator:ga3a8832e1ee2f13e0614ab7764190b16b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ebced2f639d394af512bb1e9d5d0dd8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga1ebced2f639d394af512bb1e9d5d0dd8">FSI_RX_DELAY_D1</a>&#160;&#160;&#160;((uint32_t)0x2U)</td></tr>
<tr class="separator:ga1ebced2f639d394af512bb1e9d5d0dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
FSI external frame trigger source</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp73d0b2fe036315b96fc0429e2f38aa59"></a><a class="anchor" id="FSI_ExtFrameTriggerSrc"></a></p>
</td></tr>
<tr class="memitem:ga33e4bf3c53ecdd37e0fe606367e87df8"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga33e4bf3c53ecdd37e0fe606367e87df8">FSI_ExtFrameTriggerSrc</a></td></tr>
<tr class="memdesc:ga33e4bf3c53ecdd37e0fe606367e87df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indexes of available EPWM SOC triggers.  <a href="group__DRV__FSI__RX__MODULE.html#ga33e4bf3c53ecdd37e0fe606367e87df8">More...</a><br /></td></tr>
<tr class="separator:ga33e4bf3c53ecdd37e0fe606367e87df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5aaa2cbd49804f8dcfbb40c326b282eb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga5aaa2cbd49804f8dcfbb40c326b282eb">FSI_EXT_TRIGSRC_EPWM1_SOCA</a>&#160;&#160;&#160;((uint32_t)0x08U)</td></tr>
<tr class="separator:ga5aaa2cbd49804f8dcfbb40c326b282eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02bb16fec1858b6de22bd3a83b44d766"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga02bb16fec1858b6de22bd3a83b44d766">FSI_EXT_TRIGSRC_EPWM1_SOCB</a>&#160;&#160;&#160;((uint32_t)0x09U)</td></tr>
<tr class="separator:ga02bb16fec1858b6de22bd3a83b44d766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3e05537ef1d32c5d69fca8e8fb3d508"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#gab3e05537ef1d32c5d69fca8e8fb3d508">FSI_EXT_TRIGSRC_EPWM2_SOCA</a>&#160;&#160;&#160;((uint32_t)0x0AU)</td></tr>
<tr class="separator:gab3e05537ef1d32c5d69fca8e8fb3d508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fa49147eab91a1b77dd006b0af9573e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga9fa49147eab91a1b77dd006b0af9573e">FSI_EXT_TRIGSRC_EPWM2_SOCB</a>&#160;&#160;&#160;((uint32_t)0x0BU)</td></tr>
<tr class="separator:ga9fa49147eab91a1b77dd006b0af9573e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5243e5004029640298b6af3fe4b46712"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga5243e5004029640298b6af3fe4b46712">FSI_EXT_TRIGSRC_EPWM3_SOCA</a>&#160;&#160;&#160;((uint32_t)0x0CU)</td></tr>
<tr class="separator:ga5243e5004029640298b6af3fe4b46712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88c6f5903799f7c6d9ceb77f8bec8f5e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga88c6f5903799f7c6d9ceb77f8bec8f5e">FSI_EXT_TRIGSRC_EPWM3_SOCB</a>&#160;&#160;&#160;((uint32_t)0x0DU)</td></tr>
<tr class="separator:ga88c6f5903799f7c6d9ceb77f8bec8f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb115ba4c91fc648355a367f4f4e4286"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#gabb115ba4c91fc648355a367f4f4e4286">FSI_EXT_TRIGSRC_EPWM4_SOCA</a>&#160;&#160;&#160;((uint32_t)0x0EU)</td></tr>
<tr class="separator:gabb115ba4c91fc648355a367f4f4e4286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6ff0727a24ee83364ceba2bac35f60e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#gaf6ff0727a24ee83364ceba2bac35f60e">FSI_EXT_TRIGSRC_EPWM4_SOCB</a>&#160;&#160;&#160;((uint32_t)0x0FU)</td></tr>
<tr class="separator:gaf6ff0727a24ee83364ceba2bac35f60e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad30e0061c4319420bd61b113bed1b4e4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#gad30e0061c4319420bd61b113bed1b4e4">FSI_EXT_TRIGSRC_EPWM5_SOCA</a>&#160;&#160;&#160;((uint32_t)0x10U)</td></tr>
<tr class="separator:gad30e0061c4319420bd61b113bed1b4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36434b151f30e0763aaca4be4e10ea6b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga36434b151f30e0763aaca4be4e10ea6b">FSI_EXT_TRIGSRC_EPWM5_SOCB</a>&#160;&#160;&#160;((uint32_t)0x11U)</td></tr>
<tr class="separator:ga36434b151f30e0763aaca4be4e10ea6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga902a62a7153a26f0f43dca69d5d1e82a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga902a62a7153a26f0f43dca69d5d1e82a">FSI_EXT_TRIGSRC_EPWM6_SOCA</a>&#160;&#160;&#160;((uint32_t)0x12U)</td></tr>
<tr class="separator:ga902a62a7153a26f0f43dca69d5d1e82a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga488eff08a0ae522ee7614b73e922cd96"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga488eff08a0ae522ee7614b73e922cd96">FSI_EXT_TRIGSRC_EPWM6_SOCB</a>&#160;&#160;&#160;((uint32_t)0x13U)</td></tr>
<tr class="separator:ga488eff08a0ae522ee7614b73e922cd96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99c1db6e4fe2f4a7c55c771438df45e4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga99c1db6e4fe2f4a7c55c771438df45e4">FSI_EXT_TRIGSRC_EPWM7_SOCA</a>&#160;&#160;&#160;((uint32_t)0x14U)</td></tr>
<tr class="separator:ga99c1db6e4fe2f4a7c55c771438df45e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf8f8a0769b99ce39b1d39d8c0cb7f0c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#gacf8f8a0769b99ce39b1d39d8c0cb7f0c">FSI_EXT_TRIGSRC_EPWM7_SOCB</a>&#160;&#160;&#160;((uint32_t)0x15U)</td></tr>
<tr class="separator:gacf8f8a0769b99ce39b1d39d8c0cb7f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46bacdf403712125fef9c9a116724115"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga46bacdf403712125fef9c9a116724115">FSI_EXT_TRIGSRC_EPWM8_SOCA</a>&#160;&#160;&#160;((uint32_t)0x16U)</td></tr>
<tr class="separator:ga46bacdf403712125fef9c9a116724115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3abe25611f1aa59f554d666141031ef6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga3abe25611f1aa59f554d666141031ef6">FSI_EXT_TRIGSRC_EPWM8_SOCB</a>&#160;&#160;&#160;((uint32_t)0x17U)</td></tr>
<tr class="separator:ga3abe25611f1aa59f554d666141031ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gae3bb15cce2a6c3d21dc8675314aff8e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3bb15cce2a6c3d21dc8675314aff8e7">&#9670;&nbsp;</a></span>FSI_RX_EVT_PING_WD_TIMEOUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_RX_EVT_PING_WD_TIMEOUT&#160;&#160;&#160;((uint16_t)0x0001U)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaf37e2100563594ba98f5fd4dc6cec58a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf37e2100563594ba98f5fd4dc6cec58a">&#9670;&nbsp;</a></span>FSI_RX_EVT_FRAME_WD_TIMEOUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_RX_EVT_FRAME_WD_TIMEOUT&#160;&#160;&#160;((uint16_t)0x0002U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RX ping watchdog times out event </p>

</div>
</div>
<a id="ga519b5c3a9034340583a257de0d7b2a0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga519b5c3a9034340583a257de0d7b2a0e">&#9670;&nbsp;</a></span>FSI_RX_EVT_CRC_ERR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_RX_EVT_CRC_ERR&#160;&#160;&#160;((uint16_t)0x0004U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RX frame watchdog times out event </p>

</div>
</div>
<a id="gaef37e9b0b90f8e9c9d3fce61a27f119a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef37e9b0b90f8e9c9d3fce61a27f119a">&#9670;&nbsp;</a></span>FSI_RX_EVT_TYPE_ERR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_RX_EVT_TYPE_ERR&#160;&#160;&#160;((uint16_t)0x0008U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RX frame CRC error event </p>

</div>
</div>
<a id="ga331545bce87a7270854ee570ae311fba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga331545bce87a7270854ee570ae311fba">&#9670;&nbsp;</a></span>FSI_RX_EVT_EOF_ERR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_RX_EVT_EOF_ERR&#160;&#160;&#160;((uint16_t)0x0010U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RX frame invalid Frame type event </p>

</div>
</div>
<a id="gade40ca98877b5d0e5b28f5894df5771a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade40ca98877b5d0e5b28f5894df5771a">&#9670;&nbsp;</a></span>FSI_RX_EVT_OVERRUN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_RX_EVT_OVERRUN&#160;&#160;&#160;((uint16_t)0x0020U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RX frame invalid End of Frame event </p>

</div>
</div>
<a id="ga80eac65dc15f94d3004aca64a87b78ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80eac65dc15f94d3004aca64a87b78ae">&#9670;&nbsp;</a></span>FSI_RX_EVT_FRAME_DONE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_RX_EVT_FRAME_DONE&#160;&#160;&#160;((uint16_t)0x0040U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RX frame buffer overrun event </p>

</div>
</div>
<a id="ga8fbdd2d396b247098d76bf23c0e60ef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8fbdd2d396b247098d76bf23c0e60ef6">&#9670;&nbsp;</a></span>FSI_RX_EVT_UNDERRUN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_RX_EVT_UNDERRUN&#160;&#160;&#160;((uint16_t)0x0080U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RX frame done without errors event </p>

</div>
</div>
<a id="ga486c57de7a46db41a0067dcd670b9619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga486c57de7a46db41a0067dcd670b9619">&#9670;&nbsp;</a></span>FSI_RX_EVT_ERR_FRAME</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_RX_EVT_ERR_FRAME&#160;&#160;&#160;((uint16_t)0x0100U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Software reads empty RX buffer event </p>

</div>
</div>
<a id="gaa833bd7b609e4af00e2032189315ce41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa833bd7b609e4af00e2032189315ce41">&#9670;&nbsp;</a></span>FSI_RX_EVT_PING_FRAME</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_RX_EVT_PING_FRAME&#160;&#160;&#160;((uint16_t)0x0200U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RX error frame event </p>

</div>
</div>
<a id="ga2b119b290f62d80390fcdc31c90d129f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b119b290f62d80390fcdc31c90d129f">&#9670;&nbsp;</a></span>FSI_RX_EVT_FRAME_OVERRUN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_RX_EVT_FRAME_OVERRUN&#160;&#160;&#160;((uint16_t)0x0400U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RX ping frame event </p>

</div>
</div>
<a id="ga868e7e7f1f8b5ec5d02698e068c01531"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga868e7e7f1f8b5ec5d02698e068c01531">&#9670;&nbsp;</a></span>FSI_RX_EVT_DATA_FRAME</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_RX_EVT_DATA_FRAME&#160;&#160;&#160;((uint16_t)0x0800U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Software didn't clear FRAME_DONE flag after receiving new frame event </p>

</div>
</div>
<a id="gad5da05b6c193739df52190e07f1f7b9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5da05b6c193739df52190e07f1f7b9d">&#9670;&nbsp;</a></span>FSI_RX_EVTMASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_RX_EVTMASK&#160;&#160;&#160;((uint16_t)0x0FFFU)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mask of all RX Events, ORing all event defines. </p>
<p>RX data frame event </p>

</div>
</div>
<a id="ga60101da363a483b3f313afb4a39e4aac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60101da363a483b3f313afb4a39e4aac">&#9670;&nbsp;</a></span>FSI_RX_MAX_DELAY_LINE_VAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_RX_MAX_DELAY_LINE_VAL&#160;&#160;&#160;((uint16_t)0x001FU)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum value in RX delay line tap control. </p>

</div>
</div>
<a id="ga1d9d8f05d9476fe75cbd83e5529db856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d9d8f05d9476fe75cbd83e5529db856">&#9670;&nbsp;</a></span>FSI_RX_MAIN_CORE_RESET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_RX_MAIN_CORE_RESET&#160;&#160;&#160;((uint32_t)0x0U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RX controller core reset </p>

</div>
</div>
<a id="ga3c4e028a2ef8ea33b43d591e2a750ed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c4e028a2ef8ea33b43d591e2a750ed2">&#9670;&nbsp;</a></span>FSI_RX_FRAME_WD_CNT_RESET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_RX_FRAME_WD_CNT_RESET&#160;&#160;&#160;((uint32_t)0x1U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RX frame watchdog counter reset </p>

</div>
</div>
<a id="ga01f0d38edcb6ee489c2099a4db596a48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01f0d38edcb6ee489c2099a4db596a48">&#9670;&nbsp;</a></span>FSI_RX_PING_WD_CNT_RESET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_RX_PING_WD_CNT_RESET&#160;&#160;&#160;((uint32_t)0x2U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RX ping watchdog counter reset </p>

</div>
</div>
<a id="ga422246cd0a7f942e98e4a8dbd324cb23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga422246cd0a7f942e98e4a8dbd324cb23">&#9670;&nbsp;</a></span>FSI_RX_DELAY_CLK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_RX_DELAY_CLK&#160;&#160;&#160;((uint32_t)0x0U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RX CLK line delay tap </p>

</div>
</div>
<a id="ga3a8832e1ee2f13e0614ab7764190b16b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a8832e1ee2f13e0614ab7764190b16b">&#9670;&nbsp;</a></span>FSI_RX_DELAY_D0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_RX_DELAY_D0&#160;&#160;&#160;((uint32_t)0x1U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RX D0 line delay tap </p>

</div>
</div>
<a id="ga1ebced2f639d394af512bb1e9d5d0dd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ebced2f639d394af512bb1e9d5d0dd8">&#9670;&nbsp;</a></span>FSI_RX_DELAY_D1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_RX_DELAY_D1&#160;&#160;&#160;((uint32_t)0x2U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RX D1 line delay tap </p>

</div>
</div>
<a id="ga5aaa2cbd49804f8dcfbb40c326b282eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5aaa2cbd49804f8dcfbb40c326b282eb">&#9670;&nbsp;</a></span>FSI_EXT_TRIGSRC_EPWM1_SOCA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_EXT_TRIGSRC_EPWM1_SOCA&#160;&#160;&#160;((uint32_t)0x08U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>FSI external trigger source for ePWM1 SOCA </p>

</div>
</div>
<a id="ga02bb16fec1858b6de22bd3a83b44d766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02bb16fec1858b6de22bd3a83b44d766">&#9670;&nbsp;</a></span>FSI_EXT_TRIGSRC_EPWM1_SOCB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_EXT_TRIGSRC_EPWM1_SOCB&#160;&#160;&#160;((uint32_t)0x09U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>FSI external trigger source for ePWM1 SOCB </p>

</div>
</div>
<a id="gab3e05537ef1d32c5d69fca8e8fb3d508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3e05537ef1d32c5d69fca8e8fb3d508">&#9670;&nbsp;</a></span>FSI_EXT_TRIGSRC_EPWM2_SOCA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_EXT_TRIGSRC_EPWM2_SOCA&#160;&#160;&#160;((uint32_t)0x0AU)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>FSI external trigger source for ePWM2 SOCA </p>

</div>
</div>
<a id="ga9fa49147eab91a1b77dd006b0af9573e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9fa49147eab91a1b77dd006b0af9573e">&#9670;&nbsp;</a></span>FSI_EXT_TRIGSRC_EPWM2_SOCB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_EXT_TRIGSRC_EPWM2_SOCB&#160;&#160;&#160;((uint32_t)0x0BU)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>FSI external trigger source for ePWM2 SOCB </p>

</div>
</div>
<a id="ga5243e5004029640298b6af3fe4b46712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5243e5004029640298b6af3fe4b46712">&#9670;&nbsp;</a></span>FSI_EXT_TRIGSRC_EPWM3_SOCA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_EXT_TRIGSRC_EPWM3_SOCA&#160;&#160;&#160;((uint32_t)0x0CU)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>FSI external trigger source for ePWM3 SOCA </p>

</div>
</div>
<a id="ga88c6f5903799f7c6d9ceb77f8bec8f5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88c6f5903799f7c6d9ceb77f8bec8f5e">&#9670;&nbsp;</a></span>FSI_EXT_TRIGSRC_EPWM3_SOCB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_EXT_TRIGSRC_EPWM3_SOCB&#160;&#160;&#160;((uint32_t)0x0DU)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>FSI external trigger source for ePWM3 SOCB </p>

</div>
</div>
<a id="gabb115ba4c91fc648355a367f4f4e4286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb115ba4c91fc648355a367f4f4e4286">&#9670;&nbsp;</a></span>FSI_EXT_TRIGSRC_EPWM4_SOCA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_EXT_TRIGSRC_EPWM4_SOCA&#160;&#160;&#160;((uint32_t)0x0EU)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>FSI external trigger source for ePWM4 SOCA </p>

</div>
</div>
<a id="gaf6ff0727a24ee83364ceba2bac35f60e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6ff0727a24ee83364ceba2bac35f60e">&#9670;&nbsp;</a></span>FSI_EXT_TRIGSRC_EPWM4_SOCB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_EXT_TRIGSRC_EPWM4_SOCB&#160;&#160;&#160;((uint32_t)0x0FU)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>FSI external trigger source for ePWM4 SOCB </p>

</div>
</div>
<a id="gad30e0061c4319420bd61b113bed1b4e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad30e0061c4319420bd61b113bed1b4e4">&#9670;&nbsp;</a></span>FSI_EXT_TRIGSRC_EPWM5_SOCA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_EXT_TRIGSRC_EPWM5_SOCA&#160;&#160;&#160;((uint32_t)0x10U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>FSI external trigger source for ePWM5 SOCA </p>

</div>
</div>
<a id="ga36434b151f30e0763aaca4be4e10ea6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36434b151f30e0763aaca4be4e10ea6b">&#9670;&nbsp;</a></span>FSI_EXT_TRIGSRC_EPWM5_SOCB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_EXT_TRIGSRC_EPWM5_SOCB&#160;&#160;&#160;((uint32_t)0x11U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>FSI external trigger source for ePWM5 SOCB </p>

</div>
</div>
<a id="ga902a62a7153a26f0f43dca69d5d1e82a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga902a62a7153a26f0f43dca69d5d1e82a">&#9670;&nbsp;</a></span>FSI_EXT_TRIGSRC_EPWM6_SOCA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_EXT_TRIGSRC_EPWM6_SOCA&#160;&#160;&#160;((uint32_t)0x12U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>FSI external trigger source for ePWM6 SOCA </p>

</div>
</div>
<a id="ga488eff08a0ae522ee7614b73e922cd96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga488eff08a0ae522ee7614b73e922cd96">&#9670;&nbsp;</a></span>FSI_EXT_TRIGSRC_EPWM6_SOCB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_EXT_TRIGSRC_EPWM6_SOCB&#160;&#160;&#160;((uint32_t)0x13U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>FSI external trigger source for ePWM6 SOCB </p>

</div>
</div>
<a id="ga99c1db6e4fe2f4a7c55c771438df45e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99c1db6e4fe2f4a7c55c771438df45e4">&#9670;&nbsp;</a></span>FSI_EXT_TRIGSRC_EPWM7_SOCA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_EXT_TRIGSRC_EPWM7_SOCA&#160;&#160;&#160;((uint32_t)0x14U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>FSI external trigger source for ePWM7 SOCA </p>

</div>
</div>
<a id="gacf8f8a0769b99ce39b1d39d8c0cb7f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf8f8a0769b99ce39b1d39d8c0cb7f0c">&#9670;&nbsp;</a></span>FSI_EXT_TRIGSRC_EPWM7_SOCB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_EXT_TRIGSRC_EPWM7_SOCB&#160;&#160;&#160;((uint32_t)0x15U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>FSI external trigger source for ePWM7 SOCB </p>

</div>
</div>
<a id="ga46bacdf403712125fef9c9a116724115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46bacdf403712125fef9c9a116724115">&#9670;&nbsp;</a></span>FSI_EXT_TRIGSRC_EPWM8_SOCA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_EXT_TRIGSRC_EPWM8_SOCA&#160;&#160;&#160;((uint32_t)0x16U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>FSI external trigger source for ePWM8 SOCA </p>

</div>
</div>
<a id="ga3abe25611f1aa59f554d666141031ef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3abe25611f1aa59f554d666141031ef6">&#9670;&nbsp;</a></span>FSI_EXT_TRIGSRC_EPWM8_SOCB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_EXT_TRIGSRC_EPWM8_SOCB&#160;&#160;&#160;((uint32_t)0x17U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>FSI external trigger source for ePWM8 SOCB </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gafdfea7397b8c8492c1d5fdc5d54b70c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdfea7397b8c8492c1d5fdc5d54b70c5">&#9670;&nbsp;</a></span>FSI_RxEnumType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="group__DRV__FSI__RX__MODULE.html#gafdfea7397b8c8492c1d5fdc5d54b70c5">FSI_RxEnumType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This enumerator defines the types of possible FSI RX events. </p>
<p>Values that can be passed to APIs to enable/disable interrupts and also to set/get/clear event status on FSI RX operation.</p>
<p>There are 12 supported interrupts related to RX events, all are available as event status as well. 1) ping watchdog times out 2) frame watchdog times out 3) mismatch between hardware computed CRC and received CRC.This status should be ignored if user chooses SW CRC computation 4) invalid Frame type detected 5) invalid EndofFrame bit-pattern 6) buffer Overrun in RX buffer 7) received frame without errors 8) software reads empty RX buffer 9) received error frame 10) received ping frame 11) software didn't clear FRAME_DONE flag after receiving new frame 12) received data frame </p>

</div>
</div>
<a id="ga978e5625bbdab7e0a3532158e18642de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga978e5625bbdab7e0a3532158e18642de">&#9670;&nbsp;</a></span>FSI_RxSubmoduleInReset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="group__DRV__FSI__RX__MODULE.html#ga978e5625bbdab7e0a3532158e18642de">FSI_RxSubmoduleInReset</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of RX modules that can be reset, can be used with reset APIs. </p>
<p><br  />
 Three submodules can be reset- 1) RX controller core 2) frame watchdog counter 3) ping watchdog counter </p>

</div>
</div>
<a id="ga1fbb4d66e61b47962982c0fe4369a311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fbb4d66e61b47962982c0fe4369a311">&#9670;&nbsp;</a></span>FSI_RxDelayTapType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="group__DRV__FSI__RX__MODULE.html#ga1fbb4d66e61b47962982c0fe4369a311">FSI_RxDelayTapType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Available RX lines for delay tap selection. </p>
<p><br  />
 Delay tapping can be done on 3 lines: 1) RXCLK 2) RXD0 3) RXD1 </p>

</div>
</div>
<a id="ga33e4bf3c53ecdd37e0fe606367e87df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33e4bf3c53ecdd37e0fe606367e87df8">&#9670;&nbsp;</a></span>FSI_ExtFrameTriggerSrc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="group__DRV__FSI__RX__MODULE.html#ga33e4bf3c53ecdd37e0fe606367e87df8">FSI_ExtFrameTriggerSrc</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indexes of available EPWM SOC triggers. </p>
<p><br  />
 There are 16 ePWM SOC events as external triggers for FSI frame transfers. Indexes 0:7 and 24:31 are reserved out of total 32 muxed external triggers. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga9170cb7041f53ce30ef98b43e93f0341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9170cb7041f53ce30ef98b43e93f0341">&#9670;&nbsp;</a></span>FSI_enableRxInternalLoopback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_enableRxInternalLoopback </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enables internal loopback where mux will select internal pins coming from RX module instead of what comes from pins. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI RX module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="ga1b7a943ddcbf826956eefbf695de389f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b7a943ddcbf826956eefbf695de389f">&#9670;&nbsp;</a></span>FSI_disableRxInternalLoopback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_disableRxInternalLoopback </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API disables internal loopback where mux will not use internal pins coming from RX module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI RX module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="gaa95f308ee65bdd9c1affeb8c8c795c0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa95f308ee65bdd9c1affeb8c8c795c0b">&#9670;&nbsp;</a></span>FSI_enableRxSPIPairing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_enableRxSPIPairing </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enables SPI clock paring, receive clock is selected from the internal port coming from RX module. </p>
<p><br  />
 This API is only applicable when communicating with a SPI interface</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI RX module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="gaa1e82e3b939a5b67d609fa53792cb6a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1e82e3b939a5b67d609fa53792cb6a5">&#9670;&nbsp;</a></span>FSI_disableRxSPIPairing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_disableRxSPIPairing </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API disables SPI clock paring, selects regular receive clock coming from the pins. </p>
<p><br  />
 This API is only applicable when communicating with a SPI interface</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI RX module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="gadb4886595a1ec142928bc4bd3f23a3fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb4886595a1ec142928bc4bd3f23a3fe">&#9670;&nbsp;</a></span>FSI_setRxDataWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_setRxDataWidth </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DRV__FSI__MODULE.html#ga5dbdfd7ff13523f74955cbb7707726f2">FSI_DataWidth</a>&#160;</td>
          <td class="paramname"><em>dataWidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API selects number of data lines used for receiving. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI RX module. </td></tr>
    <tr><td class="paramname">dataWidth</td><td>[IN] Data lines used for RX operation refer <a class="el" href="group__DRV__FSI__MODULE.html#ga5dbdfd7ff13523f74955cbb7707726f2" title="Data lines used for transmit/receive operation.">FSI_DataWidth</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="ga799d369814a32f0f8feea6f7162b565d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga799d369814a32f0f8feea6f7162b565d">&#9670;&nbsp;</a></span>FSI_enableRxSPIMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_enableRxSPIMode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enables SPI compatible mode in FSI RX. </p>
<p><br  />
 This API is only applicable when communicating with a SPI interface</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI RX module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="ga92dfc172f14081ef48cd952268761d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92dfc172f14081ef48cd952268761d64">&#9670;&nbsp;</a></span>FSI_disableRxSPIMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_disableRxSPIMode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API disables SPI compatible mode in FSI RX. </p>
<p><br  />
 This API is only applicable when communicating with a SPI interface</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI RX module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="gae2ae3a2c55ebc558548d25592f603063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2ae3a2c55ebc558548d25592f603063">&#9670;&nbsp;</a></span>FSI_setRxSoftwareFrameSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_setRxSoftwareFrameSize </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nWords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API sets the RX frame size if frame type is user/software defined frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI RX module. </td></tr>
    <tr><td class="paramname">nWords</td><td>[IN] number of data words in a software defined frame.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="ga082dd17b9a156637bf7a1be67f132a08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga082dd17b9a156637bf7a1be67f132a08">&#9670;&nbsp;</a></span>FSI_setRxECCComputeWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_setRxECCComputeWidth </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fsi_2v0_2fsi_8h.html#aa3bcb498544ab9219714d4531ebcadb9">FSI_ECCComputeWidth</a>&#160;</td>
          <td class="paramname"><em>eccComputeWidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API select between 16-bit and 32-bit ECC computation for FSI RX. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI RX module. </td></tr>
    <tr><td class="paramname">eccComputeWidth</td><td>[IN] Refer <a class="el" href="fsi_2v0_2fsi_8h.html#aa3bcb498544ab9219714d4531ebcadb9" title="ECC Computation width - 16 bit or 32 bit.">FSI_ECCComputeWidth</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="ga341c89644305e257e0bf0146aefbce07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga341c89644305e257e0bf0146aefbce07">&#9670;&nbsp;</a></span>FSI_setRxPingTimeoutMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_setRxPingTimeoutMode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fsi_2v0_2fsi_8h.html#a3008502af132b9be684563c208957180">FSI_PingTimeoutMode</a>&#160;</td>
          <td class="paramname"><em>pingTimeoutMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API sets HW/SW initiated RX ping timeout mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI RX module. </td></tr>
    <tr><td class="paramname">pingTimeoutMode</td><td>[IN] Refer <a class="el" href="fsi_2v0_2fsi_8h.html#a3008502af132b9be684563c208957180" title="FSI ping timeout mode.">FSI_PingTimeoutMode</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="gafa302e1bdee44a932faa9ad9b84e1a7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa302e1bdee44a932faa9ad9b84e1a7d">&#9670;&nbsp;</a></span>FSI_getRxFrameType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_getRxFrameType </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fsi_2v0_2fsi_8h.html#a5d351d5afbe8aa861a52ebcd12a91b38">FSI_FrameType</a> *&#160;</td>
          <td class="paramname"><em>pFrameType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API gets frame type received in the last successful frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI RX module. </td></tr>
    <tr><td class="paramname">pFrameType</td><td>[OUT] Pointer to the RX frame type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="ga2adadf70ac8a389cd9254113687a426f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2adadf70ac8a389cd9254113687a426f">&#9670;&nbsp;</a></span>FSI_getRxFrameTag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_getRxFrameTag </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>pFrameTag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API gets frame tag received for the last successful frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI RX module. </td></tr>
    <tr><td class="paramname">pFrameTag</td><td>[OUT] Pointer to the RX frame tag.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="gae0eb1f3b88ec70f6ace95e281df77436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0eb1f3b88ec70f6ace95e281df77436">&#9670;&nbsp;</a></span>FSI_getRxUserDefinedData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_getRxUserDefinedData </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>pUserData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API gets User-Data (8-bit) field for received data frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI RX module. </td></tr>
    <tr><td class="paramname">pUserData</td><td>[OUT] Pointer to the user data value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="ga3283e8dbd6bb4d2a8be106a568555429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3283e8dbd6bb4d2a8be106a568555429">&#9670;&nbsp;</a></span>FSI_getRxEventStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_getRxEventStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>pEvtFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API gets current status of all the event/error flags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI RX module </td></tr>
    <tr><td class="paramname">pEvtFlags</td><td>[OUT] Pointer to status of event/error flags, each bit of integer is associated with one error flag</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="ga79226282f5a52b140a6db84c1249e8d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79226282f5a52b140a6db84c1249e8d3">&#9670;&nbsp;</a></span>FSI_forceRxEvents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_forceRxEvents </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>evtFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enables user to set RX event/error flags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI RX module </td></tr>
    <tr><td class="paramname">evtFlags</td><td>[IN] event/error flags to be set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="ga7f1e7abd5645688b2e6b9c2af0ecfad2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f1e7abd5645688b2e6b9c2af0ecfad2">&#9670;&nbsp;</a></span>FSI_clearRxEvents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_clearRxEvents </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>evtFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enables user to clear RX event/error flags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI RX module </td></tr>
    <tr><td class="paramname">evtFlags</td><td>[IN] event/error flags to be cleared</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="ga47a14b1ff5bf952b0ccd69773420cc56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47a14b1ff5bf952b0ccd69773420cc56">&#9670;&nbsp;</a></span>FSI_getRxReceivedCRC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_getRxReceivedCRC </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>pCrcVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API gets CRC value received in data frame/frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI RX module </td></tr>
    <tr><td class="paramname">pCrcVal</td><td>[OUT] Pointer to CRC value received in data frame</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="gadb532f34d758864d0c4d5c129f852940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb532f34d758864d0c4d5c129f852940">&#9670;&nbsp;</a></span>FSI_getRxComputedCRC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_getRxComputedCRC </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>pCrcVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API gets CRC value computed for data received. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI RX module </td></tr>
    <tr><td class="paramname">pCrcVal</td><td>[OUT] Pointer to CRC value computed on received data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="ga44b4cb2f8cc74371fbef6f8812460d5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44b4cb2f8cc74371fbef6f8812460d5d">&#9670;&nbsp;</a></span>FSI_setRxBufferPtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_setRxBufferPtr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>bufPtrOff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API sets the value for receive buffer pointer at desired location. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI RX module </td></tr>
    <tr><td class="paramname">bufPtrOff</td><td>[IN] 4 bit offset pointer in RX buffer from where received data will be read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="ga9fe90c3f09affc730820643a3005d5a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9fe90c3f09affc730820643a3005d5a2">&#9670;&nbsp;</a></span>FSI_getRxBufferPtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_getRxBufferPtr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>pBufPtrLoc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API gets current buffer pointer location. </p>
<p><br  />
 There could be lag due to synchronization, hence value is accurate only when no current reception is happening</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI RX module </td></tr>
    <tr><td class="paramname">pBufPtrLoc</td><td>[OUT] Pointer to current buffer pointer location</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="ga12c3900957d62d91e52f804596cacc82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12c3900957d62d91e52f804596cacc82">&#9670;&nbsp;</a></span>FSI_getRxWordCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_getRxWordCount </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>pWordCnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API gets valid number of data words present in buffer which have not been read out yet. </p>
<p><br  />
 There could be lag due to synchronization, hence value is accurate only when no current reception is happening</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI RX module </td></tr>
    <tr><td class="paramname">pWordCnt</td><td>[OUT] Pointer to number of data words present in buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="ga6fe38e8b22684c6400a05692aa56e8c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fe38e8b22684c6400a05692aa56e8c3">&#9670;&nbsp;</a></span>FSI_enableRxFrameWatchdog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_enableRxFrameWatchdog </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>wdRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enables the frame watchdog counter logic to count every time it start to receive a frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI RX module </td></tr>
    <tr><td class="paramname">wdRef</td><td>[IN] reference value for frame watchdog time-out counter</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="ga405729ef78cb96a329e2890d7ab74c35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga405729ef78cb96a329e2890d7ab74c35">&#9670;&nbsp;</a></span>FSI_disableRxFrameWatchdog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_disableRxFrameWatchdog </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API disables the frame watchdog counter logic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI RX module</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="ga01346af9ba768810f6caeb29775698be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01346af9ba768810f6caeb29775698be">&#9670;&nbsp;</a></span>FSI_getRxFrameWatchdogCounter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_getRxFrameWatchdogCounter </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pWdCnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API gets current value of frame watchdog counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI RX module </td></tr>
    <tr><td class="paramname">pWdCnt</td><td>[OUT] Pointer to current value of frame watchdog counter</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="gac1cc3fbc0a5c12d8f1cbde53afb7b7bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1cc3fbc0a5c12d8f1cbde53afb7b7bb">&#9670;&nbsp;</a></span>FSI_enableRxPingWatchdog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_enableRxPingWatchdog </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>wdRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enables the ping watchdog counter logic and once the set time elapses it will indicate ping watchdog time-out has occurred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI RX module </td></tr>
    <tr><td class="paramname">wdRef</td><td>[IN] reference value for ping watchdog time-out counter</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="ga0aaa3527c9181a56c93cb2701dbe7b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0aaa3527c9181a56c93cb2701dbe7b73">&#9670;&nbsp;</a></span>FSI_disableRxPingWatchdog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_disableRxPingWatchdog </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API disables the ping watchdog counter logic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI RX module</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="gaab15bffd0c7133f8a98909c251324e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab15bffd0c7133f8a98909c251324e43">&#9670;&nbsp;</a></span>FSI_getRxPingWatchdogCounter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_getRxPingWatchdogCounter </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pWdCnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API gets current value of ping watchdog counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI RX module </td></tr>
    <tr><td class="paramname">pWdCnt</td><td>[OUT] Pointer to current value of ping watchdog counter</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="ga263b308924c40f1bb4102527f4edf8ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga263b308924c40f1bb4102527f4edf8ea">&#9670;&nbsp;</a></span>FSI_getRxPingTag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_getRxPingTag </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>pPingTag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API gets the value of tag received for last ping frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI RX module </td></tr>
    <tr><td class="paramname">pPingTag</td><td>[OUT] Pointer to ping frame tag value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="ga2761253b24833ec34428bf0b6aa96b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2761253b24833ec34428bf0b6aa96b6d">&#9670;&nbsp;</a></span>FSI_lockRxCtrl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_lockRxCtrl </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API locks the control of all receive control registers, once locked further writes will not take effect until system reset occurs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI RX module</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="gaa8f814eba73aa210f74de7d9a5964609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8f814eba73aa210f74de7d9a5964609">&#9670;&nbsp;</a></span>FSI_setRxECCData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_setRxECCData </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rxECCdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API sets RX ECC data on which ECC (SEC-DED) computaion logic runs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI RX module </td></tr>
    <tr><td class="paramname">rxECCdata</td><td>[IN] RX ECC data for ECC logic</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="gae9842c1684646d5d1be7d7b54fcfb9f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9842c1684646d5d1be7d7b54fcfb9f5">&#9670;&nbsp;</a></span>FSI_setRxReceivedECCValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_setRxReceivedECCValue </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>rxECCvalue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API sets received ECC value on which ECC (SEC-DED) computaion logic runs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI RX module </td></tr>
    <tr><td class="paramname">rxECCvalue</td><td>[IN] Received ECC value in a data frame</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="ga299a4d417435db13121de988d89d4b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga299a4d417435db13121de988d89d4b5e">&#9670;&nbsp;</a></span>FSI_getRxECCCorrectedData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_getRxECCCorrectedData </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pEccData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API gets ECC corrected data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI RX module </td></tr>
    <tr><td class="paramname">pEccData</td><td>[OUT] Pointer to 32 bit ECC corrected data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="ga38ec620ec2c4148b393a7a816652c447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38ec620ec2c4148b393a7a816652c447">&#9670;&nbsp;</a></span>FSI_getRxECCLog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_getRxECCLog </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>pEccLog</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API gets ECC Log details. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI RX module </td></tr>
    <tr><td class="paramname">pEccLog</td><td>[OUT] Pointer to ECC Log value (8 bit)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="gab84bef42f754fed3e890c000371e502b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab84bef42f754fed3e890c000371e502b">&#9670;&nbsp;</a></span>FSI_enableRxInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_enableRxInterrupt </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fsi_2v0_2fsi_8h.html#ad3a8bd4711243054c29b3215a9f05b6c">FSI_InterruptNum</a>&#160;</td>
          <td class="paramname"><em>intNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>intFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enables user to generate interrupt on occurrence of RX events. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI RX module </td></tr>
    <tr><td class="paramname">intNum</td><td>[IN] Type of interrupt to be generated, INT1 or INT2, refer <a class="el" href="fsi_2v0_2fsi_8h.html#ad3a8bd4711243054c29b3215a9f05b6c" title="Interrupt lines supported in FSI.">FSI_InterruptNum</a> </td></tr>
    <tr><td class="paramname">intFlags</td><td>[IN] events on which interrupt should be generated. Each bit will represent one event, bits for the events on which user want to generate interrupt will be set others remain clear</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="gac2e03ccc8d65b92e55858315e9ba58a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2e03ccc8d65b92e55858315e9ba58a3">&#9670;&nbsp;</a></span>FSI_disableRxInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_disableRxInterrupt </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fsi_2v0_2fsi_8h.html#ad3a8bd4711243054c29b3215a9f05b6c">FSI_InterruptNum</a>&#160;</td>
          <td class="paramname"><em>intNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>intFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enables user to disable interrupt generation on RX events. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI RX module </td></tr>
    <tr><td class="paramname">intNum</td><td>[IN] Type of interrupt to be generated, INT1 or INT2, refer <a class="el" href="fsi_2v0_2fsi_8h.html#ad3a8bd4711243054c29b3215a9f05b6c" title="Interrupt lines supported in FSI.">FSI_InterruptNum</a> </td></tr>
    <tr><td class="paramname">intFlags</td><td>[IN] events on which interrupt generation has to be disabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="gadacfefc8afd7e970166dae171c24e0d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadacfefc8afd7e970166dae171c24e0d9">&#9670;&nbsp;</a></span>FSI_getRxBufferAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_getRxBufferAddress </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API gets address of RX data buffer. </p>
<p><br  />
 Data buffer is consisting of 16 words from offset- 0x40 to 0x4e</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI RX module </td></tr>
    <tr><td class="paramname">pAddr</td><td>[OUT] Pointer to RX data buffer address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="gaeed6850f729199549e7c1ed7c412dd6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeed6850f729199549e7c1ed7c412dd6a">&#9670;&nbsp;</a></span>FSI_resetRxModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_resetRxModule </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga978e5625bbdab7e0a3532158e18642de">FSI_RxSubmoduleInReset</a>&#160;</td>
          <td class="paramname"><em>submodule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API resets frame watchdog, ping watchdog or entire RX module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI RX module </td></tr>
    <tr><td class="paramname">submodule</td><td>[IN] submodule which is supposed to be reset</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="ga71df7339698c1595b844f1306480823c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71df7339698c1595b844f1306480823c">&#9670;&nbsp;</a></span>FSI_clearRxModuleReset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_clearRxModuleReset </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga978e5625bbdab7e0a3532158e18642de">FSI_RxSubmoduleInReset</a>&#160;</td>
          <td class="paramname"><em>submodule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API clears resets on frame watchdog, ping watchdog or entire RX module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI RX module </td></tr>
    <tr><td class="paramname">submodule</td><td>[IN] submodule which is to be brought out of reset</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="gaa1fd9f043ea2d3ee6fc51c1bd5ac7407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1fd9f043ea2d3ee6fc51c1bd5ac7407">&#9670;&nbsp;</a></span>FSI_readRxBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_readRxBuffer </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>pArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>bufOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API reads data from FSI RX buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI RX module </td></tr>
    <tr><td class="paramname">pArray</td><td>[IN] Pointer to the array of words to be received </td></tr>
    <tr><td class="paramname">length</td><td>[IN] Number of words in the array to be received </td></tr>
    <tr><td class="paramname">bufOffset</td><td>[IN] Offset in RX buffer where data will be read, offset is 16-bit aligned address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="ga1e5e647e8af2ab66e1137578d3876823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e5e647e8af2ab66e1137578d3876823">&#9670;&nbsp;</a></span>FSI_configRxDelayLine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_configRxDelayLine </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DRV__FSI__RX__MODULE.html#ga1fbb4d66e61b47962982c0fe4369a311">FSI_RxDelayTapType</a>&#160;</td>
          <td class="paramname"><em>delayTapType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>tapValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API adds delay for selected RX tap line. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI RX module </td></tr>
    <tr><td class="paramname">delayTapType</td><td>[IN] RX line for which delay needs to be added it can be either RXCLK,RXD0 or RXD1 </td></tr>
    <tr><td class="paramname">tapValue</td><td>[IN] 5 bit value of the amount of delay to be added</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="ga98518d233fe2f79b8e3ed84248f13a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98518d233fe2f79b8e3ed84248f13a97">&#9670;&nbsp;</a></span>FSI_performRxInitialization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_performRxInitialization </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API initializes FSI RX module. </p>
<p><br  />
 Software based initialization of the FSI receiver module.This is typically needed only once during initialization. However, if there are framing errors in the received frames, then the receive module needs to be reset so that subsequent frames/packets can be handled fresh</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI RX module</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
