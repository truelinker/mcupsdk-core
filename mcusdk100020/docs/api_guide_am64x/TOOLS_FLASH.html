<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="shortcut icon" href="favicon.png" type="image/png">    
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<title>AM64x MCU+ SDK: Flashing Tools</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<style>
.tinav {
    background: #c00;
    /* height: 41.375px; */
    height: 30px;
    }
</style>    
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
  /* @license-end */
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="AM64x MCU+ SDK"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 40px;">
  <td id="projectlogo"><a href="https://www.ti.com"><img alt="Logo" src="ti_logo.svg"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AM64x MCU+ SDK
   &#160;<span id="projectnumber">10.00.00</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.html" method="get">
              <img id="MSearchSelect" src="search/mag.svg" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
</td>
 </tr>
 </tbody>
</table>
<div class=tinav></div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('TOOLS_FLASH.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Flashing Tools </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md2469">Introduction</a></li>
<li class="level1"><a href="#TOOLS_FLASH_UART_UNIFLASH">UART Uniflash</a><ul><li class="level2"><a href="#autotoc_md2470">Tool requirements on host PC</a></li>
<li class="level2"><a href="#autotoc_md2471">Important files and folders</a></li>
<li class="level2"><a href="#BASIC_STEPS_TO_FLASH_FILES">Basic steps to flash files</a><ul><li class="level3"><a href="#autotoc_md2472">Getting ready to flash</a></li>
<li class="level3"><a href="#autotoc_md2473">Flash configuration file</a></li>
<li class="level3"><a href="#autotoc_md2474">Flash configuration file for flashing to eMMC</a></li>
<li class="level3"><a href="#autotoc_md2475">Flashing the files</a></li>
<li class="level3"><a href="#autotoc_md2476">Flash tool options</a></li>
</ul>
</li>
<li class="level2"><a href="#TOOLS_FLASH_ERROR_MESSAGES">Flash tool error messages and solutions</a></li>
<li class="level2"><a href="#autotoc_md2477">Detailed sequence of steps that happen when flashing files</a></li>
<li class="level2"><a href="#TOOLS_UART_UNIFLASH_GUI">GUI for UART Uniflash (Experimental)</a><ul><li class="level3"><a href="#autotoc_md2478">Pre-Requisites for UART Uniflash GUI</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md2479">Using the UART Uniflash GUI</a></li>
<li class="level2"><a href="#autotoc_md2480">Important Notes and Common Pitfalls in UART Uniflash GUI</a></li>
</ul>
</li>
<li class="level1"><a href="#TOOLS_FLASH_DFU_UNIFLASH">USB DFU Uniflash</a><ul><li class="level2"><a href="#autotoc_md2481">USB DFU bootflow using dfu based flash-writer.</a></li>
<li class="level2"><a href="#autotoc_md2482">Tool requirements on host PC</a></li>
<li class="level2"><a href="#autotoc_md2483">Important files and folders</a></li>
<li class="level2"><a href="#BASIC_STEPS_TO_FLASH_FILES_DFU">Basic steps to flash files</a><ul><li class="level3"><a href="#autotoc_md2484">Flashing the files</a></li>
<li class="level3"><a href="#autotoc_md2485">Flash tool options</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md2486">Detailed sequence of steps that happen when flashing files using usb_dfu_uniflash tool</a></li>
</ul>
</li>
<li class="level1"><a href="#TOOLS_FLASH_JTAG_UNIFLASH">JTAG Uniflash</a><ul><li class="level2"><a href="#autotoc_md2487">Important files and folders</a></li>
<li class="level2"><a href="#autotoc_md2488">Basic steps to flash files</a></li>
<li class="level2"><a href="#autotoc_md2489">See also</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="md_components_tools_tools_flash"></a></p>
<h1><a class="anchor" id="autotoc_md2469"></a>
Introduction</h1>
<p>Flashing tools allow to flash binaries to the flash on a EVM.</p>
<ul>
<li><a class="el" href="TOOLS_FLASH.html#TOOLS_FLASH_UART_UNIFLASH">UART Uniflash</a></li>
<li><a class="el" href="TOOLS_FLASH.html#TOOLS_FLASH_DFU_UNIFLASH">USB DFU Uniflash</a></li>
<li><a class="el" href="TOOLS_FLASH.html#TOOLS_FLASH_JTAG_UNIFLASH">JTAG Uniflash</a></li>
</ul>
<h1><a class="anchor" id="TOOLS_FLASH_UART_UNIFLASH"></a>
UART Uniflash</h1>
<p>UART is used as the transport or interface to send the file to flash to the EVM.</p>
<h2><a class="anchor" id="autotoc_md2470"></a>
Tool requirements on host PC</h2>
<ul>
<li>The tool is implemented using python and needs python version 3.x</li>
<li>The tool uses additional python packages as listed below.<ul>
<li>pyserial for UART access on PC</li>
<li>xmodem for the file transfer protocol</li>
<li>tqdm for progress bar when the tool is run</li>
</ul>
</li>
<li>Refer to the page, <a class="el" href="SDK_DOWNLOAD_PAGE.html#INSTALL_PYTHON3">Python3</a> , to install python and the required python packages on your PC.</li>
</ul>
<h2><a class="anchor" id="autotoc_md2471"></a>
Important files and folders</h2>
<table class="doxtable">
<tr>
<th>Folder/Files </th><th>Description  </th></tr>
<tr>
<td colspan="2" bgcolor="#F0F0F0">${SDK_INSTALL_PATH}/tools/boot/ </td></tr>
<tr>
<td>uart_uniflash.py </td><td>Flashing tool  </td></tr>
<tr>
<td>sbl_prebuilt/am64x-evm </td><td>Pre-built bootloader images and default flash configuration files for a supported EVM  </td></tr>
<tr>
<td colspan="2" bgcolor="#F0F0F0">${SDK_INSTALL_PATH}/examples/drivers/boot/ </td></tr>
<tr>
<td>sbl_uart_uniflash </td><td><p class="starttd">Flashing application that is run on the EVM to receive files to flash </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>sbl_ospi </td><td><p class="starttd">OSPI bootloader application that needs to be flashed at offset 0x0. When in OSPI boot mode, this bootloader application will boot the user application file for all the CPUs </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>sbl_null </td><td>SOC init bootloader application that can be used to init the SOC when working in CCS IDE environment.  </td></tr>
</table>
<h2><a class="anchor" id="BASIC_STEPS_TO_FLASH_FILES"></a>
Basic steps to flash files</h2>
<h3><a class="anchor" id="autotoc_md2472"></a>
Getting ready to flash</h3>
<ul>
<li>Make sure the flashing application (<code>sbl_uart_uniflash</code>), OSPI bootloader (<code>sbl_ospi</code>), and the user application (<code>*.appimage</code>) you want to flash is built for the EVM.<ul>
<li>For every supported EVM pre-built flashing application and OSPI bootloader can be found below <pre class="fragment">{SDK_INSTALL_PATH}/tools/boot/sbl_prebuilt/{board}
</pre></li>
<li>The flashing application and OSPI bootloader source code can be found at below path <pre class="fragment">{SDK_INSTALL_PATH}/examples/drivers/boot
</pre></li>
<li>If you have modified the flashing or bootloader applications, make sure to rebuild these applications and note the path to the <code>hs_fs.tiimage</code> files that are generated as part of the build.</li>
<li>To build your application follow the steps mentioned in <a class="el" href="GETTING_STARTED_BUILD.html">Build a Hello World example</a> to build the application you want. Note the path to the <code>*.appimage.hs_fs</code> file that is generated as part of the build.</li>
</ul>
</li>
<li>Make sure you have installed python as mention in <a class="el" href="SDK_DOWNLOAD_PAGE.html#INSTALL_PYTHON3">Python3</a></li>
<li>Make sure you have identified the UART port on the EVM as mentioned in <a class="el" href="EVM_SETUP_PAGE.html">EVM Setup</a></li>
</ul>
<h3><a class="anchor" id="autotoc_md2473"></a>
Flash configuration file</h3>
<ul>
<li>Create a flash configuration file, using the default flash configuration file present at below as reference <pre class="fragment">  ${SDK_INSTALL_PATH}/tools/boot/sbl_prebuilt/{board}/default_sbl_ospi.cfg
</pre></li>
<li>In this config file, modify the paths to the flashing application and OSPI bootloader, in case you are not using the pre-built applications <pre class="fragment">  --flash-writer={path to flash application .tiimage}
  --file={path to OSPI bootloader .tiimage} --operation=flash --flash-offset=0x0
</pre></li>
<li>Edit below line to point to the user application (<code>.appimage.hs_fs</code>) file <pre class="fragment">  --file={path to your application .appimage.hs_fs file} --operation=flash --flash-offset=0x80000
</pre></li>
<li>Edit below line to point to the user application XIP image (<code>.appimage_xip</code>) file. When not using XIP mode, this file input is optional. <pre class="fragment">  --file={path to your application .appimage_xip file} --operation=flash-xip
</pre></li>
</ul>
<h3><a class="anchor" id="autotoc_md2474"></a>
Flash configuration file for flashing to eMMC</h3>
<ul>
<li>Create a flash configuration file, using the default flash configuration file present at below as reference<ul>
<li>For <code>sbl_emmc</code> <pre class="fragment">  ${SDK_INSTALL_PATH}/examples/drivers/boot/sbl_emmc/am64x-evm/r5fss0-0_nortos/default_sbl_emmc.cfg
</pre></li>
<li>For <code>sbl_emmc_linux</code> <pre class="fragment">  ${SDK_INSTALL_PATH}/examples/drivers/boot/sbl_emmc_linux/am64x-evm/r5fss0-0_nortos/default_sbl_emmc_linux.cfg
</pre></li>
</ul>
</li>
<li>The flashing application and the eMMC bootloader needs to be specified in this file as <pre class="fragment">  --flash-writer={path to flash application .tiimage}
  --file={path to eMMC bootloader .tiimage} --operation=flash-emmc --flash-offset=0x0
</pre></li>
<li>The user application (<code>.appimage</code>) file needs to be specified in the configuration file as <pre class="fragment">  --file={path to your application .appimage file} --operation=flash-emmc --flash-offset=0x800000
</pre></li>
</ul>
<h3><a class="anchor" id="autotoc_md2475"></a>
Flashing the files</h3>
<ul>
<li>Set EVM in <a class="el" href="EVM_SETUP_PAGE.html#BOOTMODE_UART">UART BOOT MODE</a> and power on the EVM</li>
<li>Run below python command on the Windows command prompt (<code>cmd.exe</code>) or Linux bash shell to flash the files. <pre class="fragment">  cd ${SDK_INSTALL_PATH}/tools/boot
  python uart_uniflash.py -p {name of your UART com port} --cfg={path to your edited config file}
</pre></li>
<li>At each step in the flashing your will see success or error messages, including progress as the file is being transferred.</li>
<li>If flashing is successful, power OFF the EVM, set the EVM to <a class="el" href="EVM_SETUP_PAGE.html#BOOTMODE_OSPI">OSPI BOOT MODE</a> and power ON the EVM to run the flashed application.</li>
<li>If flashing is not successful, then check the error messages and take appropriate action (See <a class="el" href="TOOLS_FLASH.html#TOOLS_FLASH_ERROR_MESSAGES">Flash tool error messages and solutions</a>).</li>
</ul>
<h3><a class="anchor" id="autotoc_md2476"></a>
Flash tool options</h3>
<ul>
<li>Type below to see all the possible options with the flashing tool and also see the default .cfg file for syntax and options possible in the config file <pre class="fragment">  cd ${SDK_INSTALL_PATH}/tools/boot
  python uart_uniflash.py --help
</pre></li>
</ul>
<h2><a class="anchor" id="TOOLS_FLASH_ERROR_MESSAGES"></a>
Flash tool error messages and solutions</h2>
<p>If the flashing fails, the error message will give a hint as to why it failed. Some common error messages, reasons and potential solutions are listed below.</p>
<table class="doxtable">
<tr>
<th>Error </th><th>Possible Reason </th><th>Solution  </th></tr>
<tr>
<td>Serial port not found or not accessible </td><td>Wrong UART port passed as argument or the UART port is open in some other terminal application. </td><td>Check the UART port, UART ports are named as <code>COM1</code>, <code>COM2</code>, and so on in Windows and as <code>/dev/ttyUSB0</code>, <code>/dev/ttyUSB1</code>, and so on in Linux. Also make sure to close all open UART terminals and try again.  </td></tr>
<tr>
<td>No response or error response from EVM. </td><td>Either EVM is not in power-ON state or EVM is not setup in UART boot mode. </td><td>Use Ctrl-C to terminate the script if it is stuck. Check UART boot mode switch setting, check power to EVM, power-cycle EVM and try again  </td></tr>
<tr>
<td>Flashing failed error message </td><td>This should not happen ideally on TI EVMs. On custom EVM this could happen if there is some issue in the flash driver on the EVM. </td><td>Power cycle EVM and try again. If the problem still does not go away, then likely the flash on the EVM has gone bad. Try other SOC initialization options and check the flash driver via CCS IDE debug.  </td></tr>
<tr>
<td>Config file parsing error </td><td>Wrong config file passed or input files not found. </td><td>Check the message that is printed, and edit the config file to fix the parsing errors. Make sure to specify file paths with forward slash <code>/</code>, including in Windows. The default config file should not have any errors though.  </td></tr>
<tr>
<td>Python not found error or python packages not not found error </td><td>Python or python packages needed for this script are not installed </td><td>Follow steps mentioned in <a class="el" href="SDK_DOWNLOAD_PAGE.html#INSTALL_PYTHON3">Python3</a> to install python and related packages  </td></tr>
<tr>
<td>Parsing config file error </td><td>SBL binaries are missing from the prebuilt folder </td><td>Build sbl using below command:<div class="fragment"><div class="line">gmake -s sbl DEVICE=am243x </div>
</div><!-- fragment -->  </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md2477"></a>
Detailed sequence of steps that happen when flashing files</h2>
<dl class="section note"><dt>Note</dt><dd>This section has more detailed sequence of steps that happen underneath the tools and on the EVM for reference.</dd></dl>
<p>The detailed sequence of steps that happen when flashing files is listed below, refer to the <a class="el" href="EVM_SETUP_PAGE.html">EVM Setup</a> page to see how to setup the EVM in different boot modes that are needed for this sequence of steps.</p>
<ul>
<li>Set EVM in UART boot mode and power it on, the SOC ROM bootloader waits to receive a file using the UART+XMODEM protocol.</li>
<li>PC sends the flashing application file (<code>sbl_uart_uniflash.release.tiimage</code>) via the flashing tool using UART+XMODEM protocol underneath.</li>
<li>The ROM bootloader, boots the flashing application</li>
<li>The flashing application now initializes the flash on the EVM and waits for additional commands using UART+XMODEM protocol</li>
<li>The PC tool can now send one or more of below commands with the file data, one after the other, until it is done.<ul>
<li>Flash a file at a given offset in the flash</li>
<li>Verify a previously flashed file at a given offset in the flash</li>
<li>Erase a region of flash memory</li>
</ul>
</li>
<li>The flashing application as such does not care what the file contains, it will simply flash it at the user specified location.</li>
<li>However typically one needs to at least send the below files to flash<ul>
<li>Send a OSPI flash bootloader application and flash it at offset 0x0 (<code>sbl_ospi.release.hs_fs.tiimage</code>). If the OSPI bootloader is already flashed previously then this step can be skipped.</li>
<li>Send your application image multi-core image and flash it at offset 0x80000 (<code>*.appimage.hs_fs</code>). The offset 0x80000 is the offset that is specified in the OSPI bootloader and when the EVM boots in OSPI mode, it will attempt to find a application at this location.</li>
</ul>
</li>
<li>After flashing is done, power OFF the EVM</li>
<li>Set EVM in OSPI boot mode and power ON the EVM.<ul>
<li>The ROM bootloader will now boot the OSPI bootloader by reading offset 0x0</li>
<li>And the OSPI bootloader will boot the application by reading from offset 0x80000.</li>
</ul>
</li>
<li>The initial flashing application and the subsequent commands to send and flash the OSPI bootloader and application files are all specified in a single configuration file which is provided as input to the tool.</li>
</ul>
<h2><a class="anchor" id="TOOLS_UART_UNIFLASH_GUI"></a>
GUI for UART Uniflash (Experimental)</h2>
<p>UART Uniflash GUI is a GUI wrapper around the UART Uniflash tool already present (<code>uart_uniflash.py</code>). This is a strictly experimental feature with minimal testing from TI side. Can be used if GUI is more comfortable. Since most of the CLI tool is used underneath, it is the same functionality wise</p>
<h3><a class="anchor" id="autotoc_md2478"></a>
Pre-Requisites for UART Uniflash GUI</h3>
<p>This GUI is built on top of the python based UART Uniflash CLI tool already mentioned, and specifically based on the PyQt5 binding of the QT5 framework. So it is expected that python3 and other dependencies (xmodem, pyserial etc) are already installed. In addition to this, one also needs to install the PyQt5 python library for the GUI to work.</p>
<ul>
<li><p class="startli">In windows, you can install PyQt5 by doing below:</p>
<p class="startli"><code>python -m pip install pyqt5</code></p>
</li>
<li><p class="startli">In Ubuntu (or other Debian based distros) you can install PyQt5 by doing below:</p>
<p class="startli"><code>sudo apt install python3-pyqt5</code></p>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md2479"></a>
Using the UART Uniflash GUI</h2>
<p>The UART Uniflash GUI can be used to flash files arbitrarily into the device flash</p>
<p> <style>div.image img[src="uniflash_gui_manual_config_sport.png"]{width:40%}</style> </p><div class="image">
<img src="uniflash_gui_manual_config_sport.png" alt=""/>
<div class="caption">
UART Uniflash GUI : Serial Port Selection</div></div>
<p>At the top there is a drop down to select the UART COM port which will be used for flashing. Please connect the target to the EVM before running the GUI so that the serial port we are interested will show up here.</p>
<ul>
<li>For choosing what to flash and how to flash there are two high level choices in UART Uniflash GUI:<ul>
<li>Manual Config</li>
<li>From File</li>
</ul>
</li>
</ul>
<p> <style>div.image img[src="uniflash_gui_manual_config.png"]{ width:50%}</style>  <style>div.image img[src="uniflash_gui_file_config.png"]{ width:50%}</style></p>
<table style="border: 0 px">
<tr>
<td><div class="image">
<img src="uniflash_gui_manual_config.png" alt=""/>
<div class="caption">
UART Uniflash GUI : Manual Config based flashing</div></div>
  </td><td><div class="image">
<img src="uniflash_gui_file_config.png" alt=""/>
<div class="caption">
UART Uniflash GUI : Config file based flashing</div></div>
   </td></tr>
</table>
<ul>
<li><b>Manual Config</b> : Manual configuration of the files to be flashed. There will be drop down file browse options to select the various files you will need to flash/send to the target. It provides options / slots to select below:<ul>
<li><b>Flash writer binary</b> : This is the sbl_uart_uniflash binary. This needs to be send first for the ROM to receive and boot. Once this boots up you can send any number of files arbitrarily for flashing.</li>
<li><b>Bootloader binary</b> : It is assumed that the eventual goal of the flashing process is to boot your application from the flash device. For this a bootloader capable of reading an image from flash device needs to be flashed at offset 0 (generally) of the flash. This would be the <code>sbl_ospi</code> or <code>sbl_qspi</code>. Although this is no different than flashing any other file to a particular offset, we have decided to keep it a separate option for better clarity. Although the offset is almost always 0, we have provided an offset edit box as well if there is any change whatsoever.</li>
<li><b>Appimage binary</b> : You can select the application image to be flashed from this slot. SDK convention is to flash at a 512 KB offset (0x80000). This can be changed, but keep in mind that the bootloader booting this application should be aware of this offset as well. It is a configurable option in the Sysconfig of the bootloader.</li>
<li><b>Appimage XIP binary</b> : You can select the XIP component to your application from this slot. These files will be of the format (<code>*.appimage_xip</code>). These files already contain details as to where these need to be flashed, so no need to provide any offset in this case.</li>
<li><b>Custom data</b> : This slot can be used to flash any custom data file at an arbitrary offset. Don't forget to provide the offset</li>
<li><b>Flash PHY tuning data</b> : In certain NOR SPI drivers, for tuning the PHY, known data needs to be present in the flash. This is a fixed size (usually 128 bytes) array written to the last block of the flash. This check box needs to be ticked if you're flashing for the first time to the target so that this known data can be written to the flash.</li>
</ul>
</li>
</ul>
<p> <style>div.image img[src="uniflash_gui_manual_config_flash_phy_tuning.png"]{width:40%}</style> </p><div class="image">
<img src="uniflash_gui_manual_config_flash_phy_tuning.png" alt=""/>
<div class="caption">
UART Uniflash GUI : Saving the manual configuration</div></div>
<ul>
<li>There is an option to save the settings you selected manually as a config file using the <b>Save CFG</b> button towards the bottom right of the Manual Config group.</li>
</ul>
<p> <style>div.image img[src="uniflash_gui_manual_config_save_cfg.png"]{width:40%}</style> </p><div class="image">
<img src="uniflash_gui_manual_config_save_cfg.png" alt=""/>
<div class="caption">
UART Uniflash GUI : Saving the manual configuration</div></div>
<ul>
<li><b>From File</b> : Flash using a configuration file (<code>*.cfg</code> extension) specifying what needs to be flashed. This is a convenient option if the files to be flashed are pretty much the same for every try. In fact even in the manual config case, a cfg file is created internally and used for flashing. This <code>cfg</code> follows the same format used by the CLI script.</li>
</ul>
<p>After selecting the config options and files, just press the <b>FLASH</b> button to start the flashing. A progress bar will show the flashing progress.</p>
<p>There is also a log area which will show detailed logs in addition to the pop up messages.</p>
<p> <style>div.image img[src="uniflash_gui_manual_config_log_area.png"]{width:40%}</style> </p><div class="image">
<img src="uniflash_gui_manual_config_log_area.png" alt=""/>
<div class="caption">
UART Uniflash GUI : LOGS</div></div>
<h2><a class="anchor" id="autotoc_md2480"></a>
Important Notes and Common Pitfalls in UART Uniflash GUI</h2>
<ul>
<li>Make sure that the target device is powered ON and is in UART boot mode before attempting to flash</li>
<li>Make sure that the correct COM port is selected from the drop down. If the wrong port is selected, the flasher might take time to exit out as it will wait for the device to send the XMODEM control character.</li>
<li>If the GUI seems to hang, re-check the selected COM port and make sure the EVM is <b>powered ON</b> and in <b>UART boot mode</b></li>
<li>The GUI is based on the <code>uart_uniflash.py</code> CLI script, and reuses a lot of objects and functions, so core functionality is the same among both.</li>
<li>In manual config case, if a drop down is non blank it is assumed that the file provided there needs to be flashed. So it will be picked up and used when <code>FLASH</code> button is clicked. If this is not required, make sure to delete it and keep it blank, the drop down is editable. This is true for the config file drop down as well, but the mishap is more probable in manual config case.</li>
</ul>
<h1><a class="anchor" id="TOOLS_FLASH_DFU_UNIFLASH"></a>
USB DFU Uniflash</h1>
<ul>
<li><b>usb_dfu_uniflash.py</b> is a tool which is used for flashing the images onto the flash memory using USB DFU protocol. It uses <a class="el" href="SDK_DOWNLOAD_PAGE.html#INSTALL_DFU_UTIL">dfu-util</a> tool to underneath to send binaries via USB.</li>
<li>This tool is used in conjuction with <a class="el" href="EXAMPLES_DRIVERS_SBL_DFU_UNIFLASH.html">SBL DFU Uniflash</a> which is a flash-writer application.</li>
<li>refer <a class="el" href="EXAMPLES_USB_DFU.html">USB DFU Example</a> for more information on DFU.</li>
</ul>
<h2><a class="anchor" id="autotoc_md2481"></a>
USB DFU bootflow using dfu based flash-writer.</h2>
<ul>
<li>Following diagram explains boot flow using USB DFU and SBL OSPI.</li>
<li>Its a three step process.<ol type="1">
<li>Put the device into DFU BOOT mode refer <a class="el" href="EVM_SETUP_PAGE.html#BOOTMODE_DFU">DFU BOOT MODE</a>. After this ROM Bootoader will accept a valid SBL image via USB and boot it. In this case we will boot <a class="el" href="EXAMPLES_DRIVERS_SBL_DFU_UNIFLASH.html">SBL DFU Uniflash</a> which is a flash-writer binary.</li>
<li>Once flash-writer is booted a new USB DFU capable device will be enumerated. After this using <b>usb_dfu_uniflash.py</b> tool we will send <b>SBL_OSPI</b> or <b>SBL_QSPI</b> along with multicore appimage. Flash-writer SBL will flash the received files onto flash memory.</li>
<li>Change the boot mode to <a class="el" href="EVM_SETUP_PAGE.html#BOOTMODE_OSPI">OSPI BOOT MODE</a> and power cycle the board. First <b>SBL_OSPI</b> or <b>SBL_QSPI</b> will be booted from flash and later it is responsible to boot the multicore appimages.</li>
</ol>
</li>
</ul>
<p> <style>div.image img[src="dfu_flash_bootflow.png"]{width:40%}</style> </p><div class="image">
<img src="dfu_flash_bootflow.png" alt=""/>
</div>
<h2><a class="anchor" id="autotoc_md2482"></a>
Tool requirements on host PC</h2>
<ul>
<li>The tool is implemented using python and needs python version 3.x</li>
<li>Refer to the page, <a class="el" href="SDK_DOWNLOAD_PAGE.html#INSTALL_PYTHON3">Python3</a> , to install python and the required python packages on your PC.</li>
<li>It uses <b>dfu-util</b> tool to execute dfu commands from the host PC.</li>
<li>Refer to the page <a class="el" href="SDK_DOWNLOAD_PAGE.html#INSTALL_DFU_UTIL">dfu-util</a> , to install <b>dfu-util</b> tool.</li>
</ul>
<h2><a class="anchor" id="autotoc_md2483"></a>
Important files and folders</h2>
<table class="doxtable">
<tr>
<th>Folder/Files </th><th>Description  </th></tr>
<tr>
<td colspan="2" bgcolor="#F0F0F0">${SDK_INSTALL_PATH}/tools/boot/ </td></tr>
<tr>
<td>usb_dfu_uniflash.py </td><td>Flashing tool  </td></tr>
<tr>
<td>sbl_prebuilt/am64x-evm </td><td>Pre-built bootloader images and default flash configuration files for a supported EVM  </td></tr>
<tr>
<td colspan="2" bgcolor="#F0F0F0">${SDK_INSTALL_PATH}/examples/drivers/boot/ </td></tr>
<tr>
<td>sbl_dfu_uniflash </td><td><p class="starttd">Flashing application that is run on the EVM to receive files to flash </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>sbl_ospi </td><td><p class="starttd">OSPI bootloader application that needs to be flashed at offset 0x0. When in OSPI boot mode, this bootloader application will boot the user application file for all the CPUs </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>sbl_null </td><td>SOC init bootloader application that can be used to init the SOC when working in CCS IDE environment.  </td></tr>
</table>
<h2><a class="anchor" id="BASIC_STEPS_TO_FLASH_FILES_DFU"></a>
Basic steps to flash files</h2>
<ul>
<li>The flashing steps are same as refer <a class="el" href="TOOLS_FLASH.html#BASIC_STEPS_TO_FLASH_FILES">Basic steps to flash files</a> only difference is instead of using <strike>uart_uniflash.py</strike> use <b>usb_dfu_uniflash.py</b>.</li>
</ul>
<h3><a class="anchor" id="autotoc_md2484"></a>
Flashing the files</h3>
<ul>
<li>Set EVM in <a class="el" href="EVM_SETUP_PAGE.html#BOOTMODE_DFU">DFU BOOT MODE</a> and power on the EVM</li>
<li>Run below python command on the Windows command prompt (<code>cmd.exe</code>) or Linux bash shell to flash the files. <pre class="fragment">  cd ${SDK_INSTALL_PATH}/tools/boot
  python usb_dfu_uniflash.py --cfg={path to your edited config file}
</pre></li>
<li>At each step in the flashing your will see success or error messages, including progress as the file is being transferred.</li>
<li>If flashing is successful, power OFF the EVM, set the EVM to <a class="el" href="EVM_SETUP_PAGE.html#BOOTMODE_OSPI">OSPI BOOT MODE</a> and power ON the EVM to run the flashed application.</li>
<li>If flashing is not successful, then DFU device i.e EVM must have send error status in <b>GET_STATUS</b> phase of <b>SETUP</b> transfer. This error condition will be detected by <b>dfu-util</b> tool and will be displayed on console.</li>
</ul>
<h3><a class="anchor" id="autotoc_md2485"></a>
Flash tool options</h3>
<ul>
<li>Type below to see all the possible options with the flashing tool and also see the default .cfg file for syntax and options possible in the config file <pre class="fragment">  cd ${SDK_INSTALL_PATH}/tools/boot
  python usb_dfu_uniflash.py --help
</pre></li>
</ul>
<h2><a class="anchor" id="autotoc_md2486"></a>
Detailed sequence of steps that happen when flashing files using usb_dfu_uniflash tool</h2>
<dl class="section note"><dt>Note</dt><dd>This section has more detailed sequence of steps that happen underneath the tools and on the EVM for reference.</dd></dl>
<p>The detailed sequence of steps that happen when flashing files is listed below, refer to the <a class="el" href="EVM_SETUP_PAGE.html">EVM Setup</a> page to see how to setup the EVM in different boot modes that are needed for this sequence of steps.</p>
<ul>
<li>Set EVM in DFU boot mode and power it on, the SOC ROM bootloader waits to receive a file using the USB2.0 DFU protocol.</li>
<li>PC sends the flashing application file (<code>sbl_dfu_uniflash.release.hs_fs.tiimage</code>) via the flashing tool using USB2.0 DFU protocol underneath.</li>
<li>The ROM bootloader, boots the flashing application</li>
<li>The flashing application now initializes the flash on the EVM and waits for additional commands using USB2.0 DFU protocol</li>
<li>The PC tool can now send one or more of below commands with the file data, one after the other, until it is done.<ul>
<li>Flash a file at a given offset in the flash</li>
<li>Verify a previously flashed file at a given offset in the flash</li>
<li>Erase a region of flash memory</li>
</ul>
</li>
<li>The flashing application as such does not care what the file contains, it will simply flash it at the user specified location.</li>
<li>However typically one needs to at least send the below files to flash<ul>
<li>Send a OSPI flash bootloader application and flash it at offset 0x0 (<code>sbl_ospi.release.hs_fs.tiimage</code>). If the OSPI bootloader is already flashed previously then this step can be skipped.</li>
<li>Send your application image multi-core image and flash it at offset 0x80000 (<code>*.appimage</code>). The offset 0x80000 is the offset that is specified in the OSPI bootloader and when the EVM boots in OSPI mode, it will attempt to find a application at this location.</li>
</ul>
</li>
<li>After flashing is done, power OFF the EVM</li>
<li>Set EVM in OSPI boot mode and power ON the EVM.<ul>
<li>The ROM bootloader will now boot the OSPI bootloader by reading offset 0x0</li>
<li>And the OSPI bootloader will boot the application by reading from offset 0x80000.</li>
</ul>
</li>
<li>The initial flashing application and the subsequent commands to send and flash the OSPI bootloader and application files are all specified in a single configuration file which is provided as input to the tool.</li>
<li>see also <a class="el" href="EXAMPLES_DRIVERS_SBL_DFU_UNIFLASH.html">SBL DFU Uniflash</a></li>
</ul>
<h1><a class="anchor" id="TOOLS_FLASH_JTAG_UNIFLASH"></a>
JTAG Uniflash</h1>
<p>JTAG is used as the transport or interface to send the file to flash to the EVM.</p>
<h2><a class="anchor" id="autotoc_md2487"></a>
Important files and folders</h2>
<table class="doxtable">
<tr>
<th>Folder/Files </th><th>Description  </th></tr>
<tr>
<td colspan="2" bgcolor="#F0F0F0">${SDK_INSTALL_PATH}/examples/drivers/boot/ </td></tr>
<tr>
<td>sbl_jtag_uniflash </td><td>Flash-writer example which uses JTAG to write files or erase flash  </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md2488"></a>
Basic steps to flash files</h2>
<p>Refer the example <a class="el" href="EXAMPLES_DRIVERS_SBL_JTAG_UNIFLASH.html">SBL JTAG Uniflash</a></p>
<h2><a class="anchor" id="autotoc_md2489"></a>
See also</h2>
<ul>
<li><a class="el" href="EXAMPLES_USB_DFU.html">USB DFU Example</a> </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
