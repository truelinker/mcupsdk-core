<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="shortcut icon" href="favicon.png" type="image/png">    
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<title>AM64x MCU+ SDK: APIs for FSI TX</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<style>
.tinav {
    background: #c00;
    /* height: 41.375px; */
    height: 30px;
    }
</style>    
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
  /* @license-end */
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="AM64x MCU+ SDK"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 40px;">
  <td id="projectlogo"><a href="https://www.ti.com"><img alt="Logo" src="ti_logo.svg"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AM64x MCU+ SDK
   &#160;<span id="projectnumber">10.00.00</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.html" method="get">
              <img id="MSearchSelect" src="search/mag.svg" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
</td>
 </tr>
 </tbody>
</table>
<div class=tinav></div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__DRV__FSI__TX__MODULE.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">APIs for FSI TX<div class="ingroups"><a class="el" href="group__DRV__MODULE.html">APIs for SOC Specific Device Drivers</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Introduction</h2>
<p>This module contains APIs to program and use the FSI TX module. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:fsi__tx_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsi__tx_8h.html">fsi_tx.h</a></td></tr>
<tr class="memdesc:fsi__tx_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Header file containing various enumerations, structure definitions and function declarations for the FSI TX IP. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gabf37b3803f5e4fb2c80edc12c41a72d7"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#gabf37b3803f5e4fb2c80edc12c41a72d7">FSI_sendTxFlush</a> (uint32_t base)</td></tr>
<tr class="memdesc:gabf37b3803f5e4fb2c80edc12c41a72d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API sends FLUSH pattern.  <a href="group__DRV__FSI__TX__MODULE.html#gabf37b3803f5e4fb2c80edc12c41a72d7">More...</a><br /></td></tr>
<tr class="separator:gabf37b3803f5e4fb2c80edc12c41a72d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga619f6852f1e177325deeb4b69da94291"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga619f6852f1e177325deeb4b69da94291">FSI_stopTxFlush</a> (uint32_t base)</td></tr>
<tr class="memdesc:ga619f6852f1e177325deeb4b69da94291"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API stops FLUSH pattern transmission.  <a href="group__DRV__FSI__TX__MODULE.html#ga619f6852f1e177325deeb4b69da94291">More...</a><br /></td></tr>
<tr class="separator:ga619f6852f1e177325deeb4b69da94291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0638cfeb1030dec605524c8de543190"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#gad0638cfeb1030dec605524c8de543190">FSI_selectTxPLLClock</a> (uint32_t base, <a class="el" href="group__DRV__FSI__TX__MODULE.html#ga6f96c0ca6b8eed9423cb3d08b8c3f2a7">FSI_TxClkSel</a> clkSel)</td></tr>
<tr class="memdesc:gad0638cfeb1030dec605524c8de543190"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API selects PLL clock as source for clock dividers.  <a href="group__DRV__FSI__TX__MODULE.html#gad0638cfeb1030dec605524c8de543190">More...</a><br /></td></tr>
<tr class="separator:gad0638cfeb1030dec605524c8de543190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4aaf8788aa6717017596f258a4894551"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga4aaf8788aa6717017596f258a4894551">FSI_enableTxClock</a> (uint32_t base, uint16_t preScaleValue)</td></tr>
<tr class="memdesc:ga4aaf8788aa6717017596f258a4894551"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API sets clock division prescalar and enables the transmit clock.  <a href="group__DRV__FSI__TX__MODULE.html#ga4aaf8788aa6717017596f258a4894551">More...</a><br /></td></tr>
<tr class="separator:ga4aaf8788aa6717017596f258a4894551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9216b8c4b4366e20ee36dd45a278febd"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga9216b8c4b4366e20ee36dd45a278febd">FSI_disableTxClock</a> (uint32_t base)</td></tr>
<tr class="memdesc:ga9216b8c4b4366e20ee36dd45a278febd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API disables transmit clock.  <a href="group__DRV__FSI__TX__MODULE.html#ga9216b8c4b4366e20ee36dd45a278febd">More...</a><br /></td></tr>
<tr class="separator:ga9216b8c4b4366e20ee36dd45a278febd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00ded17f9d497a3c626741483f8da779"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga00ded17f9d497a3c626741483f8da779">FSI_setTxDataWidth</a> (uint32_t base, <a class="el" href="group__DRV__FSI__MODULE.html#ga5dbdfd7ff13523f74955cbb7707726f2">FSI_DataWidth</a> dataWidth)</td></tr>
<tr class="memdesc:ga00ded17f9d497a3c626741483f8da779"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API sets Data width for transmission.  <a href="group__DRV__FSI__TX__MODULE.html#ga00ded17f9d497a3c626741483f8da779">More...</a><br /></td></tr>
<tr class="separator:ga00ded17f9d497a3c626741483f8da779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaccd73876f639066e4e88aa7920b48d6"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#gaaccd73876f639066e4e88aa7920b48d6">FSI_enableTxSPIMode</a> (uint32_t base)</td></tr>
<tr class="memdesc:gaaccd73876f639066e4e88aa7920b48d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enables SPI compatible mode.  <a href="group__DRV__FSI__TX__MODULE.html#gaaccd73876f639066e4e88aa7920b48d6">More...</a><br /></td></tr>
<tr class="separator:gaaccd73876f639066e4e88aa7920b48d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60d39657a2b622e564b3882c3da93b6b"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga60d39657a2b622e564b3882c3da93b6b">FSI_disableTxSPIMode</a> (uint32_t base)</td></tr>
<tr class="memdesc:ga60d39657a2b622e564b3882c3da93b6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API disables SPI compatible mode.  <a href="group__DRV__FSI__TX__MODULE.html#ga60d39657a2b622e564b3882c3da93b6b">More...</a><br /></td></tr>
<tr class="separator:ga60d39657a2b622e564b3882c3da93b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29cf99b973b8028fa441bbba1e3a0eaf"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga29cf99b973b8028fa441bbba1e3a0eaf">FSI_setTxStartMode</a> (uint32_t base, <a class="el" href="group__DRV__FSI__TX__MODULE.html#ga8d5f6ee7c83a3e7c64560661046c126e">FSI_TxStartMode</a> txStartMode)</td></tr>
<tr class="memdesc:ga29cf99b973b8028fa441bbba1e3a0eaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API sets start mode for any frame transmission.  <a href="group__DRV__FSI__TX__MODULE.html#ga29cf99b973b8028fa441bbba1e3a0eaf">More...</a><br /></td></tr>
<tr class="separator:ga29cf99b973b8028fa441bbba1e3a0eaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bf00afbb5d04bc3a4330a2b14792190"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga0bf00afbb5d04bc3a4330a2b14792190">FSI_setTxPingTimeoutMode</a> (uint32_t base, <a class="el" href="fsi_2v0_2fsi_8h.html#a3008502af132b9be684563c208957180">FSI_PingTimeoutMode</a> pingTimeoutMode)</td></tr>
<tr class="memdesc:ga0bf00afbb5d04bc3a4330a2b14792190"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API sets HW/SW initiated TX ping timeout mode.  <a href="group__DRV__FSI__TX__MODULE.html#ga0bf00afbb5d04bc3a4330a2b14792190">More...</a><br /></td></tr>
<tr class="separator:ga0bf00afbb5d04bc3a4330a2b14792190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8efc9b47b6d7d489f189c76c5a136da8"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga8efc9b47b6d7d489f189c76c5a136da8">FSI_setTxExtFrameTrigger</a> (uint32_t base, uint16_t extInputNum)</td></tr>
<tr class="memdesc:ga8efc9b47b6d7d489f189c76c5a136da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API sets a particular external input to trigger transmission.  <a href="group__DRV__FSI__TX__MODULE.html#ga8efc9b47b6d7d489f189c76c5a136da8">More...</a><br /></td></tr>
<tr class="separator:ga8efc9b47b6d7d489f189c76c5a136da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0840498fa6d03fd65614f10a58fa07ae"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga0840498fa6d03fd65614f10a58fa07ae">FSI_enableTxCRCForceError</a> (uint32_t base)</td></tr>
<tr class="memdesc:ga0840498fa6d03fd65614f10a58fa07ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enables CRC value of a data frame to be forced to zero.  <a href="group__DRV__FSI__TX__MODULE.html#ga0840498fa6d03fd65614f10a58fa07ae">More...</a><br /></td></tr>
<tr class="separator:ga0840498fa6d03fd65614f10a58fa07ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5628350f8643f8e6a5ccfd8883108364"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga5628350f8643f8e6a5ccfd8883108364">FSI_disableTxCRCForceError</a> (uint32_t base)</td></tr>
<tr class="memdesc:ga5628350f8643f8e6a5ccfd8883108364"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API disables forcing of CRC value of a data frame to zero.  <a href="group__DRV__FSI__TX__MODULE.html#ga5628350f8643f8e6a5ccfd8883108364">More...</a><br /></td></tr>
<tr class="separator:ga5628350f8643f8e6a5ccfd8883108364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27a5fee0227ccd6043962f30b74b2ade"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga27a5fee0227ccd6043962f30b74b2ade">FSI_setTxECCComputeWidth</a> (uint32_t base, <a class="el" href="fsi_2v0_2fsi_8h.html#aa3bcb498544ab9219714d4531ebcadb9">FSI_ECCComputeWidth</a> eccComputeWidth)</td></tr>
<tr class="memdesc:ga27a5fee0227ccd6043962f30b74b2ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API select between 16-bit and 32-bit ECC computation for FSI TX.  <a href="group__DRV__FSI__TX__MODULE.html#ga27a5fee0227ccd6043962f30b74b2ade">More...</a><br /></td></tr>
<tr class="separator:ga27a5fee0227ccd6043962f30b74b2ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdf14723e0a040151c0903647c3211c3"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#gabdf14723e0a040151c0903647c3211c3">FSI_setTxFrameType</a> (uint32_t base, <a class="el" href="fsi_2v0_2fsi_8h.html#a5d351d5afbe8aa861a52ebcd12a91b38">FSI_FrameType</a> frameType)</td></tr>
<tr class="memdesc:gabdf14723e0a040151c0903647c3211c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API sets frame type for transmission.  <a href="group__DRV__FSI__TX__MODULE.html#gabdf14723e0a040151c0903647c3211c3">More...</a><br /></td></tr>
<tr class="separator:gabdf14723e0a040151c0903647c3211c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fe9ba0cc066b5da896e604d5dbd9c79"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga6fe9ba0cc066b5da896e604d5dbd9c79">FSI_setTxSoftwareFrameSize</a> (uint32_t base, uint16_t nWords)</td></tr>
<tr class="memdesc:ga6fe9ba0cc066b5da896e604d5dbd9c79"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API sets the frame size if frame type is user/software defined frame.  <a href="group__DRV__FSI__TX__MODULE.html#ga6fe9ba0cc066b5da896e604d5dbd9c79">More...</a><br /></td></tr>
<tr class="separator:ga6fe9ba0cc066b5da896e604d5dbd9c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5924bee852d63ef3e53cc4880b3c69b"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#gae5924bee852d63ef3e53cc4880b3c69b">FSI_startTxTransmit</a> (uint32_t base)</td></tr>
<tr class="memdesc:gae5924bee852d63ef3e53cc4880b3c69b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API starts transmitting frames.  <a href="group__DRV__FSI__TX__MODULE.html#gae5924bee852d63ef3e53cc4880b3c69b">More...</a><br /></td></tr>
<tr class="separator:gae5924bee852d63ef3e53cc4880b3c69b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb26a6c5ab93ee1318e6fd540812967d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#gadb26a6c5ab93ee1318e6fd540812967d">FSI_setTxFrameTag</a> (uint32_t base, <a class="el" href="group__DRV__FSI__TX__MODULE.html#ga030a9c366d574155294e1b62d24ccaa0">FSI_FrameTag</a> frameTag)</td></tr>
<tr class="memdesc:gadb26a6c5ab93ee1318e6fd540812967d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API sets frame tag for transmission.  <a href="group__DRV__FSI__TX__MODULE.html#gadb26a6c5ab93ee1318e6fd540812967d">More...</a><br /></td></tr>
<tr class="separator:gadb26a6c5ab93ee1318e6fd540812967d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabedc2a4c7cdf00ab0c159ab80b855d7d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#gabedc2a4c7cdf00ab0c159ab80b855d7d">FSI_setTxUserDefinedData</a> (uint32_t base, uint16_t userDefData)</td></tr>
<tr class="memdesc:gabedc2a4c7cdf00ab0c159ab80b855d7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API sets user defined data for transmission It is an extra data field (8 bit) apart from regular data.  <a href="group__DRV__FSI__TX__MODULE.html#gabedc2a4c7cdf00ab0c159ab80b855d7d">More...</a><br /></td></tr>
<tr class="separator:gabedc2a4c7cdf00ab0c159ab80b855d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97cf4649cf062bc4e0e10275fbf8f137"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga97cf4649cf062bc4e0e10275fbf8f137">FSI_setTxBufferPtr</a> (uint32_t base, uint16_t bufPtrOff)</td></tr>
<tr class="memdesc:ga97cf4649cf062bc4e0e10275fbf8f137"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API sets the value for transmit buffer pointer at desired location.  <a href="group__DRV__FSI__TX__MODULE.html#ga97cf4649cf062bc4e0e10275fbf8f137">More...</a><br /></td></tr>
<tr class="separator:ga97cf4649cf062bc4e0e10275fbf8f137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4b11c5f2e917ba08cca780f2f92da39"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#gaf4b11c5f2e917ba08cca780f2f92da39">FSI_getTxBufferPtr</a> (uint32_t base, uint16_t *pBufPtrLoc)</td></tr>
<tr class="memdesc:gaf4b11c5f2e917ba08cca780f2f92da39"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API gets current buffer pointer locationn.  <a href="group__DRV__FSI__TX__MODULE.html#gaf4b11c5f2e917ba08cca780f2f92da39">More...</a><br /></td></tr>
<tr class="separator:gaf4b11c5f2e917ba08cca780f2f92da39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8c93ebce6161fb6608b73033e02fcd1"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#gab8c93ebce6161fb6608b73033e02fcd1">FSI_getTxWordCount</a> (uint32_t base, uint16_t *pWordCnt)</td></tr>
<tr class="memdesc:gab8c93ebce6161fb6608b73033e02fcd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API gets valid number of data words present in buffer which have not been transmitted yet.  <a href="group__DRV__FSI__TX__MODULE.html#gab8c93ebce6161fb6608b73033e02fcd1">More...</a><br /></td></tr>
<tr class="separator:gab8c93ebce6161fb6608b73033e02fcd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f6edc21d0aab434488495e05bf4d3df"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga6f6edc21d0aab434488495e05bf4d3df">FSI_enableTxPingTimer</a> (uint32_t base, uint32_t refValue, <a class="el" href="group__DRV__FSI__TX__MODULE.html#ga030a9c366d574155294e1b62d24ccaa0">FSI_FrameTag</a> pingFrameTag)</td></tr>
<tr class="memdesc:ga6f6edc21d0aab434488495e05bf4d3df"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enables ping timer logic and once set time elapses it sends signal to transmitter to send ping frame.  <a href="group__DRV__FSI__TX__MODULE.html#ga6f6edc21d0aab434488495e05bf4d3df">More...</a><br /></td></tr>
<tr class="separator:ga6f6edc21d0aab434488495e05bf4d3df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ed76cfd6620011dfd3bad79d99768f6"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga5ed76cfd6620011dfd3bad79d99768f6">FSI_setTxPingTag</a> (uint32_t base, <a class="el" href="group__DRV__FSI__TX__MODULE.html#ga030a9c366d574155294e1b62d24ccaa0">FSI_FrameTag</a> frameTag)</td></tr>
<tr class="memdesc:ga5ed76cfd6620011dfd3bad79d99768f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API sets the ping tag value, used by either timeout counter initiated PING frame transfer or by external ping trigger input.  <a href="group__DRV__FSI__TX__MODULE.html#ga5ed76cfd6620011dfd3bad79d99768f6">More...</a><br /></td></tr>
<tr class="separator:ga5ed76cfd6620011dfd3bad79d99768f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddee1947de071274e5161b2971a532ba"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#gaddee1947de071274e5161b2971a532ba">FSI_disableTxPingTimer</a> (uint32_t base)</td></tr>
<tr class="memdesc:gaddee1947de071274e5161b2971a532ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API disables ping timer logic.  <a href="group__DRV__FSI__TX__MODULE.html#gaddee1947de071274e5161b2971a532ba">More...</a><br /></td></tr>
<tr class="separator:gaddee1947de071274e5161b2971a532ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga691ed23e40e69c99e309e0ff9f5826f5"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga691ed23e40e69c99e309e0ff9f5826f5">FSI_enableTxExtPingTrigger</a> (uint32_t base, uint16_t extTrigSel)</td></tr>
<tr class="memdesc:ga691ed23e40e69c99e309e0ff9f5826f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enables external trigger to transmit a ping frame.  <a href="group__DRV__FSI__TX__MODULE.html#ga691ed23e40e69c99e309e0ff9f5826f5">More...</a><br /></td></tr>
<tr class="separator:ga691ed23e40e69c99e309e0ff9f5826f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac50a09f403c5912ed6d32886dfadaa26"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#gac50a09f403c5912ed6d32886dfadaa26">FSI_disableTxExtPingTrigger</a> (uint32_t base)</td></tr>
<tr class="memdesc:gac50a09f403c5912ed6d32886dfadaa26"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API disables external trigger logic.  <a href="group__DRV__FSI__TX__MODULE.html#gac50a09f403c5912ed6d32886dfadaa26">More...</a><br /></td></tr>
<tr class="separator:gac50a09f403c5912ed6d32886dfadaa26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac491ff826d915944ba1c4d5fa9a63f1e"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#gac491ff826d915944ba1c4d5fa9a63f1e">FSI_getTxCurrentPingTimeoutCounter</a> (uint32_t base, uint32_t *pPingToCnt)</td></tr>
<tr class="memdesc:gac491ff826d915944ba1c4d5fa9a63f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API gets current value of ping timeout logic counter.  <a href="group__DRV__FSI__TX__MODULE.html#gac491ff826d915944ba1c4d5fa9a63f1e">More...</a><br /></td></tr>
<tr class="separator:gac491ff826d915944ba1c4d5fa9a63f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5a758b0723db13873023e8a85785643"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#gac5a758b0723db13873023e8a85785643">FSI_lockTxCtrl</a> (uint32_t base)</td></tr>
<tr class="memdesc:gac5a758b0723db13873023e8a85785643"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API locks the control of all transmit control registers, once locked further writes will not take effect until system reset occurs.  <a href="group__DRV__FSI__TX__MODULE.html#gac5a758b0723db13873023e8a85785643">More...</a><br /></td></tr>
<tr class="separator:gac5a758b0723db13873023e8a85785643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f6ec09a95d6736dbb5a752eb06d703d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga8f6ec09a95d6736dbb5a752eb06d703d">FSI_getTxEventStatus</a> (uint32_t base, uint16_t *pEvtFlags)</td></tr>
<tr class="memdesc:ga8f6ec09a95d6736dbb5a752eb06d703d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API gets current status of all the error flags.  <a href="group__DRV__FSI__TX__MODULE.html#ga8f6ec09a95d6736dbb5a752eb06d703d">More...</a><br /></td></tr>
<tr class="separator:ga8f6ec09a95d6736dbb5a752eb06d703d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae43d1581f38dc885ef354ff62e9d4731"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#gae43d1581f38dc885ef354ff62e9d4731">FSI_forceTxEvents</a> (uint32_t base, uint16_t evtFlags)</td></tr>
<tr class="memdesc:gae43d1581f38dc885ef354ff62e9d4731"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enables user to set TX error flags.  <a href="group__DRV__FSI__TX__MODULE.html#gae43d1581f38dc885ef354ff62e9d4731">More...</a><br /></td></tr>
<tr class="separator:gae43d1581f38dc885ef354ff62e9d4731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5155275350f9945116d7b8931164a3bb"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga5155275350f9945116d7b8931164a3bb">FSI_clearTxEvents</a> (uint32_t base, uint16_t evtFlags)</td></tr>
<tr class="memdesc:ga5155275350f9945116d7b8931164a3bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enables user to clear TX error flags.  <a href="group__DRV__FSI__TX__MODULE.html#ga5155275350f9945116d7b8931164a3bb">More...</a><br /></td></tr>
<tr class="separator:ga5155275350f9945116d7b8931164a3bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c17770e26f066a5fef654a00b58051c"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga9c17770e26f066a5fef654a00b58051c">FSI_enableTxUserCRC</a> (uint32_t base, uint16_t userCRCValue)</td></tr>
<tr class="memdesc:ga9c17770e26f066a5fef654a00b58051c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API sets the CRC value to be picked transmission if transmission is configured to use user defined SW CRC.  <a href="group__DRV__FSI__TX__MODULE.html#ga9c17770e26f066a5fef654a00b58051c">More...</a><br /></td></tr>
<tr class="separator:ga9c17770e26f066a5fef654a00b58051c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a74106abfd5fcdcff7c72edf12329d1"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga8a74106abfd5fcdcff7c72edf12329d1">FSI_disableTxUserCRC</a> (uint32_t base)</td></tr>
<tr class="memdesc:ga8a74106abfd5fcdcff7c72edf12329d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API disables user defined CRC value, the transmitted CRC value is computed by hardware.  <a href="group__DRV__FSI__TX__MODULE.html#ga8a74106abfd5fcdcff7c72edf12329d1">More...</a><br /></td></tr>
<tr class="separator:ga8a74106abfd5fcdcff7c72edf12329d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd69ecca36f616f7f51f99a441620840"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#gadd69ecca36f616f7f51f99a441620840">FSI_setTxECCdata</a> (uint32_t base, uint32_t <a class="el" href="csl__udmap__tr_8h.html#ae4abda5e3cab325153762e904fd3f1e8">data</a>)</td></tr>
<tr class="memdesc:gadd69ecca36f616f7f51f99a441620840"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API sets data for ECC logic computaion.  <a href="group__DRV__FSI__TX__MODULE.html#gadd69ecca36f616f7f51f99a441620840">More...</a><br /></td></tr>
<tr class="separator:gadd69ecca36f616f7f51f99a441620840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99a542d2a18f102a04d75a78ee8112a8"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga99a542d2a18f102a04d75a78ee8112a8">FSI_getTxECCValue</a> (uint32_t base, uint16_t *pEccVal)</td></tr>
<tr class="memdesc:ga99a542d2a18f102a04d75a78ee8112a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API gets ECC value evaluated for 16/32 bit data.  <a href="group__DRV__FSI__TX__MODULE.html#ga99a542d2a18f102a04d75a78ee8112a8">More...</a><br /></td></tr>
<tr class="separator:ga99a542d2a18f102a04d75a78ee8112a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf372007b7814f6e7d46c59b3464d2721"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#gaf372007b7814f6e7d46c59b3464d2721">FSI_enableTxInterrupt</a> (uint32_t base, <a class="el" href="fsi_2v0_2fsi_8h.html#ad3a8bd4711243054c29b3215a9f05b6c">FSI_InterruptNum</a> intNum, uint16_t intFlags)</td></tr>
<tr class="memdesc:gaf372007b7814f6e7d46c59b3464d2721"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enables user to generate interrupt on occurrence of FSI_TxEventList events.  <a href="group__DRV__FSI__TX__MODULE.html#gaf372007b7814f6e7d46c59b3464d2721">More...</a><br /></td></tr>
<tr class="separator:gaf372007b7814f6e7d46c59b3464d2721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c44d3bd84aaa5dc2f3f3d1d97f47fa8"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga5c44d3bd84aaa5dc2f3f3d1d97f47fa8">FSI_disableTxInterrupt</a> (uint32_t base, <a class="el" href="fsi_2v0_2fsi_8h.html#ad3a8bd4711243054c29b3215a9f05b6c">FSI_InterruptNum</a> intNum, uint16_t intFlags)</td></tr>
<tr class="memdesc:ga5c44d3bd84aaa5dc2f3f3d1d97f47fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enables user to disable generation interrupt on occurrence of FSI TX events.  <a href="group__DRV__FSI__TX__MODULE.html#ga5c44d3bd84aaa5dc2f3f3d1d97f47fa8">More...</a><br /></td></tr>
<tr class="separator:ga5c44d3bd84aaa5dc2f3f3d1d97f47fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga954b0c1bc5058f5c9aa607e0f447229f"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga954b0c1bc5058f5c9aa607e0f447229f">FSI_getTxBufferAddress</a> (uint32_t base, uint32_t *pBufAddr)</td></tr>
<tr class="memdesc:ga954b0c1bc5058f5c9aa607e0f447229f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API gets address of TX data buffer.  <a href="group__DRV__FSI__TX__MODULE.html#ga954b0c1bc5058f5c9aa607e0f447229f">More...</a><br /></td></tr>
<tr class="separator:ga954b0c1bc5058f5c9aa607e0f447229f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae125216cd59099d7f549ace92e03ef5"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#gaae125216cd59099d7f549ace92e03ef5">FSI_resetTxModule</a> (uint32_t base, <a class="el" href="group__DRV__FSI__TX__MODULE.html#ga4d13219ea4e4fefa02d221d87c807c0e">FSI_TxSubmoduleInReset</a> submodule)</td></tr>
<tr class="memdesc:gaae125216cd59099d7f549ace92e03ef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API resets clock or ping timeout counter or entire TX module.  <a href="group__DRV__FSI__TX__MODULE.html#gaae125216cd59099d7f549ace92e03ef5">More...</a><br /></td></tr>
<tr class="separator:gaae125216cd59099d7f549ace92e03ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d2add9c6ceca89ae90f1006c952cca8"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga3d2add9c6ceca89ae90f1006c952cca8">FSI_clearTxModuleReset</a> (uint32_t base, <a class="el" href="group__DRV__FSI__TX__MODULE.html#ga4d13219ea4e4fefa02d221d87c807c0e">FSI_TxSubmoduleInReset</a> submodule)</td></tr>
<tr class="memdesc:ga3d2add9c6ceca89ae90f1006c952cca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API clears reset on clock or ping timeout counter or entire TX module.  <a href="group__DRV__FSI__TX__MODULE.html#ga3d2add9c6ceca89ae90f1006c952cca8">More...</a><br /></td></tr>
<tr class="separator:ga3d2add9c6ceca89ae90f1006c952cca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac812955d5f1add5c08039bcb1c1c5992"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#gac812955d5f1add5c08039bcb1c1c5992">FSI_writeTxBuffer</a> (uint32_t base, const uint16_t *pArray, uint16_t length, uint16_t bufOffset)</td></tr>
<tr class="memdesc:gac812955d5f1add5c08039bcb1c1c5992"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API writes data in FSI TX buffer.  <a href="group__DRV__FSI__TX__MODULE.html#gac812955d5f1add5c08039bcb1c1c5992">More...</a><br /></td></tr>
<tr class="separator:gac812955d5f1add5c08039bcb1c1c5992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdb1da2b92a8f006b58c349fdfa03c28"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#gafdb1da2b92a8f006b58c349fdfa03c28">FSI_performTxInitialization</a> (uint32_t base, uint16_t prescalar)</td></tr>
<tr class="memdesc:gafdb1da2b92a8f006b58c349fdfa03c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API initializes FSI TX module.  <a href="group__DRV__FSI__TX__MODULE.html#gafdb1da2b92a8f006b58c349fdfa03c28">More...</a><br /></td></tr>
<tr class="separator:gafdb1da2b92a8f006b58c349fdfa03c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadccd34d6543f6038c76d299b74ca432a"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#gadccd34d6543f6038c76d299b74ca432a">FSI_executeTxFlushSequence</a> (uint32_t base, uint16_t prescalar)</td></tr>
<tr class="memdesc:gadccd34d6543f6038c76d299b74ca432a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API sends Flush pattern sequence.  <a href="group__DRV__FSI__TX__MODULE.html#gadccd34d6543f6038c76d299b74ca432a">More...</a><br /></td></tr>
<tr class="separator:gadccd34d6543f6038c76d299b74ca432a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
FSI TX Enum type</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpef3120618e8e95d02c64d405c6f3bc01"></a><a class="anchor" id="FSI_TxEnum"></a></p>
</td></tr>
<tr class="memitem:ga61635a960710f050b578742988b9bfb1"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga61635a960710f050b578742988b9bfb1">FSI_TxEnumType</a></td></tr>
<tr class="memdesc:ga61635a960710f050b578742988b9bfb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This enumerator defines the types of possible FSI TX events.  <a href="group__DRV__FSI__TX__MODULE.html#ga61635a960710f050b578742988b9bfb1">More...</a><br /></td></tr>
<tr class="separator:ga61635a960710f050b578742988b9bfb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa80e44d32baf2476cd603b130f793f59"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#gaa80e44d32baf2476cd603b130f793f59">FSI_TX_EVT_FRAME_DONE</a>&#160;&#160;&#160;((uint16_t)0x1U)</td></tr>
<tr class="separator:gaa80e44d32baf2476cd603b130f793f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeeb0e15369372aadedad98ee22810047"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#gaeeb0e15369372aadedad98ee22810047">FSI_TX_EVT_BUF_UNDERRUN</a>&#160;&#160;&#160;((uint16_t)0x2U)</td></tr>
<tr class="separator:gaeeb0e15369372aadedad98ee22810047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffd8c6a80721e43a9f595d016d51a143"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#gaffd8c6a80721e43a9f595d016d51a143">FSI_TX_EVT_BUF_OVERRUN</a>&#160;&#160;&#160;((uint16_t)0x4U)</td></tr>
<tr class="separator:gaffd8c6a80721e43a9f595d016d51a143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48139fba8d50bcaab322637e5c46aa2a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga48139fba8d50bcaab322637e5c46aa2a">FSI_TX_EVT_PING_TIMEOUT</a>&#160;&#160;&#160;((uint16_t)0x8U)</td></tr>
<tr class="separator:ga48139fba8d50bcaab322637e5c46aa2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d1ce4dc0fe6c4a7e9c859d13529a922"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga5d1ce4dc0fe6c4a7e9c859d13529a922">FSI_TX_EVT_PING_HW_TRIG</a>&#160;&#160;&#160;((uint16_t)0x8U)</td></tr>
<tr class="separator:ga5d1ce4dc0fe6c4a7e9c859d13529a922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b40a1b7facf887a512b0ddb801cb231"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga3b40a1b7facf887a512b0ddb801cb231">FSI_TX_EVTMASK</a>&#160;&#160;&#160;((uint16_t)0xFU)</td></tr>
<tr class="memdesc:ga3b40a1b7facf887a512b0ddb801cb231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask of all TX Event types.  <a href="group__DRV__FSI__TX__MODULE.html#ga3b40a1b7facf887a512b0ddb801cb231">More...</a><br /></td></tr>
<tr class="separator:ga3b40a1b7facf887a512b0ddb801cb231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga084cf2399ba15047ad29de218dc41267"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga084cf2399ba15047ad29de218dc41267">FSI_TX_MAX_NUM_EXT_TRIGGERS</a>&#160;&#160;&#160;((uint16_t)0x40U)</td></tr>
<tr class="memdesc:ga084cf2399ba15047ad29de218dc41267"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum number of external input for triggering frame-transmission  <a href="group__DRV__FSI__TX__MODULE.html#ga084cf2399ba15047ad29de218dc41267">More...</a><br /></td></tr>
<tr class="separator:ga084cf2399ba15047ad29de218dc41267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89a22b039b103381bcb217ea81b93816"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga89a22b039b103381bcb217ea81b93816">FSI_TX_INT2_CTRL_S</a>&#160;&#160;&#160;((uint16_t)0x8U)</td></tr>
<tr class="memdesc:ga89a22b039b103381bcb217ea81b93816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts needed to control FSI TX interrupt generation on INT2.  <a href="group__DRV__FSI__TX__MODULE.html#ga89a22b039b103381bcb217ea81b93816">More...</a><br /></td></tr>
<tr class="separator:ga89a22b039b103381bcb217ea81b93816"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
FSI TX submodules can be in reset</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp2ace4a675d90bc9b9a36022d963efb30"></a><a class="anchor" id="FSI_TxSubmoduleInReset"></a></p>
</td></tr>
<tr class="memitem:ga4d13219ea4e4fefa02d221d87c807c0e"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga4d13219ea4e4fefa02d221d87c807c0e">FSI_TxSubmoduleInReset</a></td></tr>
<tr class="memdesc:ga4d13219ea4e4fefa02d221d87c807c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">TX submodules that can be reset with reset APIs.  <a href="group__DRV__FSI__TX__MODULE.html#ga4d13219ea4e4fefa02d221d87c807c0e">More...</a><br /></td></tr>
<tr class="separator:ga4d13219ea4e4fefa02d221d87c807c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa31951ff8a4cc30503cfae8b0a37e51"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#gafa31951ff8a4cc30503cfae8b0a37e51">FSI_TX_MAIN_CORE_RESET</a>&#160;&#160;&#160;((uint32_t)0x0U)</td></tr>
<tr class="separator:gafa31951ff8a4cc30503cfae8b0a37e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga771fd83cc9c3a84359834b8a8c973f16"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga771fd83cc9c3a84359834b8a8c973f16">FSI_TX_CLOCK_RESET</a>&#160;&#160;&#160;((uint32_t)0x1U)</td></tr>
<tr class="separator:ga771fd83cc9c3a84359834b8a8c973f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4dc528097912e3d2e1a60ccec961c37"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#gaa4dc528097912e3d2e1a60ccec961c37">FSI_TX_PING_TIMEOUT_CNT_RESET</a>&#160;&#160;&#160;((uint32_t)0x2U)</td></tr>
<tr class="separator:gaa4dc528097912e3d2e1a60ccec961c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
FSI TX start mode</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpae74f6044aab0916092e8dcd0f945592"></a><a class="anchor" id="FSI_TxStartMode"></a></p>
</td></tr>
<tr class="memitem:ga8d5f6ee7c83a3e7c64560661046c126e"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga8d5f6ee7c83a3e7c64560661046c126e">FSI_TxStartMode</a></td></tr>
<tr class="memdesc:ga8d5f6ee7c83a3e7c64560661046c126e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start Mode for TX frame transmission (i.e. how transmission will start)  <a href="group__DRV__FSI__TX__MODULE.html#ga8d5f6ee7c83a3e7c64560661046c126e">More...</a><br /></td></tr>
<tr class="separator:ga8d5f6ee7c83a3e7c64560661046c126e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f4ee47e644110b6937cdccc08b0189b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga1f4ee47e644110b6937cdccc08b0189b">FSI_TX_START_FRAME_CTRL</a>&#160;&#160;&#160;((uint32_t)0x0U)</td></tr>
<tr class="separator:ga1f4ee47e644110b6937cdccc08b0189b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3631bc364636a54c8abf6abcb5c773eb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga3631bc364636a54c8abf6abcb5c773eb">FSI_TX_START_EXT_TRIG</a>&#160;&#160;&#160;((uint32_t)0x1U)</td></tr>
<tr class="separator:ga3631bc364636a54c8abf6abcb5c773eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga527b25ec9fc4a13ee15fefe0166dd433"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga527b25ec9fc4a13ee15fefe0166dd433">FSI_TX_START_FRAME_CTRL_OR_UDATA_TAG</a>&#160;&#160;&#160;((uint32_t)0x2U)</td></tr>
<tr class="separator:ga527b25ec9fc4a13ee15fefe0166dd433"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
FSI TX input clock select</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp74def2ab1b7f7c1201e95b3ce9ef3fe9"></a><a class="anchor" id="FSI_TxClkSel"></a></p>
</td></tr>
<tr class="memitem:ga6f96c0ca6b8eed9423cb3d08b8c3f2a7"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga6f96c0ca6b8eed9423cb3d08b8c3f2a7">FSI_TxClkSel</a></td></tr>
<tr class="memdesc:ga6f96c0ca6b8eed9423cb3d08b8c3f2a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">FSI TX input clock select.  <a href="group__DRV__FSI__TX__MODULE.html#ga6f96c0ca6b8eed9423cb3d08b8c3f2a7">More...</a><br /></td></tr>
<tr class="separator:ga6f96c0ca6b8eed9423cb3d08b8c3f2a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaea2618e5179cfca188bcaa3c17e6c37"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#gaaea2618e5179cfca188bcaa3c17e6c37">FSI_TX_CLK_SEL0</a>&#160;&#160;&#160;((uint32_t)0x0U)</td></tr>
<tr class="separator:gaaea2618e5179cfca188bcaa3c17e6c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf18866bdc119105445dbf5e864e675eb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#gaf18866bdc119105445dbf5e864e675eb">FSI_TX_CLK_SEL1</a>&#160;&#160;&#160;((uint32_t)0x1U)</td></tr>
<tr class="separator:gaf18866bdc119105445dbf5e864e675eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
FSI frame tag</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp0f76513fe2b07d27d62eda499f2b4a91"></a><a class="anchor" id="FSI_FrameTag"></a></p>
</td></tr>
<tr class="memitem:ga030a9c366d574155294e1b62d24ccaa0"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga030a9c366d574155294e1b62d24ccaa0">FSI_FrameTag</a></td></tr>
<tr class="memdesc:ga030a9c366d574155294e1b62d24ccaa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">FSI frame tag values.  <a href="group__DRV__FSI__TX__MODULE.html#ga030a9c366d574155294e1b62d24ccaa0">More...</a><br /></td></tr>
<tr class="separator:ga030a9c366d574155294e1b62d24ccaa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d18633afe8991f366b6f60caf6ccf86"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga0d18633afe8991f366b6f60caf6ccf86">FSI_FRAME_TAG0</a>&#160;&#160;&#160;((uint32_t)0x0U)</td></tr>
<tr class="separator:ga0d18633afe8991f366b6f60caf6ccf86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6ff91aa304a1e3e032b737239e88acc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#gab6ff91aa304a1e3e032b737239e88acc">FSI_FRAME_TAG1</a>&#160;&#160;&#160;((uint32_t)0x1U)</td></tr>
<tr class="separator:gab6ff91aa304a1e3e032b737239e88acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac409452357d32cf09e8dcd4e456a4b63"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#gac409452357d32cf09e8dcd4e456a4b63">FSI_FRAME_TAG2</a>&#160;&#160;&#160;((uint32_t)0x2U)</td></tr>
<tr class="separator:gac409452357d32cf09e8dcd4e456a4b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f73d6f335bd21479617937819bfce63"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga9f73d6f335bd21479617937819bfce63">FSI_FRAME_TAG3</a>&#160;&#160;&#160;((uint32_t)0x3U)</td></tr>
<tr class="separator:ga9f73d6f335bd21479617937819bfce63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3573452386be2e61e6d6a9ade0303f3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#gad3573452386be2e61e6d6a9ade0303f3">FSI_FRAME_TAG4</a>&#160;&#160;&#160;((uint32_t)0x4U)</td></tr>
<tr class="separator:gad3573452386be2e61e6d6a9ade0303f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27573b97fbb3bfe67308b36eea75a587"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga27573b97fbb3bfe67308b36eea75a587">FSI_FRAME_TAG5</a>&#160;&#160;&#160;((uint32_t)0x5U)</td></tr>
<tr class="separator:ga27573b97fbb3bfe67308b36eea75a587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3911045660bbdb17d272704a24e172ba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga3911045660bbdb17d272704a24e172ba">FSI_FRAME_TAG6</a>&#160;&#160;&#160;((uint32_t)0x6U)</td></tr>
<tr class="separator:ga3911045660bbdb17d272704a24e172ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga300e0b3cacce65503dfe6a4b5ae592be"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga300e0b3cacce65503dfe6a4b5ae592be">FSI_FRAME_TAG7</a>&#160;&#160;&#160;((uint32_t)0x7U)</td></tr>
<tr class="separator:ga300e0b3cacce65503dfe6a4b5ae592be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac34ff29f0247724c7d0088f1fdd05275"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#gac34ff29f0247724c7d0088f1fdd05275">FSI_FRAME_TAG8</a>&#160;&#160;&#160;((uint32_t)0x8U)</td></tr>
<tr class="separator:gac34ff29f0247724c7d0088f1fdd05275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4fbd4ccf4c2f68f126fa9eed1244212"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#gaa4fbd4ccf4c2f68f126fa9eed1244212">FSI_FRAME_TAG9</a>&#160;&#160;&#160;((uint32_t)0x9U)</td></tr>
<tr class="separator:gaa4fbd4ccf4c2f68f126fa9eed1244212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58f4af7d91a95dadb07a6ae11d49f5ef"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga58f4af7d91a95dadb07a6ae11d49f5ef">FSI_FRAME_TAG10</a>&#160;&#160;&#160;((uint32_t)0xAU)</td></tr>
<tr class="separator:ga58f4af7d91a95dadb07a6ae11d49f5ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac69ac61ddc0bc85abe4a60aac59f66fa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#gac69ac61ddc0bc85abe4a60aac59f66fa">FSI_FRAME_TAG11</a>&#160;&#160;&#160;((uint32_t)0xBU)</td></tr>
<tr class="separator:gac69ac61ddc0bc85abe4a60aac59f66fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga135a98434b4326b9872800ffc6851961"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga135a98434b4326b9872800ffc6851961">FSI_FRAME_TAG12</a>&#160;&#160;&#160;((uint32_t)0xCU)</td></tr>
<tr class="separator:ga135a98434b4326b9872800ffc6851961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1c86d55a9f089d06488b882ba11bb7c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#gaf1c86d55a9f089d06488b882ba11bb7c">FSI_FRAME_TAG13</a>&#160;&#160;&#160;((uint32_t)0xDU)</td></tr>
<tr class="separator:gaf1c86d55a9f089d06488b882ba11bb7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98534ac7aa08b21e297eef7e21c20468"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga98534ac7aa08b21e297eef7e21c20468">FSI_FRAME_TAG14</a>&#160;&#160;&#160;((uint32_t)0xEU)</td></tr>
<tr class="separator:ga98534ac7aa08b21e297eef7e21c20468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba7ee77a766d3b2ff63549562fdc1746"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FSI__TX__MODULE.html#gaba7ee77a766d3b2ff63549562fdc1746">FSI_FRAME_TAG15</a>&#160;&#160;&#160;((uint32_t)0xFU)</td></tr>
<tr class="separator:gaba7ee77a766d3b2ff63549562fdc1746"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gaa80e44d32baf2476cd603b130f793f59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa80e44d32baf2476cd603b130f793f59">&#9670;&nbsp;</a></span>FSI_TX_EVT_FRAME_DONE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_TX_EVT_FRAME_DONE&#160;&#160;&#160;((uint16_t)0x1U)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaeeb0e15369372aadedad98ee22810047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeeb0e15369372aadedad98ee22810047">&#9670;&nbsp;</a></span>FSI_TX_EVT_BUF_UNDERRUN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_TX_EVT_BUF_UNDERRUN&#160;&#160;&#160;((uint16_t)0x2U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TX frame done event </p>

</div>
</div>
<a id="gaffd8c6a80721e43a9f595d016d51a143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffd8c6a80721e43a9f595d016d51a143">&#9670;&nbsp;</a></span>FSI_TX_EVT_BUF_OVERRUN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_TX_EVT_BUF_OVERRUN&#160;&#160;&#160;((uint16_t)0x4U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TX buffer underrun event </p>

</div>
</div>
<a id="ga48139fba8d50bcaab322637e5c46aa2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48139fba8d50bcaab322637e5c46aa2a">&#9670;&nbsp;</a></span>FSI_TX_EVT_PING_TIMEOUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_TX_EVT_PING_TIMEOUT&#160;&#160;&#160;((uint16_t)0x8U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TX buffer overrun event </p>

</div>
</div>
<a id="ga5d1ce4dc0fe6c4a7e9c859d13529a922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d1ce4dc0fe6c4a7e9c859d13529a922">&#9670;&nbsp;</a></span>FSI_TX_EVT_PING_HW_TRIG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_TX_EVT_PING_HW_TRIG&#160;&#160;&#160;((uint16_t)0x8U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TX ping timeout event </p>

</div>
</div>
<a id="ga3b40a1b7facf887a512b0ddb801cb231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b40a1b7facf887a512b0ddb801cb231">&#9670;&nbsp;</a></span>FSI_TX_EVTMASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_TX_EVTMASK&#160;&#160;&#160;((uint16_t)0xFU)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mask of all TX Event types. </p>
<p>TX ping hardware trigger event </p>

</div>
</div>
<a id="ga084cf2399ba15047ad29de218dc41267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga084cf2399ba15047ad29de218dc41267">&#9670;&nbsp;</a></span>FSI_TX_MAX_NUM_EXT_TRIGGERS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_TX_MAX_NUM_EXT_TRIGGERS&#160;&#160;&#160;((uint16_t)0x40U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>maximum number of external input for triggering frame-transmission </p>

</div>
</div>
<a id="ga89a22b039b103381bcb217ea81b93816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89a22b039b103381bcb217ea81b93816">&#9670;&nbsp;</a></span>FSI_TX_INT2_CTRL_S</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_TX_INT2_CTRL_S&#160;&#160;&#160;((uint16_t)0x8U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts needed to control FSI TX interrupt generation on INT2. </p>

</div>
</div>
<a id="gafa31951ff8a4cc30503cfae8b0a37e51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa31951ff8a4cc30503cfae8b0a37e51">&#9670;&nbsp;</a></span>FSI_TX_MAIN_CORE_RESET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_TX_MAIN_CORE_RESET&#160;&#160;&#160;((uint32_t)0x0U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset entire TX Module </p>

</div>
</div>
<a id="ga771fd83cc9c3a84359834b8a8c973f16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga771fd83cc9c3a84359834b8a8c973f16">&#9670;&nbsp;</a></span>FSI_TX_CLOCK_RESET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_TX_CLOCK_RESET&#160;&#160;&#160;((uint32_t)0x1U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset only TX clock </p>

</div>
</div>
<a id="gaa4dc528097912e3d2e1a60ccec961c37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4dc528097912e3d2e1a60ccec961c37">&#9670;&nbsp;</a></span>FSI_TX_PING_TIMEOUT_CNT_RESET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_TX_PING_TIMEOUT_CNT_RESET&#160;&#160;&#160;((uint32_t)0x2U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset ping timeout counter </p>

</div>
</div>
<a id="ga1f4ee47e644110b6937cdccc08b0189b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f4ee47e644110b6937cdccc08b0189b">&#9670;&nbsp;</a></span>FSI_TX_START_FRAME_CTRL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_TX_START_FRAME_CTRL&#160;&#160;&#160;((uint32_t)0x0U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SW write of START bit in TX_PKT_CTRL register </p>

</div>
</div>
<a id="ga3631bc364636a54c8abf6abcb5c773eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3631bc364636a54c8abf6abcb5c773eb">&#9670;&nbsp;</a></span>FSI_TX_START_EXT_TRIG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_TX_START_EXT_TRIG&#160;&#160;&#160;((uint32_t)0x1U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rising edge on external trigger </p>

</div>
</div>
<a id="ga527b25ec9fc4a13ee15fefe0166dd433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga527b25ec9fc4a13ee15fefe0166dd433">&#9670;&nbsp;</a></span>FSI_TX_START_FRAME_CTRL_OR_UDATA_TAG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_TX_START_FRAME_CTRL_OR_UDATA_TAG&#160;&#160;&#160;((uint32_t)0x2U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Either SW write of START bit or Frame completion </p>

</div>
</div>
<a id="gaaea2618e5179cfca188bcaa3c17e6c37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaea2618e5179cfca188bcaa3c17e6c37">&#9670;&nbsp;</a></span>FSI_TX_CLK_SEL0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_TX_CLK_SEL0&#160;&#160;&#160;((uint32_t)0x0U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Input clock select 0 </p>

</div>
</div>
<a id="gaf18866bdc119105445dbf5e864e675eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf18866bdc119105445dbf5e864e675eb">&#9670;&nbsp;</a></span>FSI_TX_CLK_SEL1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_TX_CLK_SEL1&#160;&#160;&#160;((uint32_t)0x1U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Input clock select 1 </p>

</div>
</div>
<a id="ga0d18633afe8991f366b6f60caf6ccf86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d18633afe8991f366b6f60caf6ccf86">&#9670;&nbsp;</a></span>FSI_FRAME_TAG0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_FRAME_TAG0&#160;&#160;&#160;((uint32_t)0x0U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frame tag value 0 </p>

</div>
</div>
<a id="gab6ff91aa304a1e3e032b737239e88acc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6ff91aa304a1e3e032b737239e88acc">&#9670;&nbsp;</a></span>FSI_FRAME_TAG1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_FRAME_TAG1&#160;&#160;&#160;((uint32_t)0x1U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frame tag value 1 </p>

</div>
</div>
<a id="gac409452357d32cf09e8dcd4e456a4b63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac409452357d32cf09e8dcd4e456a4b63">&#9670;&nbsp;</a></span>FSI_FRAME_TAG2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_FRAME_TAG2&#160;&#160;&#160;((uint32_t)0x2U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frame tag value 2 </p>

</div>
</div>
<a id="ga9f73d6f335bd21479617937819bfce63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f73d6f335bd21479617937819bfce63">&#9670;&nbsp;</a></span>FSI_FRAME_TAG3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_FRAME_TAG3&#160;&#160;&#160;((uint32_t)0x3U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frame tag value 3 </p>

</div>
</div>
<a id="gad3573452386be2e61e6d6a9ade0303f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3573452386be2e61e6d6a9ade0303f3">&#9670;&nbsp;</a></span>FSI_FRAME_TAG4</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_FRAME_TAG4&#160;&#160;&#160;((uint32_t)0x4U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frame tag value 4 </p>

</div>
</div>
<a id="ga27573b97fbb3bfe67308b36eea75a587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27573b97fbb3bfe67308b36eea75a587">&#9670;&nbsp;</a></span>FSI_FRAME_TAG5</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_FRAME_TAG5&#160;&#160;&#160;((uint32_t)0x5U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frame tag value 5 </p>

</div>
</div>
<a id="ga3911045660bbdb17d272704a24e172ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3911045660bbdb17d272704a24e172ba">&#9670;&nbsp;</a></span>FSI_FRAME_TAG6</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_FRAME_TAG6&#160;&#160;&#160;((uint32_t)0x6U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frame tag value 6 </p>

</div>
</div>
<a id="ga300e0b3cacce65503dfe6a4b5ae592be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga300e0b3cacce65503dfe6a4b5ae592be">&#9670;&nbsp;</a></span>FSI_FRAME_TAG7</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_FRAME_TAG7&#160;&#160;&#160;((uint32_t)0x7U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frame tag value 7 </p>

</div>
</div>
<a id="gac34ff29f0247724c7d0088f1fdd05275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac34ff29f0247724c7d0088f1fdd05275">&#9670;&nbsp;</a></span>FSI_FRAME_TAG8</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_FRAME_TAG8&#160;&#160;&#160;((uint32_t)0x8U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frame tag value 8 </p>

</div>
</div>
<a id="gaa4fbd4ccf4c2f68f126fa9eed1244212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4fbd4ccf4c2f68f126fa9eed1244212">&#9670;&nbsp;</a></span>FSI_FRAME_TAG9</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_FRAME_TAG9&#160;&#160;&#160;((uint32_t)0x9U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frame tag value 9 </p>

</div>
</div>
<a id="ga58f4af7d91a95dadb07a6ae11d49f5ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58f4af7d91a95dadb07a6ae11d49f5ef">&#9670;&nbsp;</a></span>FSI_FRAME_TAG10</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_FRAME_TAG10&#160;&#160;&#160;((uint32_t)0xAU)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frame tag value 10 </p>

</div>
</div>
<a id="gac69ac61ddc0bc85abe4a60aac59f66fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac69ac61ddc0bc85abe4a60aac59f66fa">&#9670;&nbsp;</a></span>FSI_FRAME_TAG11</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_FRAME_TAG11&#160;&#160;&#160;((uint32_t)0xBU)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frame tag value 11 </p>

</div>
</div>
<a id="ga135a98434b4326b9872800ffc6851961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga135a98434b4326b9872800ffc6851961">&#9670;&nbsp;</a></span>FSI_FRAME_TAG12</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_FRAME_TAG12&#160;&#160;&#160;((uint32_t)0xCU)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frame tag value 12 </p>

</div>
</div>
<a id="gaf1c86d55a9f089d06488b882ba11bb7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1c86d55a9f089d06488b882ba11bb7c">&#9670;&nbsp;</a></span>FSI_FRAME_TAG13</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_FRAME_TAG13&#160;&#160;&#160;((uint32_t)0xDU)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frame tag value 13 </p>

</div>
</div>
<a id="ga98534ac7aa08b21e297eef7e21c20468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98534ac7aa08b21e297eef7e21c20468">&#9670;&nbsp;</a></span>FSI_FRAME_TAG14</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_FRAME_TAG14&#160;&#160;&#160;((uint32_t)0xEU)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frame tag value 14 </p>

</div>
</div>
<a id="gaba7ee77a766d3b2ff63549562fdc1746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba7ee77a766d3b2ff63549562fdc1746">&#9670;&nbsp;</a></span>FSI_FRAME_TAG15</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSI_FRAME_TAG15&#160;&#160;&#160;((uint32_t)0xFU)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frame tag value 15 </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga61635a960710f050b578742988b9bfb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61635a960710f050b578742988b9bfb1">&#9670;&nbsp;</a></span>FSI_TxEnumType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="group__DRV__FSI__TX__MODULE.html#ga61635a960710f050b578742988b9bfb1">FSI_TxEnumType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This enumerator defines the types of possible FSI TX events. </p>
<p>Values that can be passed to APIs to enable/disable interrupts and also to set/get/clear event status on FSI TX operation.</p>
<p>There are 4 supported interrupts related to TX events, all are available as event status as well excecpt 4th one. 1) frame transmission done 2) transmit buffer is underrun 3) transmit buffer is overrun 4) ping counter timeout</p>
<p>Ping frame transmission upon hardware trigger (ping watchdog or external trigger) is shown as event status. </p>

</div>
</div>
<a id="ga4d13219ea4e4fefa02d221d87c807c0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d13219ea4e4fefa02d221d87c807c0e">&#9670;&nbsp;</a></span>FSI_TxSubmoduleInReset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="group__DRV__FSI__TX__MODULE.html#ga4d13219ea4e4fefa02d221d87c807c0e">FSI_TxSubmoduleInReset</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TX submodules that can be reset with reset APIs. </p>

</div>
</div>
<a id="ga8d5f6ee7c83a3e7c64560661046c126e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d5f6ee7c83a3e7c64560661046c126e">&#9670;&nbsp;</a></span>FSI_TxStartMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="group__DRV__FSI__TX__MODULE.html#ga8d5f6ee7c83a3e7c64560661046c126e">FSI_TxStartMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start Mode for TX frame transmission (i.e. how transmission will start) </p>

</div>
</div>
<a id="ga6f96c0ca6b8eed9423cb3d08b8c3f2a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f96c0ca6b8eed9423cb3d08b8c3f2a7">&#9670;&nbsp;</a></span>FSI_TxClkSel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="group__DRV__FSI__TX__MODULE.html#ga6f96c0ca6b8eed9423cb3d08b8c3f2a7">FSI_TxClkSel</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>FSI TX input clock select. </p>

</div>
</div>
<a id="ga030a9c366d574155294e1b62d24ccaa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga030a9c366d574155294e1b62d24ccaa0">&#9670;&nbsp;</a></span>FSI_FrameTag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="group__DRV__FSI__TX__MODULE.html#ga030a9c366d574155294e1b62d24ccaa0">FSI_FrameTag</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>FSI frame tag values. </p>
<p>4 bit field inside FSI frame is available to set tag value (0-15) </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gabf37b3803f5e4fb2c80edc12c41a72d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf37b3803f5e4fb2c80edc12c41a72d7">&#9670;&nbsp;</a></span>FSI_sendTxFlush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_sendTxFlush </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API sends FLUSH pattern. </p>
<p>FLUSH pattern (toggle data lines followed by toggle on clocks) should be sent only when FSI TX is not under SOFT_RESET and the clock to the transmit core has been turned ON.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI TX module</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base addr parameter </dd></dl>

</div>
</div>
<a id="ga619f6852f1e177325deeb4b69da94291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga619f6852f1e177325deeb4b69da94291">&#9670;&nbsp;</a></span>FSI_stopTxFlush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_stopTxFlush </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API stops FLUSH pattern transmission. </p>
<p>Transmission of FLUSH pattern should be stopped before starting sending frames. Generally during initilization a pair of send/stop APIs for FLUSH pattern is called to clear data/clock lines.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI TX module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base addr parameter </dd></dl>

</div>
</div>
<a id="gad0638cfeb1030dec605524c8de543190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0638cfeb1030dec605524c8de543190">&#9670;&nbsp;</a></span>FSI_selectTxPLLClock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_selectTxPLLClock </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga6f96c0ca6b8eed9423cb3d08b8c3f2a7">FSI_TxClkSel</a>&#160;</td>
          <td class="paramname"><em>clkSel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API selects PLL clock as source for clock dividers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI TX module. </td></tr>
    <tr><td class="paramname">clkSel</td><td>[IN] Input PLL clock select to the FSI TX module refer <a class="el" href="group__DRV__FSI__TX__MODULE.html#ga6f96c0ca6b8eed9423cb3d08b8c3f2a7" title="FSI TX input clock select.">FSI_TxClkSel</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base addr parameter </dd></dl>

</div>
</div>
<a id="ga4aaf8788aa6717017596f258a4894551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4aaf8788aa6717017596f258a4894551">&#9670;&nbsp;</a></span>FSI_enableTxClock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_enableTxClock </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>preScaleValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API sets clock division prescalar and enables the transmit clock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI TX module. </td></tr>
    <tr><td class="paramname">preScaleValue</td><td>[IN] prescale value used to generate transmit clock, it defines the division value of /2,/3,/4, etc. of PLL CLK</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="ga9216b8c4b4366e20ee36dd45a278febd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9216b8c4b4366e20ee36dd45a278febd">&#9670;&nbsp;</a></span>FSI_disableTxClock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_disableTxClock </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API disables transmit clock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI TX module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="ga00ded17f9d497a3c626741483f8da779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00ded17f9d497a3c626741483f8da779">&#9670;&nbsp;</a></span>FSI_setTxDataWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_setTxDataWidth </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DRV__FSI__MODULE.html#ga5dbdfd7ff13523f74955cbb7707726f2">FSI_DataWidth</a>&#160;</td>
          <td class="paramname"><em>dataWidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API sets Data width for transmission. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI TX module. </td></tr>
    <tr><td class="paramname">dataWidth</td><td>[IN] Data lines used for TX operation refer <a class="el" href="group__DRV__FSI__MODULE.html#ga5dbdfd7ff13523f74955cbb7707726f2" title="Data lines used for transmit/receive operation.">FSI_DataWidth</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="gaaccd73876f639066e4e88aa7920b48d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaccd73876f639066e4e88aa7920b48d6">&#9670;&nbsp;</a></span>FSI_enableTxSPIMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_enableTxSPIMode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enables SPI compatible mode. </p>
<p><br  />
 This API is only applicable when communicating with a SPI interface</p>
<p>FSI supports a compatibility mode in order to communicate with legacy peripherals like SPI. Only the 16-bit mode of SPI will be supported. All the frame structures, CRC checks and will be identical to the normal FSI frames.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI TX module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="ga60d39657a2b622e564b3882c3da93b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60d39657a2b622e564b3882c3da93b6b">&#9670;&nbsp;</a></span>FSI_disableTxSPIMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_disableTxSPIMode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API disables SPI compatible mode. </p>
<p><br  />
 This API is only applicable when communicating with a SPI interface</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI TX module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="ga29cf99b973b8028fa441bbba1e3a0eaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29cf99b973b8028fa441bbba1e3a0eaf">&#9670;&nbsp;</a></span>FSI_setTxStartMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_setTxStartMode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga8d5f6ee7c83a3e7c64560661046c126e">FSI_TxStartMode</a>&#160;</td>
          <td class="paramname"><em>txStartMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API sets start mode for any frame transmission. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI TX module. </td></tr>
    <tr><td class="paramname">txStartMode</td><td>[IN] Refer <a class="el" href="group__DRV__FSI__TX__MODULE.html#ga8d5f6ee7c83a3e7c64560661046c126e" title="Start Mode for TX frame transmission (i.e. how transmission will start)">FSI_TxStartMode</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="ga0bf00afbb5d04bc3a4330a2b14792190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0bf00afbb5d04bc3a4330a2b14792190">&#9670;&nbsp;</a></span>FSI_setTxPingTimeoutMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_setTxPingTimeoutMode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fsi_2v0_2fsi_8h.html#a3008502af132b9be684563c208957180">FSI_PingTimeoutMode</a>&#160;</td>
          <td class="paramname"><em>pingTimeoutMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API sets HW/SW initiated TX ping timeout mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI TX module. </td></tr>
    <tr><td class="paramname">pingTimeoutMode</td><td>[IN] Refer <a class="el" href="fsi_2v0_2fsi_8h.html#a3008502af132b9be684563c208957180" title="FSI ping timeout mode.">FSI_PingTimeoutMode</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="ga8efc9b47b6d7d489f189c76c5a136da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8efc9b47b6d7d489f189c76c5a136da8">&#9670;&nbsp;</a></span>FSI_setTxExtFrameTrigger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_setTxExtFrameTrigger </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>extInputNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API sets a particular external input to trigger transmission. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI TX module. </td></tr>
    <tr><td class="paramname">extInputNum</td><td>[IN] external input number, from 0 to 31</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="ga0840498fa6d03fd65614f10a58fa07ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0840498fa6d03fd65614f10a58fa07ae">&#9670;&nbsp;</a></span>FSI_enableTxCRCForceError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_enableTxCRCForceError </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enables CRC value of a data frame to be forced to zero. </p>
<p>CRC value of the data frame will be forced to 0 whenever there is a transmission and buffer over-run or under-run condition happens. The idea is to force a corruption of the CRC since the data is not guaranteed to be reliable</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI TX module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="ga5628350f8643f8e6a5ccfd8883108364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5628350f8643f8e6a5ccfd8883108364">&#9670;&nbsp;</a></span>FSI_disableTxCRCForceError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_disableTxCRCForceError </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API disables forcing of CRC value of a data frame to zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI TX module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="ga27a5fee0227ccd6043962f30b74b2ade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27a5fee0227ccd6043962f30b74b2ade">&#9670;&nbsp;</a></span>FSI_setTxECCComputeWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_setTxECCComputeWidth </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fsi_2v0_2fsi_8h.html#aa3bcb498544ab9219714d4531ebcadb9">FSI_ECCComputeWidth</a>&#160;</td>
          <td class="paramname"><em>eccComputeWidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API select between 16-bit and 32-bit ECC computation for FSI TX. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI TX module. </td></tr>
    <tr><td class="paramname">eccComputeWidth</td><td>[IN] Refer <a class="el" href="fsi_2v0_2fsi_8h.html#aa3bcb498544ab9219714d4531ebcadb9" title="ECC Computation width - 16 bit or 32 bit.">FSI_ECCComputeWidth</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="gabdf14723e0a040151c0903647c3211c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdf14723e0a040151c0903647c3211c3">&#9670;&nbsp;</a></span>FSI_setTxFrameType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_setTxFrameType </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fsi_2v0_2fsi_8h.html#a5d351d5afbe8aa861a52ebcd12a91b38">FSI_FrameType</a>&#160;</td>
          <td class="paramname"><em>frameType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API sets frame type for transmission. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI TX module. </td></tr>
    <tr><td class="paramname">frameType</td><td>[IN] Refer <a class="el" href="fsi_2v0_2fsi_8h.html#a5d351d5afbe8aa861a52ebcd12a91b38" title="FSI frame type.">FSI_FrameType</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="ga6fe9ba0cc066b5da896e604d5dbd9c79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fe9ba0cc066b5da896e604d5dbd9c79">&#9670;&nbsp;</a></span>FSI_setTxSoftwareFrameSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_setTxSoftwareFrameSize </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nWords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API sets the frame size if frame type is user/software defined frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI TX module. </td></tr>
    <tr><td class="paramname">nWords</td><td>[IN] number of data words in a software defined frame</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="gae5924bee852d63ef3e53cc4880b3c69b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5924bee852d63ef3e53cc4880b3c69b">&#9670;&nbsp;</a></span>FSI_startTxTransmit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_startTxTransmit </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API starts transmitting frames. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI TX module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="gadb26a6c5ab93ee1318e6fd540812967d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb26a6c5ab93ee1318e6fd540812967d">&#9670;&nbsp;</a></span>FSI_setTxFrameTag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_setTxFrameTag </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga030a9c366d574155294e1b62d24ccaa0">FSI_FrameTag</a>&#160;</td>
          <td class="paramname"><em>frameTag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API sets frame tag for transmission. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI TX module. </td></tr>
    <tr><td class="paramname">frameTag</td><td>[IN] refer <a class="el" href="group__DRV__FSI__TX__MODULE.html#ga030a9c366d574155294e1b62d24ccaa0" title="FSI frame tag values.">FSI_FrameTag</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="gabedc2a4c7cdf00ab0c159ab80b855d7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabedc2a4c7cdf00ab0c159ab80b855d7d">&#9670;&nbsp;</a></span>FSI_setTxUserDefinedData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_setTxUserDefinedData </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>userDefData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API sets user defined data for transmission It is an extra data field (8 bit) apart from regular data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI TX module. </td></tr>
    <tr><td class="paramname">userDefData</td><td>[IN] 8 bit user defined data value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="ga97cf4649cf062bc4e0e10275fbf8f137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97cf4649cf062bc4e0e10275fbf8f137">&#9670;&nbsp;</a></span>FSI_setTxBufferPtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_setTxBufferPtr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>bufPtrOff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API sets the value for transmit buffer pointer at desired location. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI TX module. </td></tr>
    <tr><td class="paramname">bufPtrOff</td><td>[IN] 4 bit offset pointer in TX buffer where transmitter will pick the data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="gaf4b11c5f2e917ba08cca780f2f92da39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4b11c5f2e917ba08cca780f2f92da39">&#9670;&nbsp;</a></span>FSI_getTxBufferPtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_getTxBufferPtr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>pBufPtrLoc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API gets current buffer pointer locationn. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI TX module. </td></tr>
    <tr><td class="paramname">pBufPtrLoc</td><td>[OUT] Pointer to current buffer pointer location</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="gab8c93ebce6161fb6608b73033e02fcd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8c93ebce6161fb6608b73033e02fcd1">&#9670;&nbsp;</a></span>FSI_getTxWordCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_getTxWordCount </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>pWordCnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API gets valid number of data words present in buffer which have not been transmitted yet. </p>
<p><br  />
 there could be lag due to synchronization hence value is accurate only when no current transmission is happening</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI TX module. </td></tr>
    <tr><td class="paramname">pWordCnt</td><td>[OUT] Pointer to number of data words</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="ga6f6edc21d0aab434488495e05bf4d3df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f6edc21d0aab434488495e05bf4d3df">&#9670;&nbsp;</a></span>FSI_enableTxPingTimer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_enableTxPingTimer </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>refValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga030a9c366d574155294e1b62d24ccaa0">FSI_FrameTag</a>&#160;</td>
          <td class="paramname"><em>pingFrameTag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enables ping timer logic and once set time elapses it sends signal to transmitter to send ping frame. </p>
<p><br  />
 there could be lag due to synchronization hence value is accurate only when no current transmission is happening</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI TX module. </td></tr>
    <tr><td class="paramname">refValue</td><td>[IN] 32 bit reference value for ping time-out counter </td></tr>
    <tr><td class="paramname">pingFrameTag</td><td>[IN] 4 bit tag value for ping time-out counter refer <a class="el" href="group__DRV__FSI__TX__MODULE.html#ga030a9c366d574155294e1b62d24ccaa0" title="FSI frame tag values.">FSI_FrameTag</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="ga5ed76cfd6620011dfd3bad79d99768f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ed76cfd6620011dfd3bad79d99768f6">&#9670;&nbsp;</a></span>FSI_setTxPingTag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_setTxPingTag </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga030a9c366d574155294e1b62d24ccaa0">FSI_FrameTag</a>&#160;</td>
          <td class="paramname"><em>frameTag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API sets the ping tag value, used by either timeout counter initiated PING frame transfer or by external ping trigger input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI TX module. </td></tr>
    <tr><td class="paramname">frameTag</td><td>[IN] 4 bit tag value for ping time-out counter refer <a class="el" href="group__DRV__FSI__TX__MODULE.html#ga030a9c366d574155294e1b62d24ccaa0" title="FSI frame tag values.">FSI_FrameTag</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="gaddee1947de071274e5161b2971a532ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaddee1947de071274e5161b2971a532ba">&#9670;&nbsp;</a></span>FSI_disableTxPingTimer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_disableTxPingTimer </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API disables ping timer logic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI TX module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="ga691ed23e40e69c99e309e0ff9f5826f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga691ed23e40e69c99e309e0ff9f5826f5">&#9670;&nbsp;</a></span>FSI_enableTxExtPingTrigger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_enableTxExtPingTrigger </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>extTrigSel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enables external trigger to transmit a ping frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI TX module. </td></tr>
    <tr><td class="paramname">extTrigSel</td><td>[IN] 5 bit value which selects among 32 external inputs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="gac50a09f403c5912ed6d32886dfadaa26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac50a09f403c5912ed6d32886dfadaa26">&#9670;&nbsp;</a></span>FSI_disableTxExtPingTrigger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_disableTxExtPingTrigger </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API disables external trigger logic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI TX module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="gac491ff826d915944ba1c4d5fa9a63f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac491ff826d915944ba1c4d5fa9a63f1e">&#9670;&nbsp;</a></span>FSI_getTxCurrentPingTimeoutCounter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_getTxCurrentPingTimeoutCounter </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pPingToCnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API gets current value of ping timeout logic counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI TX module. </td></tr>
    <tr><td class="paramname">pPingToCnt</td><td>[OUT] Pointer to current ping timeout counter</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="gac5a758b0723db13873023e8a85785643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5a758b0723db13873023e8a85785643">&#9670;&nbsp;</a></span>FSI_lockTxCtrl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_lockTxCtrl </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API locks the control of all transmit control registers, once locked further writes will not take effect until system reset occurs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI TX module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="ga8f6ec09a95d6736dbb5a752eb06d703d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f6ec09a95d6736dbb5a752eb06d703d">&#9670;&nbsp;</a></span>FSI_getTxEventStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_getTxEventStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>pEvtFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API gets current status of all the error flags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI TX module. </td></tr>
    <tr><td class="paramname">pEvtFlags</td><td>[OUT] Pointer to the status of error event flags, each bit of integer is associated with one error flag.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="gae43d1581f38dc885ef354ff62e9d4731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae43d1581f38dc885ef354ff62e9d4731">&#9670;&nbsp;</a></span>FSI_forceTxEvents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_forceTxEvents </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>evtFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enables user to set TX error flags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI TX module. </td></tr>
    <tr><td class="paramname">evtFlags</td><td>[IN] event and error flags to be set</td></tr>
  </table>
  </dd>
</dl>
<p><br  />
 Writing a 1 to this bit position will cause the corresponding bit in TX_EVT_ERR_STATUS register to get set. The purpose of this register is to allow software to simulate the effect of the event and test the associated software/ISR.</p>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="ga5155275350f9945116d7b8931164a3bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5155275350f9945116d7b8931164a3bb">&#9670;&nbsp;</a></span>FSI_clearTxEvents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_clearTxEvents </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>evtFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enables user to clear TX error flags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI TX module. </td></tr>
    <tr><td class="paramname">evtFlags</td><td>[IN] event and error flags to be cleared</td></tr>
  </table>
  </dd>
</dl>
<p><br  />
 Writing a 1 to this bit position will cause the corresponding bit in TX_EVT_ERR_STATUS register to get cleared to 0.</p>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="ga9c17770e26f066a5fef654a00b58051c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c17770e26f066a5fef654a00b58051c">&#9670;&nbsp;</a></span>FSI_enableTxUserCRC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_enableTxUserCRC </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>userCRCValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API sets the CRC value to be picked transmission if transmission is configured to use user defined SW CRC. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI TX module. </td></tr>
    <tr><td class="paramname">userCRCValue</td><td>[IN] user defined CRC value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="ga8a74106abfd5fcdcff7c72edf12329d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a74106abfd5fcdcff7c72edf12329d1">&#9670;&nbsp;</a></span>FSI_disableTxUserCRC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_disableTxUserCRC </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API disables user defined CRC value, the transmitted CRC value is computed by hardware. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI TX module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="gadd69ecca36f616f7f51f99a441620840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd69ecca36f616f7f51f99a441620840">&#9670;&nbsp;</a></span>FSI_setTxECCdata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_setTxECCdata </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API sets data for ECC logic computaion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI TX module. </td></tr>
    <tr><td class="paramname">data</td><td>[IN] data value for which ECC needs to be computed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="ga99a542d2a18f102a04d75a78ee8112a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99a542d2a18f102a04d75a78ee8112a8">&#9670;&nbsp;</a></span>FSI_getTxECCValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_getTxECCValue </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>pEccVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API gets ECC value evaluated for 16/32 bit data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI TX module. </td></tr>
    <tr><td class="paramname">pEccVal</td><td>[OUT] Pointer to the ECC value for input data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="gaf372007b7814f6e7d46c59b3464d2721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf372007b7814f6e7d46c59b3464d2721">&#9670;&nbsp;</a></span>FSI_enableTxInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_enableTxInterrupt </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fsi_2v0_2fsi_8h.html#ad3a8bd4711243054c29b3215a9f05b6c">FSI_InterruptNum</a>&#160;</td>
          <td class="paramname"><em>intNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>intFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enables user to generate interrupt on occurrence of FSI_TxEventList events. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI TX module. </td></tr>
    <tr><td class="paramname">intNum</td><td>[IN] Type of interrupt to be generated, INT1 or INT2 </td></tr>
    <tr><td class="paramname">intFlags</td><td>[IN] TX events on which interrupt should be generated</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="ga5c44d3bd84aaa5dc2f3f3d1d97f47fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c44d3bd84aaa5dc2f3f3d1d97f47fa8">&#9670;&nbsp;</a></span>FSI_disableTxInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_disableTxInterrupt </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fsi_2v0_2fsi_8h.html#ad3a8bd4711243054c29b3215a9f05b6c">FSI_InterruptNum</a>&#160;</td>
          <td class="paramname"><em>intNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>intFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enables user to disable generation interrupt on occurrence of FSI TX events. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI TX module. </td></tr>
    <tr><td class="paramname">intNum</td><td>[IN] Type of interrupt to be generated, INT1 or INT2 </td></tr>
    <tr><td class="paramname">intFlags</td><td>[IN] TX events on which interrupt generation has to be disabled</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="ga954b0c1bc5058f5c9aa607e0f447229f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga954b0c1bc5058f5c9aa607e0f447229f">&#9670;&nbsp;</a></span>FSI_getTxBufferAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_getTxBufferAddress </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pBufAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API gets address of TX data buffer. </p>
<p><br  />
 Data buffer is consisting of 16 words from offset- 0x40 to 0x4e</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI TX module. </td></tr>
    <tr><td class="paramname">pBufAddr</td><td>[OUT] Pointer to the TX data buffer address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="gaae125216cd59099d7f549ace92e03ef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae125216cd59099d7f549ace92e03ef5">&#9670;&nbsp;</a></span>FSI_resetTxModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_resetTxModule </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga4d13219ea4e4fefa02d221d87c807c0e">FSI_TxSubmoduleInReset</a>&#160;</td>
          <td class="paramname"><em>submodule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API resets clock or ping timeout counter or entire TX module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI TX module. </td></tr>
    <tr><td class="paramname">submodule</td><td>[IN] name of submodule which is supposed to be reset</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="ga3d2add9c6ceca89ae90f1006c952cca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d2add9c6ceca89ae90f1006c952cca8">&#9670;&nbsp;</a></span>FSI_clearTxModuleReset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_clearTxModuleReset </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DRV__FSI__TX__MODULE.html#ga4d13219ea4e4fefa02d221d87c807c0e">FSI_TxSubmoduleInReset</a>&#160;</td>
          <td class="paramname"><em>submodule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API clears reset on clock or ping timeout counter or entire TX module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI TX module. </td></tr>
    <tr><td class="paramname">submodule</td><td>[IN] name of submodule to be brought out of reset</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="gac812955d5f1add5c08039bcb1c1c5992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac812955d5f1add5c08039bcb1c1c5992">&#9670;&nbsp;</a></span>FSI_writeTxBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_writeTxBuffer </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>pArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>bufOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API writes data in FSI TX buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI TX module. </td></tr>
    <tr><td class="paramname">pArray</td><td>[IN] Address of the array of words to be transmitted. </td></tr>
    <tr><td class="paramname">length</td><td>[IN] Length is the number of words in the array to be transmitted. </td></tr>
    <tr><td class="paramname">bufOffset</td><td>[IN] Offset in TX buffer where data will be written, offset is a 16-bit aligned address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Data Overwrite protection is implemented in this function by ensuring not more than 16 words are written and also wrap around case is taken care when more words need to be written if last write happens at maximum offset in TX buffer</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="gafdb1da2b92a8f006b58c349fdfa03c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdb1da2b92a8f006b58c349fdfa03c28">&#9670;&nbsp;</a></span>FSI_performTxInitialization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_performTxInitialization </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>prescalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API initializes FSI TX module. </p>
<p><br  />
 Software based initialization of the FSI transmitter IP. This is typically needed only once during initialization or if the module needs to be reset due to an underrun condition that occurred during operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI TX module </td></tr>
    <tr><td class="paramname">prescalar</td><td>[IN] User configurable clock divider for PLL input clock</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
<a id="gadccd34d6543f6038c76d299b74ca432a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadccd34d6543f6038c76d299b74ca432a">&#9670;&nbsp;</a></span>FSI_executeTxFlushSequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FSI_executeTxFlushSequence </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>prescalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API sends Flush pattern sequence. </p>
<p><br  />
 Flush pattern sequence sent by a FSI transmit module will bring the FSI receive module out of reset so that it will then be ready to receive subsequent frames.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>[IN] Base address of the FSI TX module </td></tr>
    <tr><td class="paramname">prescalar</td><td>[IN] user configurable clock divider for PLL input clock</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS = success CSL_EBADARGS = Invalid base address parameter </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
