<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="shortcut icon" href="favicon.png" type="image/png">    
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<title>AM64x MCU+ SDK: Understanding the bootflow and bootloaders</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<style>
.tinav {
    background: #c00;
    /* height: 41.375px; */
    height: 30px;
    }
</style>    
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
  /* @license-end */
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="AM64x MCU+ SDK"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 40px;">
  <td id="projectlogo"><a href="https://www.ti.com"><img alt="Logo" src="ti_logo.svg"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AM64x MCU+ SDK
   &#160;<span id="projectnumber">10.00.00</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.html" method="get">
              <img id="MSearchSelect" src="search/mag.svg" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
</td>
 </tr>
 </tbody>
</table>
<div class=tinav></div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('BOOTFLOW_GUIDE.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Understanding the bootflow and bootloaders </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md155">Introduction</a><ul><li class="level2"><a href="#autotoc_md156">What Is Bootloader?</a></li>
<li class="level2"><a href="#autotoc_md157">Multi-Stage Bootloader</a></li>
<li class="level2"><a href="#autotoc_md158">Multi-Core Bootloading</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md159">Bootloading in MCU+SDK</a><ul><li class="level2"><a href="#autotoc_md160">ROM Boot</a><ul><li class="level3"><a href="#autotoc_md161">System Controller Firmware (SYSFW)</a></li>
<li class="level3"><a href="#autotoc_md162">Preparing the SBL for boot</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md163">SBL Boot</a><ul><li class="level3"><a href="#autotoc_md164">Preparing the application for boot</a></li>
<li class="level3"><a href="#autotoc_md165">Flashing the application for boot</a></li>
<li class="level3"><a href="#autotoc_md166">Booting the application</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md167">Secure Boot</a></li>
<li class="level1"><a href="#autotoc_md168">Deep Dive into SBLs</a><ul><li class="level2"><a href="#autotoc_md169">SBL NULL</a></li>
<li class="level2"><a href="#BOOTFLOW_SBL_SD">SBL SD</a></li>
<li class="level2"><a href="#autotoc_md170">SBL OSPI</a></li>
<li class="level2"><a href="#autotoc_md171">SBL OSPI MULTI-PARTITION</a></li>
<li class="level2"><a href="#autotoc_md172">SBL UART</a></li>
<li class="level2"><a href="#autotoc_md173">SBL PCIE</a></li>
<li class="level2"><a href="#autotoc_md174">SBL EMMC</a></li>
<li class="level2"><a href="#autotoc_md175">SBL OSPI LINUX</a></li>
<li class="level2"><a href="#autotoc_md176">SBL EMMC LINUX</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md177">Additional References</a></li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="md_developer_guides_bootflow"></a></p>
<h1><a class="anchor" id="autotoc_md155"></a>
Introduction</h1>
<p>This section is aimed at explaining what a bootloader is, why is it needed and details regarding the bootloader and bootflow used in the MCU+SDK.</p>
<h2><a class="anchor" id="autotoc_md156"></a>
What Is Bootloader?</h2>
<p>Generally speaking, bootloader is a piece of software / firmware that runs as soon as you power on an SoC. A bootloader's main duty is to start the subsequent pieces of software, such an OS, a baremetal application or in some cases another bootloader. When it comes to embedded, the bootloader is usually closely tied with the underlying SoC architecture. The bootloader is usually stored in a protected, non-volatile on-chip memory. Typically the bootloader performs various hardware checks, initializes the processor and configures the SoC registers etc. Since the primary aim of the bootloader is to load the next piece of software, it needs to communicate to the external world to receive this firmware/application image. This can be over a number of protocols - USB, UART, SPI, I2C, External Flash, Internal Flash, SD Card, Ethernet, CAN etc. Bootloader is also a key component in embedded security. Hardware Root-of-Trust is usually passed onto the bootloader and is passed on down the line.</p>
<dl class="section note"><dt>Note</dt><dd>In devices supported by MCU+SDK, the first stage bootloader is burned into read-only memory of the device and is considered as device firmware / ROM. Mostly in MCU+SDK when we say "bootloader" we are referring to the secondary bootloader, or the SBL</dd></dl>
<h2><a class="anchor" id="autotoc_md157"></a>
Multi-Stage Bootloader</h2>
<p>As mentioned earlier, sometimes the bootloader would be loading another bootloader which can load another one and so on. This is usually the case in advanced SoCs, and there are various reasons for this. The first bootloader is usually kept on secure, read-only memory for security reasons and to have a known state always before application software starts. It makes sense then to keep this bootloader simple and let it do only the bare minimum configuration required. This secondary bootloader can be complex and configurable to suit the needs of the application. This can also be updated easily compared to the first stage bootloader. In fact for the devices in MCU+SDK, we have a two-stage bootloading - the first stage bootloader is called ROM Bootloader (RBL) and the second stage bootloader is called Secondary Bootloader (SBL).</p>
<h2><a class="anchor" id="autotoc_md158"></a>
Multi-Core Bootloading</h2>
<p>Multi-core bootloading is almost always a follow up when there is a multi-stage bootloading. In this case the first bootloader technically might not be even aware of the other cores, it will just boot the next stage bootloader and this second stage bootloader will take care of the complex bootloading on the different cores.</p>
<p>Loading a multi-core application is slightly more complicated than loading a single core application. There would be concerns regarding image preparation, shared memory access, and so on. Mostly there would be a particular format in which the individual core images are created, and then they may/may not be concatenated into a single image for SBL to load. Whatever format the application image is in, the SBL should be aware of it so that it can parse and load the image correctly.</p>
<h1><a class="anchor" id="autotoc_md159"></a>
Bootloading in MCU+SDK</h1>
<p>In the MCU+SDK, the bootflow takes place mainly in two steps after you power ON the device</p><ul>
<li><b>ROM boot</b>, in which the ROM bootloader boots a secondary bootloader or an SBL</li>
<li><b>SBL boot</b> in which the secondary bootloader boots the application</li>
</ul>
<h2><a class="anchor" id="autotoc_md160"></a>
ROM Boot</h2>
<p>The <b>RBL</b> or ROM Bootloader is stored in read-only memory and is almost considered as part of the SoC. The details regarding the RBL and ROM Boot is out of scope for this user guide. Please refer to the Technical Reference Manual of the device for more details. But basically the ROM expects an x509 signed binary image of the secondary bootloader to be provided for boot.</p>
<ul>
<li>As soon as the board is powered ON, the ROM bootloader or RBL starts running. The RBL is the primary bootloader.</li>
<li>Depending on which boot mode is selected, the RBL will load the <b>secondary bootloader</b> or SBL from a boot media (OSPI flash, SD card or via UART).</li>
<li>Rest of the booting is done by the SBL.</li>
<li>The RBL expects the image it boots (SBL in our case) to always be signed as mentioned above. Refer <a class="el" href="TOOLS_BOOT.html">Booting Tools</a> for more information on signing scripts.</li>
</ul>
<p>The x509 template for ROM looks something like this:</p>
<div class="fragment"><div class="line">[ req ]</div>
<div class="line">distinguished_name     = req_distinguished_name</div>
<div class="line">x509_extensions        = v3_ca</div>
<div class="line">prompt                 = no</div>
<div class="line"> </div>
<div class="line">dirstring_type = nobmp</div>
<div class="line"> </div>
<div class="line">[ req_distinguished_name ]</div>
<div class="line">C                      = US</div>
<div class="line">ST                     = SC</div>
<div class="line">L                      = New York</div>
<div class="line">O                      = Texas Instruments., Inc.</div>
<div class="line">OU                     = DSP</div>
<div class="line">CN                     = Albert</div>
<div class="line">emailAddress           = Albert@gt.ti.com</div>
<div class="line"> </div>
<div class="line">[ v3_ca ]</div>
<div class="line">basicConstraints = CA:true</div>
<div class="line">1.3.6.1.4.1.294.1.3 = ASN1:SEQUENCE:swrv</div>
<div class="line">1.3.6.1.4.1.294.1.9 = ASN1:SEQUENCE:ext_boot_info</div>
<div class="line"> </div>
<div class="line">[ swrv ]</div>
<div class="line">swrv = INTEGER:1</div>
<div class="line"> </div>
<div class="line">[ ext_boot_info ]</div>
<div class="line">extImgSize = INTEGER:0</div>
<div class="line">numComp = INTEGER:3</div>
<div class="line">sbl = SEQUENCE:sbl</div>
<div class="line">fw = SEQUENCE:sysfw</div>
<div class="line">bd2 = SEQUENCE:boardcfg</div>
<div class="line"> </div>
<div class="line">[ sbl ]</div>
<div class="line"> </div>
<div class="line">compType = INTEGER:1</div>
<div class="line">bootCore = INTEGER:16</div>
<div class="line">compOpts = INTEGER:0</div>
<div class="line">destAddr = FORMAT:HEX,OCT:0000</div>
<div class="line">compSize = INTEGER:0</div>
<div class="line">shaType = OID:SHAOID</div>
<div class="line">shaValue = FORMAT:HEX,OCT:0000</div>
<div class="line"> </div>
<div class="line">[ sysfw ]</div>
<div class="line"> </div>
<div class="line">compType = INTEGER:2</div>
<div class="line">bootCore = INTEGER:0</div>
<div class="line">compOpts = INTEGER:0</div>
<div class="line">destAddr = FORMAT:HEX,OCT:0000</div>
<div class="line">compSize = INTEGER:0000</div>
<div class="line">shaType = OID:SHAOID</div>
<div class="line">shaValue = FORMAT:HEX,OCT:0000</div>
<div class="line"> </div>
<div class="line">{SYSFW_INNER_CERT_SEQ}</div>
<div class="line"> </div>
<div class="line">[ boardcfg ]</div>
<div class="line"> </div>
<div class="line">compType = INTEGER:18</div>
<div class="line">bootCore = INTEGER:0</div>
<div class="line">compOpts = INTEGER:0</div>
<div class="line">destAddr = FORMAT:HEX,OCT:0000</div>
<div class="line">compSize = INTEGER:0000</div>
<div class="line">shaType = OID:SHAOID</div>
<div class="line">shaValue = FORMAT:HEX,OCT:0000</div>
</div><!-- fragment --><p>Depending on the device type, these are the validation requirements for ROM:</p>
<p> <style>div.image img[src="device_types_validation_req.png"]{width:50%}</style> </p><div class="image">
<img src="device_types_validation_req.png" alt=""/>
<div class="caption">
Validation for Device Types</div></div>
<h3><a class="anchor" id="autotoc_md161"></a>
System Controller Firmware (SYSFW)</h3>
<ul>
<li>In case of AM64X, there is one more component called the System Controller Firmware (SYSFW) which is important in the booting process and SoC operation. As the name suggests it is controller firmware which runs in the Cortex M3 core and acts as a centralized server for the SoC which grants services in<ul>
<li>Resource Management (RM)</li>
<li>Power Management (PM)</li>
<li>Security</li>
</ul>
</li>
<li>Since the services provided by SYSFW are fundamental, it needs to be loaded before the secondary bootloader can do pretty much anything.</li>
<li>In MCU+SDK we follow what's called the combined bootflow (for more details on combined bootflow refer <a class="el" href="BOOTFLOW_MIGRATION_GUIDE.html">Bootflow Migration Guide</a>), where RBL boots the SBL and the SYSFW. For this we have to prepare the boot image for RBL specially. It will be a concatenation of the SBL binary, SYSFW binary and Board Configuration binary all signed with a single x509 certificate. This process is taken care in SBL makefiles, so in most cases the user need not worry about it. For details regarding the signing script used for this please refer <a class="el" href="TOOLS_BOOT.html">Booting Tools</a></li>
<li>One of the first things SBL is going to do is wait for a boot notification from SYSFW.</li>
<li>There are different types of SYSFW images included in the SDK. You can find below binary files under <code>source/drivers/sciclient/soc/${soc}</code>:<ul>
<li><code>sysfw-hs-fs-enc.bin</code>: This is the encrypted and signed SYSFW binary to be packaged with SBL when preparing the SBL boot image for <b>HS-FS</b> device.</li>
<li><code>sysfw-hs-fs-enc-cert.bin</code>: This is the x509 certificate binary generated while signing the above (<code>sysfw-hs-fs-enc.bin</code>) image. This is also to be packaged with SBL when preparing the SBL boot image for <b>HS-FS</b> device.</li>
<li><code>sysfw-hs-enc.bin</code>: This is the encrypted and signed SYSFW binary to be packaged with SBL when preparing the SBL boot image for <b>HS-SE</b> device.</li>
<li><code>sysfw-hs-enc-cert.bin</code>: This is the x509 certificate binary generated while signing the above (<code>sysfw-hs-enc.bin</code>) image. This is also to be packaged with SBL when preparing the SBL boot image for <b>HS-SE</b> device.</li>
</ul>
</li>
<li>For more information regarding the SYSFW please refer to the TISCI Documentation : <a href="https://software-dl.ti.com/tisci/esd/latest/index.html">https://software-dl.ti.com/tisci/esd/latest/index.html</a></li>
<li>For ROM to accept any image to boot, there are some restrictions in the image preparation</li>
</ul>
<h3><a class="anchor" id="autotoc_md162"></a>
Preparing the SBL for boot</h3>
<p>The SBL is like any other application, created using the same compiler and linker toolchain. It is an example implementation rather than a deliverable. It is customizable by users, but must adhere to the requirements by RBL which is a constant as mentioned above. However the steps to convert the application <code>.out</code> into a bootable image are different for SBL as listed below:</p>
<ul>
<li>Other special factors for SBL application are listed below<ul>
<li>After entering <code>main()</code>, make sure to call <code>Bootloader_socWaitForFWBoot</code> to wait for the boot notification from the SYSFW</li>
<li>The linker command file for SBL has to place vectors at address <code>0x70000000</code> and this is the entry point for the SBL.</li>
<li>Nothing should be placed in ATCM or BTCM</li>
<li>Only the region <code>0x70000000</code> to <code>0x70080000</code> should be used by SBL code, data, stack etc</li>
</ul>
</li>
<li>After building, the SBL application <code>.out</code> file is first converted to a binary format <code>.bin</code> using the TI ARM CLANG <code>objcopy</code> tool.<ul>
<li>This copies the loadable sections from the .out into a binary image stripping all symbol and section information.</li>
<li>If there are two loadable sections in the image which are not contiguous then <code>objcopy</code> fills the gaps with <code>0x00</code>.</li>
<li>It is highly recommended to keep all loadable sections together within a SBL application.</li>
</ul>
</li>
<li>This <code>.bin</code> file is then signed using the <a class="el" href="TOOLS_BOOT.html#TOOLS_BOOT_SIGNING">Signing Scripts</a> to create the final <code>.tiimage</code> bootable image.<ul>
<li>The <code>.tiimage</code> file extension is kept to separate the SBL boot image from a normal application image</li>
<li>The rom_degenerateKey.pem is used for this.</li>
<li>This is a ROM bootloader requirement and is needed even on a non-secure device.</li>
<li>The signing tools take the <code>.bin</code> file</li>
</ul>
</li>
<li>Depending on the device type for which we build the SBL, there will be certain prefixes to the <code>.tiimage</code> extension like so:<ul>
<li><b>GP</b> device:<ul>
<li><code>sbl_xxx.release.tiimage</code> [No prefix before <code>.tiimage</code>, plain image]</li>
</ul>
</li>
<li><b>HS-FS</b> device:<ul>
<li><code>sbl_xxx.release.hs_fs.tiimage</code> [<code>hs_fs</code> prefix before <code>.tiimage</code>]</li>
</ul>
</li>
<li><b>HS-SE</b> device:<ul>
<li><code>sbl_xxx.release.hs.tiimage</code> [<code>hs</code> prefix before <code>.tiimage</code>]</li>
</ul>
</li>
</ul>
</li>
<li>Note that if we just mentioned <code>hs</code> it is meant for <b>HS-SE</b> device and <code>hs_fs</code> or <code>hs-fs</code> is meant for <b>HS-FS</b> device.</li>
<li>The <code>.tiimage</code> file can then be flashed or copied to a boot image using the <a class="el" href="TOOLS_FLASH.html">Flashing Tools</a></li>
<li>In case of AM243x/AM64x we use combined boot flow, so the tiimage will have SYSFW and BoardCfg as additional components as ROM is going to boot these as well. As you can see from the image the signing is done for a concatenated binary of all three. For more details on combined boot flow please refer to <a class="el" href="BOOTFLOW_MIGRATION_GUIDE.html">Bootflow Migration Guide</a></li>
</ul>
<p> <style>div.image img[src="tiimage_k3.png"]{width:20%}</style> </p><div class="image">
<img src="tiimage_k3.png" alt=""/>
<div class="caption">
TIIMAGE</div></div>
<h2><a class="anchor" id="autotoc_md163"></a>
SBL Boot</h2>
<ul>
<li>An SBL typically does a bunch of SOC specific initializations and proceeds to the application loading.</li>
<li>Depending on the type of SBL loaded, SBL looks for the <b>multicore appimage</b> (refer <a class="el" href="TOOLS_BOOT.html">Booting Tools</a> for more on multicore appimage) of the application binary at a specified location in a boot media.</li>
<li>If the appimage is found, the multicore appimage is parsed into multiple <b>RPRCs</b>. These are optimized binaries which are then loaded into individual CPUs.</li>
<li>Each RPRC image will have information regarding the core on which it is to be loaded, entry points and multiple sections of that application binary</li>
<li>The SBL uses this information to initialize each core which has a valid RPRC. It then loads the RPRC according to the sections specified, sets the entry points and releases the core from reset. Now the core will start running.</li>
</ul>
<p> <video autoplay playinline muted controls width=50% style="display:block; margin: 0 auto;"> <source src="sbl_boot.mp4" type="video/mp4"> </video> <p style="text-align: center;"><strong>SBL BOOT</strong></p> </p>
<ul>
<li>To understand the steps to use XIP, see <a class="el" href="BOOTFLOW_XIP.html">Enabling XIP or eXecute In Place</a></li>
<li>Now, as mentioned above, to boot an application with SBL it has to be specially prepared after it's compiled.</li>
</ul>
<h3><a class="anchor" id="autotoc_md164"></a>
Preparing the application for boot</h3>
<dl class="section note"><dt>Note</dt><dd>To see the exact sequence of steps in which applications and secondary bootloader (SBL) are converted from compiler generated .out files to boot images, see the makefile <code>makefile_ccs_bootimage_gen</code> that is included in every example and secondary bootloader (SBL) CCS project.</dd>
<dd>
If you are using makefile based build, then see the file named <code>makefile</code> in the example folder.</dd></dl>
<p>Shown below are the different steps that are done to convert the compiler+linker generated application <code>.out</code> into a format suitable for flashing and booting</p>
<ul>
<li>For each CPU, the compiler+linker toolchain is used to create the application .out "ELF" file which can be loaded and run via CCS</li>
<li>The below "post build" steps are then used to convert the application .out into a "flash" friendly format<ul>
<li>For each CPU, <code>out2rpc</code> is used to convert the ELF .out to a binary file containing only the loadable sections. This is called a RPRC file.</li>
<li>For each CPU, <code>xipGen</code> is used to split this RPRC file into two RPRC files.<ul>
<li>One RPRC, containing the section that during boot need to be loaded to RAM</li>
<li>Second RPRC, containing the section that during boot are not loaded to RAM but are instead "eXecuted In Place", i.e XIP</li>
</ul>
</li>
<li><code>multiCoreGen</code> is then used to combine all the non-XIP RPRC files per CPU into a single <code>.appimage</code> file which is a concatenation of the individual CPU specific RPRC files.</li>
<li><code>multiCoreGen</code> is used again to combine all the XIP RPRC files per CPU into a single <code>.appimage_xip</code> file which is a concatenation of the individual CPU specific RPRC XIP files.</li>
</ul>
</li>
<li>This <code>.appimage</code> and <code>.appimage_xip</code> is then flashed to the board</li>
</ul>
<p> <style>div.image img[src="bootflow_post_build_steps.png"]{width:50%}</style> </p><div class="image">
<img src="bootflow_post_build_steps.png" alt=""/>
<div class="caption">
Post build steps</div></div>
<h3><a class="anchor" id="autotoc_md165"></a>
Flashing the application for boot</h3>
<ul>
<li>Once the application images (<code>.appimage</code> and <code>.appimage_xip</code>) are created one needs to copy or flash these to a supported boot media so that the application can start executing once the SOC is powered ON</li>
<li>When flashing the application we also need to flash a bootloader or SBL image.</li>
<li>See <a class="el" href="TOOLS_FLASH.html">Flashing Tools</a> for detailed steps that are done to flash a user application</li>
</ul>
<h3><a class="anchor" id="autotoc_md166"></a>
Booting the application</h3>
<p>After a SBL and application image is flashed, shown below is the high level boot flow, after the SOC is powered on.</p>
<p> <style>div.image img[src="bootflow_main.png"]{width:40%}</style> </p><div class="image">
<img src="bootflow_main.png" alt=""/>
<div class="caption">
HIGH LEVEL BOOTFLOW</div></div>
<h1><a class="anchor" id="autotoc_md167"></a>
Secure Boot</h1>
<p>In secure device variants, there are slight differences in the bootflow. For details on secure boot, please refer <a class="el" href="SECURE_BOOT.html">Enabling Secure Boot</a></p>
<h1><a class="anchor" id="autotoc_md168"></a>
Deep Dive into SBLs</h1>
<p>The SBL is like any other example of the SDK. They use the bootloader library APIs to carry out the bootloading process. Depending on the boot media from which we load the application binary, we have multiple SBLs like <code>sbl_ospi</code>,<code>sbl_uart</code> etc. A bare minimum SBL called the <code>sbl_null</code> is also included which aids the users to load their applications via CCS. Here are some details regarding those.</p>
<h2><a class="anchor" id="autotoc_md169"></a>
SBL NULL</h2>
<ul>
<li>The <code>sbl_null</code> is a secondary bootloader which doesn't load any application binary, but just does the SOC initialization and puts all the cores in WFI (Wait For Interrupt) mode.</li>
<li>This is supposed to be a "development form" bootloader which should be used only during initial development.</li>
<li>The other method is using NO-BOOT/DEV-BOOT boot modes of the devices and using GEL scripts to initialize the SoC via debugger. The application binaries can then be side-loaded. ROM is not involved in this case. The <code>sbl_null</code> is an alternative to this process.</li>
<li>In HS-SE devices, the debugger is usually closed. So using the <code>sbl_null</code> is the only option to initialize the device in this case.</li>
<li>This is referred to as the SOC initialization binary, refer <a class="el" href="EVM_SETUP_PAGE.html#EVM_FLASH_SOC_INIT">Flash SOC Initialization Binary</a> for more on this.</li>
</ul>
<h2><a class="anchor" id="BOOTFLOW_SBL_SD"></a>
SBL SD</h2>
<ul>
<li>The <code>sbl_sd</code> is a secondary bootloader which reads the application image file from the SD card and then moves on to core initialization and other steps</li>
<li>To boot an application using the <code>sbl_sd</code>, the application image needs to be copied to the SD card as a file named "app". Make sure that the SD card is formatted to have a FAT partition. To know more about the SD card partitioning please refer <a class="el" href="EVM_SETUP_PAGE.html#EVM_SOC_INIT_SD_BOOT_MODE">SOC Initialization Using SD BOOT</a></li>
<li>Follow the steps in the above referred page to partition the SD card. For a complete boot from SD card, both the <code>sbl_sd</code> binary and the application image binary has to be present as files in the SD card. You have to rename the <code>sbl_sd</code> appimage as 'tiboot3.bin'. <pre class="fragment">  copy file to SD card =&gt; ${SDK_INSTALL_PATH}/tools/boot/sbl_prebuilt/am64x-evm/sbl_sd.release.hs_fs.tiimage
  rename in SD card as =&gt; tiboot3.bin
</pre></li>
<li>Similarly you can copy any appimage file to the SD card and rename in the SD card as "app" so that the SBL can pick it up.</li>
<li>Currently the <code>sbl_sd</code> reads the full appimage file into an MSRAM buffer and then parses the multicore appimage. Because of this reason <b>appimages higher than ~380 KB in size can't be booted by <code>sbl_sd</code> as of now</b>.</li>
</ul>
<h2><a class="anchor" id="autotoc_md170"></a>
SBL OSPI</h2>
<ul>
<li>The <code>sbl_ospi</code> is a secondary bootloader which reads and parses the application image from a location in the OSPI flash and then moves on to core initialization and other steps</li>
<li>To boot an application using the <code>sbl_ospi</code>, the application image needs to be flashed at a particular location in the OSPI flash memory.</li>
<li>This location or offset is specified in the SysConfig of the <code>sbl_ospi</code> application. Currently this is 0x80000. This offset is chosen under the assumption that the <code>sbl_ospi</code> application takes at max 512 KB from the start of the flash. If a custom bootloader is used, make sure that this offset is chosen in such a way that it is greater than the size of the bootloader which is being flashed and also aligns with the block size of the flash.</li>
<li>To flash an application (or any file in fact) to a location in the OSPI flash memory, follow the steps mentioned in <a class="el" href="TOOLS_FLASH.html#BASIC_STEPS_TO_FLASH_FILES">Basic steps to flash files</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md171"></a>
SBL OSPI MULTI-PARTITION</h2>
<ul>
<li>The <code>sbl_ospi_multipartition</code> is a secondary bootloader which reads and parses core-specific application images for a system project from pre-defined locations in the OSPI flash and then moves on to core initialization and other steps</li>
<li>To boot an application using the <code>sbl_ospi_multipartition</code>, the application images needs to be flashed at specific locations in the OSPI flash memory. The default offsets are 512 KB apart.</li>
<li>This locations or offsets are specified in the SysConfig of the <code>sbl_ospi_multipartition</code> application.</li>
<li>For more information please refer to the example documentation of <code>sbl_ospi_multipartition</code> here: <a class="el" href="EXAMPLES_DRIVERS_SBL_OSPI_MULTI_PARTITION.html">SBL OSPI Multi-Partition</a></li>
<li>To flash an application (or any file in fact) to a location in the OSPI flash memory, follow the steps mentioned in <a class="el" href="TOOLS_FLASH.html#BASIC_STEPS_TO_FLASH_FILES">Basic steps to flash files</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md172"></a>
SBL UART</h2>
<ul>
<li>The <code>sbl_uart</code> is a secondary bootloader which receives the multicore appimage via UART, stores it in memory and then does the parsing, core initialization etc.</li>
<li>To boot an application using the <code>sbl_uart</code>, you can refer to <a class="el" href="TOOLS_BOOT.html#UART_BOOTLOADER_PYTHON_SCRIPT">UART Bootloader Python Script</a> subsection. Detailed steps on the usage is mentioned in the same subsection.</li>
</ul>
<h2><a class="anchor" id="autotoc_md173"></a>
SBL PCIE</h2>
<ul>
<li>The <code>sbl pcie</code> is a secondary bootloader which receives the multicore appimage via PCIe to memory and then does the parsing, core initialization etc.</li>
<li>The bootloader and appimage for <code>sbl pcie</code> is send over to the target board from a host board running <a class="el" href="EXAMPLES_DRIVERS_SBL_PCIE_HOST.html">SBL PCIE HOST</a>.</li>
<li>For detailed steps on running <code>sbl pcie</code>, you can refer to <a class="el" href="EXAMPLES_DRIVERS_SBL_PCIE.html">SBL PCIE</a>.</li>
</ul>
<h2><a class="anchor" id="autotoc_md174"></a>
SBL EMMC</h2>
<ul>
<li>The <code>sbl_emmc</code> is a secondary bootloader which reads and parses the application image from a location in the eMMC and then moves on to core initialization and other steps.</li>
<li>To boot an application using the <code>sbl_emmc</code>, the application image needs to be flashed at a particular location in the eMMC.</li>
<li>This location or offset is specified in the SysConfig of the <code>sbl_emmc</code> application. Currently this is 0x800000.</li>
<li>To flash an application (or any file in fact) to a location in the eMMC, follow the steps mentioned in <a class="el" href="TOOLS_FLASH.html#BASIC_STEPS_TO_FLASH_FILES">Basic steps to flash files</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md175"></a>
SBL OSPI LINUX</h2>
<ul>
<li>The <code>sbl_ospi_linux</code> is a secondary bootloader which boots Linux on A53 core and RTOS/NORTOS application on R5, M4 cores.</li>
<li>To boot Linux and RTOS/NORTOS applications using <code>sbl_ospi_linux</code>, the Linux appimage (see <a class="el" href="TOOLS_BOOT.html#LINUX_APPIMAGE_GEN_TOOL">Linux Appimage Generator Tool</a>) and the RTOS/NORTOS application images needs to be flashed at a particular location in the OSPI flash memory.</li>
<li>This location or offset is specified in the SysConfig of the <code>sbl_ospi_linux</code> application. Currently this is 0x80000 for RTOS/NORTOS images and 0x300000 for Linux application image.</li>
<li>To flash an application (or any file in fact) to a location in the OSPI flash memory, follow the steps mentioned in <a class="el" href="TOOLS_FLASH.html#BASIC_STEPS_TO_FLASH_FILES">Basic steps to flash files</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md176"></a>
SBL EMMC LINUX</h2>
<ul>
<li>The <code>sbl_emmc_linux</code> is a secondary bootloader which boots Linux on A53 core and RTOS/NORTOS application on R5, M4 cores from eMMC.</li>
<li>To boot Linux and RTOS/NORTOS applications using <code>sbl_emmc_linux</code>, the Linux appimage (see <a class="el" href="TOOLS_BOOT.html#LINUX_APPIMAGE_GEN_TOOL">Linux Appimage Generator Tool</a>) and the RTOS/NORTOS application images needs to be flashed at a particular location in the eMMC.</li>
<li>This location or offset is specified in the SysConfig of the <code>sbl_emmc_linux</code> application. Currently this is 0x800000 for RTOS/NORTOS images and 0xA00000 for Linux application image. In most cases you wouldn't need to change this.</li>
<li>To flash an application (or any file in fact) to a location in the eMMC, follow the steps mentioned in <a class="el" href="TOOLS_FLASH.html#BASIC_STEPS_TO_FLASH_FILES">Basic steps to flash files</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md177"></a>
Additional References</h1>
<p>See also these additional pages for more details and examples about the boot flow,</p>
<ul>
<li>To understand different secondary bootloader (SBL) examples see,<ul>
<li><a class="el" href="EXAMPLES_DRIVERS_SBL_NULL.html">SBL NULL</a></li>
<li><a class="el" href="EXAMPLES_DRIVERS_SBL_UART_UNIFLASH.html">SBL UART Flash Writer</a></li>
<li><a class="el" href="EXAMPLES_DRIVERS_SBL_SD.html">SBL SD</a></li>
<li><a class="el" href="EXAMPLES_DRIVERS_SBL_OSPI.html">SBL OSPI</a></li>
<li><a class="el" href="EXAMPLES_DRIVERS_SBL_UART.html">SBL UART</a></li>
<li><a class="el" href="EXAMPLES_DRIVERS_SBL_OSPI_MULTI_PARTITION.html">SBL OSPI Multi-Partition</a></li>
<li><a class="el" href="EXAMPLES_DRIVERS_SBL_DFU_UNIFLASH.html">SBL DFU Uniflash</a></li>
<li><a class="el" href="EXAMPLES_DRIVERS_SBL_PCIE.html">SBL PCIE</a></li>
<li><a class="el" href="EXAMPLES_DRIVERS_SBL_OSPI_LINUX.html">SBL OSPI Linux</a></li>
<li><a class="el" href="EXAMPLES_DRIVERS_SBL_EMMC_LINUX.html">SBL EMMC Linux</a></li>
</ul>
</li>
<li>To understand the flashing steps, see <a class="el" href="TOOLS_FLASH.html">Flashing Tools</a></li>
<li>To understand the boot image creation tools, see <a class="el" href="TOOLS_BOOT.html">Booting Tools</a></li>
<li>To understand the details on SBL Booting linux from OSPI, see <a class="el" href="SBL_BOOTING_LINUX_OSPI.html">SBL Booting Linux From OSPI</a></li>
<li>To understand the details on SBL Booting linux from eMMC, see <a class="el" href="SBL_BOOTING_LINUX_EMMC.html">SBL Booting Linux From eMMC</a> </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
