<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="shortcut icon" href="favicon.png" type="image/png">    
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<title>AM64x MCU+ SDK: PCIE EP Enumeration</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<style>
.tinav {
    background: #c00;
    /* height: 41.375px; */
    height: 30px;
    }
</style>    
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
  /* @license-end */
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="AM64x MCU+ SDK"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 40px;">
  <td id="projectlogo"><a href="https://www.ti.com"><img alt="Logo" src="ti_logo.svg"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AM64x MCU+ SDK
   &#160;<span id="projectnumber">10.00.00</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.html" method="get">
              <img id="MSearchSelect" src="search/mag.svg" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
</td>
 </tr>
 </tbody>
</table>
<div class=tinav></div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('EXAMPLES_DRIVERS_PCIE_ENUMERATE_EP.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">PCIE EP Enumeration </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md657">Introduction</a></li>
<li class="level1"><a href="#autotoc_md658">Supported Combinations</a></li>
<li class="level1"><a href="#autotoc_md659">Steps to Run the Example</a><ul><li class="level2"><a href="#autotoc_md660">Build the example</a></li>
<li class="level2"><a href="#autotoc_md661">HW Setup</a><ul><li class="level3"><a href="#autotoc_md662">AM64X-EVM</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md663">RC Setup</a><ul><li class="level3"><a href="#autotoc_md664">Windows</a></li>
<li class="level3"><a href="#autotoc_md665">Linux</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md666">Run the example</a><ul><li class="level3"><a href="#autotoc_md667">Windows</a><ul><li class="level4"><a href="#autotoc_md668">Building for Windows</a></li>
<li class="level4"><a href="#autotoc_md669">Deploying on Windows</a></li>
<li class="level4"><a href="#autotoc_md670">Usage on Windows</a></li>
</ul>
</li>
<li class="level3"><a href="#autotoc_md671">Linux</a><ul><li class="level4"><a href="#autotoc_md672">Building for Linux</a></li>
<li class="level4"><a href="#autotoc_md673">Deploying on Linux</a></li>
<li class="level4"><a href="#autotoc_md674">Usage on Linux</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md675">Important concepts in the example</a><ul><li class="level2"><a href="#autotoc_md676">x86 RC requirements</a><ul><li class="level3"><a href="#autotoc_md677">Startup requirements, reset behavior</a></li>
<li class="level3"><a href="#autotoc_md678">Reference clock</a><ul><li class="level4"><a href="#autotoc_md679">External reference clock implications</a></li>
</ul>
</li>
<li class="level3"><a href="#autotoc_md680">EP-&gt;RC and RC-&gt;EP interrupt signaling</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md681">Software concepts</a><ul><li class="level3"><a href="#autotoc_md682">Driver startup</a></li>
<li class="level3"><a href="#autotoc_md683">Memory map</a><ul><li class="level4"><a href="#autotoc_md684">Local memories</a></li>
<li class="level4"><a href="#autotoc_md685">DMA memory / outbound mappings</a></li>
</ul>
</li>
<li class="level3"><a href="#autotoc_md686">Driver runtime operation</a><ul><li class="level4"><a href="#autotoc_md687">Pcie_onLinkDetect</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md688">Background information</a><ul><li class="level2"><a href="#autotoc_md689">PCIe reference clock</a></li>
<li class="level2"><a href="#autotoc_md690">IOMMU background</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md691">Example Output</a><ul><li class="level2"><a href="#autotoc_md692">Linux</a></li>
<li class="level2"><a href="#autotoc_md693">Windows</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md694">See Also</a></li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="md_examples_drivers_pcie_enumerate_ep"></a></p>
<h1><a class="anchor" id="autotoc_md657"></a>
Introduction</h1>
<p>The PCIe Enumeration (EP) example demonstrates an EP that supports enumeration through an RC that is running Windows or Linux.</p>
<p>The EP waits for enumeration and configuration through the RC. It offers a BAR0 memory region with a control and status register interface through which three tests can be executed:</p><ul>
<li>RC fills a data buffer in the EP's BAR0 memory region and configures the address of a DMA buffer. The EP copies the data from the BAR0 data buffer back to the RC's DMA buffer.</li>
<li>EP triggers each configured message signaled interrupt in the RC in ascending order.</li>
<li>RC fills data buffers in the EP's BAR1 and BAR2 memory regions with a known pattern. The EP verifies the content of its BAR1 and BAR2 memory regions and in case of successful verification it sends an MSI back to the RC.</li>
</ul>
<h1><a class="anchor" id="autotoc_md658"></a>
Supported Combinations</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Parameter  </th><th class="markdownTableHeadNone">Value   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">CPU + OS  </td><td class="markdownTableBodyNone">r5fss0-0_freertos   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Toolchain  </td><td class="markdownTableBodyNone">ti-arm-clang   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Board  </td><td class="markdownTableBodyNone">am64x-evm   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Example folder  </td><td class="markdownTableBodyNone">examples/drivers/pcie/pcie_enumerate/pcie_enumerate_ep   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md659"></a>
Steps to Run the Example</h1>
<h2><a class="anchor" id="autotoc_md660"></a>
Build the example</h2>
<ul>
<li>When using CCS projects to build, import the CCS project for the required combination and build it using the CCS project menu (see <a class="el" href="CCS_PROJECTS_PAGE.html">Using SDK with CCS Projects</a>).</li>
<li>When using makefiles to build, note the required combination and build using make command (see <a class="el" href="MAKEFILE_BUILD_PAGE.html">Using SDK with Makefiles</a>)</li>
</ul>
<h2><a class="anchor" id="autotoc_md661"></a>
HW Setup</h2>
<dl class="section note"><dt>Note</dt><dd>Make sure you have setup the EVM with cable connections as shown here, <a class="el" href="EVM_SETUP_PAGE.html">EVM Setup</a>. In addition do below steps.</dd></dl>
<h3><a class="anchor" id="autotoc_md662"></a>
AM64X-EVM</h3>
<ul>
<li>For connecting a board in EP mode and a Windows or Linux PC a specialized cable as below is required  <style>div.image img[src="pcie_cable.png"]{ width:50%}</style> <div class="image">
<img src="pcie_cable.png" alt=""/>
</div>
</li>
<li>This cable can be obtained from Adex Electronics (<a href="https://www.adexelec.com">https://www.adexelec.com</a>).</li>
<li>PCs (more specifically the PCIe electromechanical spefication) mandates an add-in card (the board in EP mode in this case) to use the reference clock on the connector. This requires modifications to the EVM:<ul>
<li>use a TMDS243EVM or TMDS64EVM Rev. C</li>
<li>remove Resistors R661, R662, R667 &amp; R668</li>
<li>populate Resistors R665, R666, R679 &amp; R680 (all 0 ohm)</li>
</ul>
</li>
<li><dl class="section note"><dt>Note</dt><dd>Contrary to other examples, this example requires the CK+ and CK- lines of the PCIe cable to be present.</dd></dl>
</li>
<li>The jumper J34 on the EVM needs to be disconnected, as we want neither the AM24x to driver the PERST signal (we're an EP, this is an input) nor do we want the x86's PERST signal to reset our processor, because we want to boot the AM24x BEFORE the x86 to make sure the startup and reset timing requirements are met.</li>
</ul>
<h2><a class="anchor" id="autotoc_md663"></a>
RC Setup</h2>
<p>This example assumes use of Windows or Linux on an x86 PC as the RC. Only specific versions of Windows have been Linux have been tested, though others should works as well, but might require minor changes.</p>
<p>While the EP application should work with every x86 based system, there could be differences especially in how the BIOS handles PCIe cards. The driver has been tested on the following hardware:</p>
<ul>
<li>Intel 10th Generation Core i3-10100 on MSI MAG Z490 mainboard</li>
<li>"UP Squared Pro 7000" with an Intel Atom x7425E</li>
</ul>
<h3><a class="anchor" id="autotoc_md664"></a>
Windows</h3>
<p>On the Windows target system, the following software needs to be installed:</p><ul>
<li>Windows 10 22H2</li>
<li>WDK for windows 10, version 2004 <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/other-wdk-downloads">https://learn.microsoft.com/en-us/windows-hardware/drivers/other-wdk-downloads</a></li>
<li>Windows SDK 10.0.19041.685 <a href="https://developer.microsoft.com/en-us/windows/downloads/sdk-archive/">https://developer.microsoft.com/en-us/windows/downloads/sdk-archive/</a></li>
<li>Microsoft Visual C++ Redistributable from <a href="https://learn.microsoft.com/en-us/cpp/windows/latest-supported-vc-redist?view=msvc-170#visual-studio-2015-2017-2019-and-2022">https://learn.microsoft.com/en-us/cpp/windows/latest-supported-vc-redist?view=msvc-170#visual-studio-2015-2017-2019-and-2022</a></li>
</ul>
<p>In order to build the Windows driver that runs on the RC to talk to the EP, the following software needs to be installed:</p>
<ul>
<li>WDK for windows 10, version 2004 <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/other-wdk-downloads">https://learn.microsoft.com/en-us/windows-hardware/drivers/other-wdk-downloads</a></li>
<li>Windows SDK 10.0.19041.685 <a href="https://developer.microsoft.com/en-us/windows/downloads/sdk-archive/">https://developer.microsoft.com/en-us/windows/downloads/sdk-archive/</a></li>
<li>Visual Studio 2019 (Professional or Community edition)<ul>
<li>spectre mitigation libraries need to be added as an individual component using Visual Studio's installer</li>
</ul>
</li>
<li>ti-sample-kmdf and ti-sample-console source code</li>
</ul>
<h3><a class="anchor" id="autotoc_md665"></a>
Linux</h3>
<p>On the Linux target system, the following distributions and versions have been tested:</p><ul>
<li>Ubuntu 20.04 with Kernel 5.15.0-91-generic</li>
<li>Debian 12 with Kernel 6.1.0-10-amd64</li>
</ul>
<p>The Linux kernel needs to include the following configuration options:</p>
<p>The kernel version currently running can be verified with the uname utility:</p>
<div class="fragment"><div class="line">uname -a</div>
<div class="line">Linux debian 6.1.0-17-rt-amd64 #1 SMP PREEMPT_RT Debian 6.1.69-1 (2023-12-30) x86_64 GNU/Linux</div>
</div><!-- fragment --><p>Kernel options used to compile the running kernel are usually available in a file under /boot/*kernel_version* or at /proc/config.gz. The following kernel options are required:</p><ul>
<li>CONFIG_VFIO, CONFIG_VFIO_PCI</li>
<li>CONFIG_IOMMU, CONFIG_INTEL_IOMMU On AMD based systems, CONFIG_AMD_IOMMU is used instead of CONFIG_INTEL_IOMMU.</li>
</ul>
<p>On Intel based systems, the IOMMU usually needs to be enabled by adding the parameter intel_iommu=on to the kernel command line. This can be done by modifying the file /etc/default/grub:</p>
<div class="fragment"><div class="line">GRUB_CMDLINE_LINUX=&quot;intel_iommu=on&quot;</div>
</div><!-- fragment --><p>On AMD based systems, the IOMMU is enabled by default.</p>
<h2><a class="anchor" id="autotoc_md666"></a>
Run the example</h2>
<ul>
<li>Make sure the Windows or Linux PC is powered off</li>
<li>Connect the Windows or Linux PC and the EVM with the PCIe cable</li>
<li><p class="startli">Launch a CCS debug session and run the example executable, see CCS Launch, Load and Run</p>
<p class="startli">After starting the example application, only the following status is printed on the UART terminal:</p>
</li>
</ul>
<div class="fragment"><div class="line">PCIe: EP initialized and waiting for link</div>
</div><!-- fragment --><ul>
<li><p class="startli">Power on the Windows or Linux PC</p>
<p class="startli">After powering up the RC system, the following output should be visible on the UART terminal:</p>
</li>
</ul>
<div class="fragment"><div class="line">PCIe: link detected</div>
<div class="line">PCIe Link Parameter: PCIe Gen1 with 2.5 GT/s speed, Number of Lanes: 1</div>
<div class="line">EP is in D0 state</div>
<div class="line">PCIe: signaling APPL ready</div>
<div class="line">APPL: pcie ready</div>
</div><!-- fragment --><p>The initial link parameters depend on the behavior of the RC system. With some systems, the initial link is already established at 5 GT/s, while other systems establish a link at 2.5 GT/s and upgrade the link to 5 GT/s upon the call to <a class="el" href="group__DRV__PCIE__MODULE.html#gafa104b227a358f3b966cb60bf137bf3a" title="Configure Pcie for EP (End Point) operation. PCIe mode setting is NOT done here (Pcie_setInterfaceMod...">Pcie_cfgEP()</a>.</p>
<p>At this point, different instructions apply to Windows and Linux based RC systems.</p>
<h3><a class="anchor" id="autotoc_md667"></a>
Windows</h3>
<h4><a class="anchor" id="autotoc_md668"></a>
Building for Windows</h4>
<p>Before trying to build the ti-sample-kmdf driver, make sure that your Visual Studio installation and Microsoft's SDK are all correctly installed by trying to build a template KMDF driver according to Microsoft's instructions:</p>
<p><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/gettingstarted/writing-a-kmdf-driver-based-on-a-template">https://learn.microsoft.com/en-us/windows-hardware/drivers/gettingstarted/writing-a-kmdf-driver-based-on-a-template</a></p>
<p>The ti-sample-kmdf solution contains two projects, the kernel mode driver ti-sample-kmdf and a console application ti-sample-console. Both projects can be built by opening the ti-sample-kmdf solution in Visual Studio 2019 and building the entire solution.</p>
<ul>
<li>The driver currently only support 64-bit mode on x86 machines, so the platform "x64" should be selected, along with the configuration "Release".</li>
<li>In the solution explorer select the solution "ti-sample-kmdf" and build the solution.</li>
</ul>
<p>The build output will be located in a new folder "x64\\Release" below the solution directory (ti-sample-kmdf\x64\Release).</p>
<h4><a class="anchor" id="autotoc_md669"></a>
Deploying on Windows</h4>
<p>The following files from the build output folder need to be copied to the target machine:</p>
<ul>
<li>ti-sample-kmdf.inf</li>
<li>ti-sample-kmdf.sys</li>
<li>ti-sample-kmdf.cat</li>
<li>ti-sample-kmdf.cer</li>
<li>ti-sample-console.exe</li>
</ul>
<p>Windows by default only accepts signed drivers. An installation can be modified to accept socalled test signed drivers. The Windows KMDF sample driver ti-sample-kmdf uses this approach and is built as a test signed driver.</p>
<p>In order to allow Windows to use test signed drivers, open an administrator prompt (cmd, Run as administrator) and enter the following command:</p>
<div class="fragment"><div class="line">Bcdedit.exe -set TESTSIGNING ON</div>
</div><!-- fragment --><p>After enabling test signing the system needs to be rebooted. At this point the AM24x EVM with the pcie_enumerate_ep application should be started as described above.</p>
<p>You then need to install the certificate used to test sign the driver on the target computer. This certificate is placed in the solution output folder along with the driver and is named ti-sample-kmdf.cer.</p>
<p>It can be installed using the CertMgr.exe tool that comes with the WDK from an administrator prompt:</p>
<div class="fragment"><div class="line">cd C:\\Program Files (x86)\\Windows Kits\\10\\bin\\10.0.19041.0\\x64\\</div>
<div class="line"> </div>
<div class="line">CertMgr.exe /add ti-sample-kmdf.cer /s /r localMachine root /all</div>
<div class="line">CertMgr.exe /add ti-sample-kmdf.cer /s /r localMachine trustedpublisher</div>
</div><!-- fragment --><p>(use full path to ti-sample-kmdf.cer)</p>
<p><b>This CertMgr.exe is different from the certmgr that opens when you try to just run CertMgr on an administrator command line.</b></p>
<p>With the certificate installed you can install the driver for the device using the Windows device manager. Look for an unknown PCI device and verify the hardware ID is PCI\VEN_17cd&amp;DEV_0100. Right-click the device, select "Browse my computer for drivers" and select the folder containing the solution build output.</p>
<p>Windows should install the driver and inform you that it finished installing the driver for the ti-sample-kmdf device.</p>
<p>Alternatively, the driver can also be deployed from within Visual Studio. This latter approach is more convenient for development as it works from within the development environment and includes additional test steps. Follow the Microsoft documentation at <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/gettingstarted/writing-a-kmdf-driver-based-on-a-template">https://learn.microsoft.com/en-us/windows-hardware/drivers/gettingstarted/writing-a-kmdf-driver-based-on-a-template</a> and <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/develop/deploying-a-driver-to-a-test-computer">https://learn.microsoft.com/en-us/windows-hardware/drivers/develop/deploying-a-driver-to-a-test-computer</a> for further instructions.</p>
<h4><a class="anchor" id="autotoc_md670"></a>
Usage on Windows</h4>
<p>In order to make use of the driver the ti-sample-console application can be run. This application opens the driver, sends IOCTLs to the driver, and waits for the IOCTLs to return.</p>
<p>The KMDF driver uses the "pattern" sent with the IOCTL to fill the Bar0 data area of the EP and then triggers a "downstream" interrupt in the EP. The EP copies the data area from its Bar0 to the RC driver's DMA buffer and triggers an MSI in the RC. The RC handles this interrupt and replies to the IOCTL with the data sent back via DMA.</p>
<h3><a class="anchor" id="autotoc_md671"></a>
Linux</h3>
<h4><a class="anchor" id="autotoc_md672"></a>
Building for Linux</h4>
<ul>
<li><p class="startli">The ti-sample-vfio example driver consists of a single C file that can be compiled on-target using a simple GCC command:</p>
<p class="startli">gcc ti-sample-vfio.c -o ti-sample-vfio -g -O2</p>
</li>
</ul>
<h4><a class="anchor" id="autotoc_md673"></a>
Deploying on Linux</h4>
<ul>
<li>Since the driver can be compiled self-hosted on Linux there's no separate deployment step.</li>
</ul>
<h4><a class="anchor" id="autotoc_md674"></a>
Usage on Linux</h4>
<ul>
<li><p class="startli">Get root privileges:</p>
<p class="startli">sudo su -</p>
</li>
<li>Make sure the AM24x PCIe EP is correctly enumerated by the Linux OS and note the bus, device and function assigned to the EP:</li>
</ul>
<div class="fragment"><div class="line">lspci -vt</div>
<div class="line"> </div>
<div class="line">-[0000:00]-+-00.0  Intel Corporation Device 4679</div>
<div class="line">           ...</div>
<div class="line">           +-1d.0-[03]----00.0  Cadence Design Systems, Inc. Device 0100</div>
</div><!-- fragment --><p><b>In this example, our device is connected to the RC at 0000:00:1d.0 and was assigned address 0000:03:00.0 (bus 3, device 0, function 0).</b></p>
<ul>
<li>Load the VFIO-PCI driver:</li>
</ul>
<div class="fragment"><div class="line">modprobe vfio-pci</div>
</div><!-- fragment --><ul>
<li>Assign the pcie_enumerate_ep sample's vendor and device ID to the VFIO driver:</li>
</ul>
<div class="fragment"><div class="line">echo &quot;17cd 0100&quot; &gt; /sys/bus/pci/drivers/vfio-pci/new_id</div>
</div><!-- fragment --><p>At this point the EP is put into D3hot state by the Linux VFIO driver:</p>
<div class="fragment"><div class="line">PCIe: power state entry</div>
<div class="line">EP is in D3hot state</div>
<div class="line">PCIe: signaling APPL halt</div>
<div class="line">APPL: pcie not ready</div>
</div><!-- fragment --><ul>
<li>Check which IOMMU group the EP was assigned to:</li>
</ul>
<div class="fragment"><div class="line">readlink /sys/bus/pci/devices/0000:03:00.0/iommu_group</div>
<div class="line"> </div>
<div class="line">../../../../kernel/iommu_groups/16</div>
</div><!-- fragment --><p><b>our device is in IOMMU group 16</b></p>
<ul>
<li>Make sure the EP is the only device in this IOMMU group:</li>
</ul>
<div class="fragment"><div class="line">ls -l /sys/bus/pci/devices/0000:03:00.0/iommu_group/devices</div>
<div class="line"> </div>
<div class="line">lrwxrwxrwx 1 root root 0 17. Nov 10:57 0000:03:00.0 -&gt; ../../../../devices/pci0000:00/0000:00:1d.0/0000:03:00.0</div>
</div><!-- fragment --><p><b>our device is the sole device in this IOMMU group</b></p>
<ul>
<li><p class="startli"><b>if there are other devices listed as part of this IOMMU group, you need to try a different PCIe slot on your x86 target.</b></p>
<p class="startli"><b>If that doesn't help, you could try loading the vfio_pci driver for all devices in this IOMMU group, provided of course that these devices aren't needed for normal operation.</b></p>
<p class="startli"><b>See IOMMU background at the end of this page for further information.</b></p>
</li>
<li>Start the ti-sample-vfio application with bus, device, function and the IOMMU group as parameters:</li>
</ul>
<div class="fragment"><div class="line">./ti-sample-vfio 3 0 0 16</div>
</div><!-- fragment --><ul>
<li>Optionally specify the number of MSI vectors to allocate (multiple message enable):</li>
</ul>
<div class="fragment"><div class="line">./ti-sample-vfio 3 0 0 16 8</div>
</div><!-- fragment --><ul>
<li>Additionally you can specify the number of loops the DMA copy test should execute:</li>
</ul>
<div class="fragment"><div class="line">./ti-sample-vfio 3 0 0 16 8 1000</div>
</div><!-- fragment --><ul>
<li>In order to debug the EP application, the RC application optionally waits for user input at certain locations, e.g. allowing the user to observe register content:</li>
</ul>
<div class="fragment"><div class="line">./ti-sample-vfio 3 0 0 16 8 1000 wait</div>
</div><!-- fragment --><p>Running the sample application puts the device from D3hot into D0 state. The application outputs further state changes while the sample executes until finally the EP is put back into D3hot state.</p>
<p>See below for what the output should look like when executing the Linux example.</p>
<h1><a class="anchor" id="autotoc_md675"></a>
Important concepts in the example</h1>
<p>The PCIe Enumeration (EP) example demonstrates some important concepts for EP applications when used in conjunction with "typical" host systems based on e.g. x86 Linux and Windows.</p>
<h2><a class="anchor" id="autotoc_md676"></a>
x86 RC requirements</h2>
<p>x86 systems typically assume that PCIe devices are built-in and thus available at power-up of the x86 system. Some x86 implementations also support hot-plug PCIe devices that can be connected at runtime.</p>
<p>Connecting the AM24x as an EP to an x86 as a RC needs to follow PCIe specification requirements in order to be properly detected by the x86 system's BIOS.</p>
<h3><a class="anchor" id="autotoc_md677"></a>
Startup requirements, reset behavior</h3>
<p>The PCI express specification requires an endpoint device to enter link training within 20 ms of deassertion of the PERST# signal.</p>
<p>The PERST# signal is guaranteed to be active for at least 100 ms after power supplies are stable for “standard” PCI express cards. In effect this means that a device needs to enter link training within 120 ms from power supplies becoming stable. The time it takes for the AM24x to boot up to a point where it can enter PCIe link training depends on many variables.</p>
<ul>
<li>A) In order to ensure startup timing requirements are met, an embedded system consisting of an x86 and an AM24x could release the AM24x's reset before releasing the x86's reset. This allows the AM24x to complete startup before the x86 releases its PERST signal.</li>
<li>B) If that's not an option a system might optimize bootup of the AM24x application to ensure that the PCIe EP driver is ready to enable link training within the allotted time frame. Such optimization is outside of the scope of this example</li>
<li>C) If the x86 system supports hot-plugging of PCIe devices, the AM24x EP can boot up in parallel with the x86, but the BIOS and the operating system need to support this.</li>
</ul>
<p>This example ensures the timing conditions are met by powering up the EP before powering up the RC, thus resembling the first approach, where the AM24x boots before the x86.</p>
<h3><a class="anchor" id="autotoc_md678"></a>
Reference clock</h3>
<p>There are different schemes for distributing the PCIe reference clock in a system.</p>
<p>x86 usually systems assume a common reference clock topology where the PCIe RefClk is provided by the x86 on the PCI express card connector. The EP is expected to use that reference clock. If the x86 uses spread spectrum clocking (usually it does) the same frequency spread is applied to the EP and the RC, ensuring stable communication.</p>
<p>With separate reference clocks there exist two options:</p>
<p>Separate reference clock with no spread (SRNS): Both RC and EP use a separate reference clock, and there's no spread spectrum clocking applied.</p>
<p>Separate reference clock, independent spread (SRIS): Both RC and EP use a separate reference clock both with individual spread spectrum clocking. This mode of operation is supported by the AM24x but support within x86 is usually not "user" configurable.</p>
<p>On the AM24x EVM starting with revision A there is a clock generator IC that supplies the reference clock to both the AM24x (where RefClk thus acts as an input) and to the PCIe connector. A x86 also supplies its reference clock on its PCIe connector.</p>
<p>There are two options to handle this situation:</p>
<ul>
<li>A) Rework the AM24x EVM to directly connect the AM24x RefClk pins to the PCIe connector and use a PCIe male-to-male cable that connects the RefClk pins. This is the recommended approach.</li>
<li>B) Leave the AM24x EVM as-is and use a PCIe male-to-male cable where the RefClk pins are /not/ connected. This results in a SRNS/SRIS setup which may or may not work.</li>
</ul>
<h4><a class="anchor" id="autotoc_md679"></a>
External reference clock implications</h4>
<p>The reference clock is used as the PCIe core clock on the AM24x, and without that clock running certain registers of the AM24x's PCIe peripheral are inaccessible (PCIE0_CORE_DBN_CFG_PCIE_CORE). For the generic use case we need an external reference clock, but that in turn means the EP needs to support working even if the reference clock is not (yet) available, if only to allow powering the EP before powering the RC.</p>
<h3><a class="anchor" id="autotoc_md680"></a>
EP-&gt;RC and RC-&gt;EP interrupt signaling</h3>
<p>Several mechanisms exist for the EP to signal events back to the RC. Traditionally PCI devices used to be able to trigger one of four interrupt lines (INTA-D) that allowed interrupts to be raised in the RC's CPU.</p>
<p>Later versions of PCI and all PCIe devices added support for message signaled interrupts (MSI), where the RC tells the EP an address and a value that the EP should send to the RC in order to raise an interrupt.</p>
<p>PCIe doesn't specify a means for an RC to raise an interrupt in an EP, as EPs are usually "hardware", where every incoming access can trigger any kind of response.</p>
<p>When using a CPU to implement the EP functionality on the other hand, it is desirable to allow the RC to send interrupts to the EP in order to inform the EP's CPU that some action is desired. On the AM24x/AM64x this can be achieved by tryingger a downstream interrupt in the EP, which causes an interrupt to be delivered to the EP's CPU (e.g. R5f).</p>
<p>An RC can trigger a downstream interrupt by setting bit 8 (0x100) in the EP's vendor specific control register in the EP's configuration space.</p>
<h2><a class="anchor" id="autotoc_md681"></a>
Software concepts</h2>
<h3><a class="anchor" id="autotoc_md682"></a>
Driver startup</h3>
<p>In order to be able to support scenarios where the PCIe reference clock isn't immediately available upon startup of the AM24x, the PCIe EP driver initializes only the bare minimum in order to be able to start link training during Pcie_open (called from Drivers_open).</p>
<p>The application then needs to wait (poll) for a PCIe link via <a class="el" href="group__DRV__PCIE__MODULE.html#gaba9b2a8b35994b93edd08fc5ab90c325" title="Check if PCIe link training completed.">Pcie_isLinkUp()</a>. Once a link is established, we can assume that the reference clock is available and configure the rest of the PCIe EP. In order to avoid a race condition with the RC which might be trying to enumerate the EP as soon as a link is established, the EP driver configures the device to respond with CRS completions (configuration request retry status) to config requests until the EP finished initialization, at which point <a class="el" href="group__DRV__PCIE__MODULE.html#gafa104b227a358f3b966cb60bf137bf3a" title="Configure Pcie for EP (End Point) operation. PCIe mode setting is NOT done here (Pcie_setInterfaceMod...">Pcie_cfgEP()</a> is called to enable the EP to properly respond to configuration requests.</p>
<p>The PCIe specification calls for system software (x86 BIOS) to wait at least one second while the device responds with CRS completions. Care must be taken if the EP keeps responding with CRS completions for too long, as this might not be handled gracefully in x86 BIOS implementations.</p>
<h3><a class="anchor" id="autotoc_md683"></a>
Memory map</h3>
<h4><a class="anchor" id="autotoc_md684"></a>
Local memories</h4>
<p>If an endpoint wants to expose part of its local memories via a PCIe BAR it needs to add "Inbound Address Translation" entries. The target address for an inbound ATU entry is the address in the SoC address space. This address needs to be aligned to the size of the memory region.</p>
<p>This example allocates a dedicated memory section in the linker file to place the bar0 memory. The bar0 memory includes a configruation area (struct config) and a memory buffer (uin32_t data[]). The configuration area is used as a control and status register space for the RC to configure the EP and for the EP to respond with status information.</p>
<p>Since accesses to that memory region from the RC are not coherent with the R5f caches, a MPU region (CONFIG_MPU_REGION7) is configured to map a part of the bar0 memory as strongly ordered memory, thus aleviating the need to manually maintain cache coherency.</p>
<p>In order to improve performance for the data buffers these are still accessed as normal, cacheable memory, and thus require the use of <a class="el" href="group__KERNEL__DPL__CACHE.html#ga894fcf969b6afb5f30e25861d39c9219" title="Cache invalidate for a specified region.">CacheP_inv()</a> to manually invalidate cache content before and after accessing the data buffer.</p>
<h4><a class="anchor" id="autotoc_md685"></a>
DMA memory / outbound mappings</h4>
<p>If an endpoint wants to access part of the RC's memory via DMA it needs to create an outbound mapping. Since the PCIe address of that memory is at the discretion of the RC this mapping can't be created at compilation or initialization time but rather needs to be created at runtime after the RC informed the EP about the location of the RC's DMA buffer.</p>
<p>This example implements two "registers" to allow the RC to specify the address and length of a DMA buffer and informs the EP via downstream IRQ (RC-&gt;EP) that this configuration has been performed. The EP then dynamically maps the RC's DMA buffer via an outbound mapping.</p>
<p>Outbound mappings are currently only supported via the PCIE0_DAT0 window. Where outbound mappings are located within this 128 MB area is up to the application. Outbound mappings need to align both the base address (local SoC address) and the target address (PCIe address) to the size of the region. Since the PCIe bus address of the RC's DMA buffer is at the RC's discretion there can't be any assumptions about its alignment.</p>
<p>The example uses one 64 MB area starting at 0x68000000 (start of PCIE0_DAT0) to map the RC's DMA buffer. Due to the unknown alignment the EP can therefore map a maximum of 32 MB in that area.</p>
<p>The example uses message signaled interrupts which also requires an outbound mapping. The example uses a 256 byte region at the end of the PCIE0_DAT0 address space (0x6fffff00) to map the RC's MSI target address.</p>
<h3><a class="anchor" id="autotoc_md686"></a>
Driver runtime operation</h3>
<p>Since the driver initializes only the bare minimum during Pcie_open, the remaining configuration needs to be performed at runtime. In order to allow an application maximum flexibility in how it uses the AM24x PCIe EP's feature, the driver provides only passive functions to read status and RC configured settings and to modify the EP's configuration.</p>
<p>The application needs to poll for hardware status changes or handle interrupts in order to track the state of the PCIe interface, and then call the appropriate configuration functions.</p>
<p>The pcie_enumerate_ep sample application acts on the following hardware events:</p>
<ul>
<li>Link up detection (polled, since there is no IRQ generated for this event</li>
<li>Link down detection (IRQ triggered)</li>
<li>Power management state entry (IRQ triggered)</li>
<li>Power management return to active state "D0" (polled, since there is no IRQ generated for this event)</li>
<li>PCIe hot-reset (IRQ triggered)</li>
<li>"Downstream" interrupts (IRQ triggered)</li>
</ul>
<p>The pcie_enumerate_ep sample application acts on the following software events (all triggered via a downstream IRQ and action flags in the ctrl "register"):</p>
<ul>
<li>Configuration Done</li>
<li>Reset</li>
<li>DMA Copy Request (copies from Bar0 to RC's DMA buffer)</li>
<li>MSI Request (sends every enabled MSI interrupt once)</li>
<li>BAR1/2 Request (verifies Bar1/Bar2 content and sends a MSI)</li>
</ul>
<h4><a class="anchor" id="autotoc_md687"></a>
Pcie_onLinkDetect</h4>
<p>Once the EP application detected a link it can rely on the PCIe RefClk being available. The example application then calls Pcie_onLinkDetect(). That function can perform any additional application specific configuration (in this example we set the "slot clock configuration" to indicate we're using the RefClk from the connector) and then calls <a class="el" href="group__DRV__PCIE__MODULE.html#gafa104b227a358f3b966cb60bf137bf3a" title="Configure Pcie for EP (End Point) operation. PCIe mode setting is NOT done here (Pcie_setInterfaceMod...">Pcie_cfgEP</a> to finalize the EP configuration.</p>
<h1><a class="anchor" id="autotoc_md688"></a>
Background information</h1>
<h2><a class="anchor" id="autotoc_md689"></a>
PCIe reference clock</h2>
<p>PCIe systems usually use a 100 MHz reference clock. On the AM24x, this reference clock can be generated internally or it can be sourced externally. If the reference clock is generated internally, it can optionally be output on the RefClk pins.</p>
<p>In the scope of the PCIe standard, use of a common reference clock is optional, provided that both systems use a reference clock that ensures certain jitter thresholds. The PCI express card electromechanical specification that describes the type of PCIe connectors typically found on PC mainboards mandates the use of a common reference clock.</p>
<p>The PCIe reference clock is often modulated to reduce electromagnetic interference, so called "spread spectrum clocking". Use of spread spectrum clocking requires both link partners to be able to tolerate much higher timing differences than what the PCIe specification requires for reference clock stability.</p>
<p>Setups with a common reference clock usually have no problems when spread spectrum clocking is enabled. Setups without a common reference clock and with spread spectrum clocking enabled are called "SRIS" (separate reference, independent spread). Setups without a common reference clock and no spread spectrum clocking are called "SRNS" (separate reference, no spread).</p>
<p>The PCIe driver allows the AM24x to be configured for every possible reference clock configuration, but x86 systems often rely on a common reference clock (in accordance with the PCI express card specification). On some systems, spread spectrum clocking can be disabled, allowing a SRNS type setup. Other systems might support SRIS, but this usually needs to be configured in the x86 BIOS, and is often not configurable at all.</p>
<h2><a class="anchor" id="autotoc_md690"></a>
IOMMU background</h2>
<p>An IOMMU sits as an MMU between memory accesses coming from DMA capable devices and the system's main memory. With the IOMMU active, the PCIe addresses seen by the EP are no longer actual physical addresses but rather logical addresses that are valid only for this device (or rather this IOMMU group).</p>
<p>This has several benefits, for example it allows the host's operating system to map physically not contiguous memory buffers as a logically contiguous buffer for the device. Another benefit is that a device can only access the system memory that is explicitly intended for the device to use, providing extra security to a system. The Linux VFIO framework requires an IOMMU to be present in order to prevent a user space process from accessing arbitrary parts of system memory by means of a DMA capable device. There is a special No-IOMMU mode in VFIO but use of this mode is not supported by this sample.</p>
<p>The granularity with which an IOMMU can differentiate between devices depends on the particular system. Linux uses a concept of IOMMU groups where a single group holds all the devices that need to use the same IOMMU mapping. For VFIO there must not be any other devices in the same IOMMU group as the AM24x EP running the sample application.</p>
<p>Devices directly connected to root ports of an Intel system can be expected to be assigned to an individual IOMMU group.</p>
<p>See <a href="https://docs.kernel.org/driver-api/vfio.html">https://docs.kernel.org/driver-api/vfio.html</a> for more details.</p>
<h1><a class="anchor" id="autotoc_md691"></a>
Example Output</h1>
<h2><a class="anchor" id="autotoc_md692"></a>
Linux</h2>
<p>When running the Linux RC sample driver ti-sample-vfio, the output on the Linux terminal should be similar to this:</p>
<div class="fragment"><div class="line">sudo ./ti-sample-vfio 3 0 0 16 8 5</div>
<div class="line">--------------------------------------------------------------------------------</div>
<div class="line">Starting PCIe RC VFIO test application with parameters:</div>
<div class="line">PCIe Bus Number: 3</div>
<div class="line">PCIe Device Number: 0</div>
<div class="line">PCIe Function Number: 0</div>
<div class="line">PCIe IOMMU Number: 16</div>
<div class="line">Test mode: default test</div>
<div class="line">MSI IRQ number: 8</div>
<div class="line">Iteration number: 5</div>
<div class="line">--------------------------------------------------------------------------------</div>
<div class="line">Using PCI device 0000:03:00.0 in IOMMU group 16</div>
<div class="line">VFIO_CHECK_EXTENSION VFIO_TYPE1_IOMMU: Present</div>
<div class="line">VFIO_CHECK_EXTENSION VFIO_NOIOMMU_IOMMU: Not Present</div>
<div class="line">Config region info: region index 0x7, size 0x1000, offset 0x70000000000, cap_offset 0x0, flags 0x3</div>
<div class="line">BAR0 Info: size 0x8000, offset 0x0, flags 0x7</div>
<div class="line">MSI IRQ Info: index: 1, count: 16, flags: 9</div>
<div class="line">RC completed EP initialization</div>
<div class="line">--------------------------------------------------------------------------------</div>
<div class="line">Start COPY test</div>
<div class="line">COPY test passed with 5 loops</div>
<div class="line">--------------------------------------------------------------------------------</div>
<div class="line">Initialize MSI test. Expect 8 distinct MSI IRQs</div>
<div class="line">Expect MSI IRQ nr. 0</div>
<div class="line">Expect MSI IRQ nr. 1</div>
<div class="line">Expect MSI IRQ nr. 2</div>
<div class="line">Expect MSI IRQ nr. 3</div>
<div class="line">Expect MSI IRQ nr. 4</div>
<div class="line">Expect MSI IRQ nr. 5</div>
<div class="line">Expect MSI IRQ nr. 6</div>
<div class="line">Expect MSI IRQ nr. 7</div>
<div class="line">MSI test passed</div>
<div class="line">--------------------------------------------------------------------------------</div>
<div class="line">Initialize BARs test</div>
<div class="line">BAR1 Info: size 0x100000, offset 0x10000000000, flags 0x7</div>
<div class="line">BAR2 Info: size 0x100000, offset 0x20000000000, flags 0x7</div>
<div class="line">BAR test passed</div>
<div class="line">--------------------------------------------------------------------------------</div>
<div class="line">RC resets EP</div>
</div><!-- fragment --><p>During the execution of the ti-sample-vfio test program, the following output should be visible on the EVM's UART:</p>
<div class="fragment"><div class="line">EP is in D0 state</div>
<div class="line">PCIe: signaling APPL ready</div>
<div class="line">APPL: pcie ready</div>
<div class="line">PCIe: lost PCIe link</div>
<div class="line">PCIe: hot reset detected</div>
<div class="line">PCIe: signaling APPL halt</div>
<div class="line">APPL: pcie not ready</div>
<div class="line">PCIe: link detected</div>
<div class="line">PCIe link parameter: PCIe Gen2 with 5.0 GT/s speed, Number of Lanes: 1</div>
<div class="line">PCIe: signaling APPL ready</div>
<div class="line">APPL: pcie ready</div>
<div class="line">PCIe: MSI enabled with 8 vector(s) using address fee00618 and data 0</div>
<div class="line">Mapping MSI target at 0xfee00600 - size 0xff...</div>
<div class="line">Mapping DMA buffer at 0x0 - size 0xffff...</div>
<div class="line">APPL: EP configured</div>
<div class="line">DMA test done</div>
<div class="line">DMA test done</div>
<div class="line">DMA test done</div>
<div class="line">DMA test done</div>
<div class="line">DMA test done</div>
<div class="line">Send MSI Irq Nr. 0</div>
<div class="line">Send MSI Irq Nr. 1</div>
<div class="line">Send MSI Irq Nr. 2</div>
<div class="line">Send MSI Irq Nr. 3</div>
<div class="line">Send MSI Irq Nr. 4</div>
<div class="line">Send MSI Irq Nr. 5</div>
<div class="line">Send MSI Irq Nr. 6</div>
<div class="line">Send MSI Irq Nr. 7</div>
<div class="line">MSI test done</div>
<div class="line">BAR test done</div>
<div class="line">Disabling MSI mapping...</div>
<div class="line">Disabling DMA buffer mapping...</div>
<div class="line">APPL: EP unconfigured</div>
<div class="line">PCIe: lost PCIe link</div>
<div class="line">PCIe: hot reset detected</div>
<div class="line">PCIe: signaling APPL halt</div>
<div class="line">APPL: pcie not ready</div>
<div class="line">PCIe: link detected</div>
<div class="line">PCIe Link Parameter: PCIe Gen2 with 5.0 GT/s speed, Number of Lanes: 1</div>
<div class="line">PCIe: signaling APPL ready</div>
<div class="line">APPL: pcie ready</div>
<div class="line">PCIe: power state entry</div>
<div class="line">EP is in D3hot state</div>
<div class="line">PCIe: signaling APPL halt</div>
<div class="line">APPL: pcie not ready</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md693"></a>
Windows</h2>
<p>When running the Windows RC sample driver ti-sample-kmdf along with the Windows console application ti-sample-console, the output on the Windows terminal should be similar to this:</p>
<div class="fragment"><div class="line">--------------------------------------------------------------------------------</div>
<div class="line">Starting PCIe RC KMDF test application</div>
<div class="line">--------------------------------------------------------------------------------</div>
<div class="line">Opening windows kernel mode driver \\.\SampleTI</div>
<div class="line">--------------------------------------------------------------------------------</div>
<div class="line">Start COPY test</div>
<div class="line">IOCTL_TISAMPLEKMDF_TEST_DMA returned data, verifying...</div>
<div class="line">COPY test passed</div>
<div class="line">--------------------------------------------------------------------------------</div>
<div class="line">Start MSI test</div>
<div class="line">IOCTL_TISAMPLEKMDF_TEST_MSI returned, result: 0000ffff</div>
<div class="line">MSI test passed</div>
<div class="line">--------------------------------------------------------------------------------</div>
<div class="line">Start Bar1/2 test</div>
<div class="line">IOCTL_TISAMPLEKMDF_TEST_BARS returned, result: 00000001</div>
<div class="line">BAR test passed</div>
<div class="line">--------------------------------------------------------------------------------</div>
<div class="line">Closing windows kernel mode driver</div>
<div class="line">KMDF test application done</div>
<div class="line">--------------------------------------------------------------------------------</div>
</div><!-- fragment --><p>During the execution of the ti-sample-console test program, the following output should be visible on the EVM's UART:</p>
<div class="fragment"><div class="line">DMA test done</div>
<div class="line">Send MSI IRQ nr. 0</div>
<div class="line">Send MSI IRQ nr. 1</div>
<div class="line">Send MSI IRQ nr. 2</div>
<div class="line">Send MSI IRQ nr. 3</div>
<div class="line">Send MSI IRQ nr. 4</div>
<div class="line">Send MSI IRQ nr. 5</div>
<div class="line">Send MSI IRQ nr. 6</div>
<div class="line">Send MSI IRQ nr. 7</div>
<div class="line">Send MSI IRQ nr. 8</div>
<div class="line">Send MSI IRQ nr. 9</div>
<div class="line">Send MSI IRQ nr. 10</div>
<div class="line">Send MSI IRQ nr. 11</div>
<div class="line">Send MSI IRQ nr. 12</div>
<div class="line">Send MSI IRQ nr. 13</div>
<div class="line">Send MSI IRQ nr. 14</div>
<div class="line">Send MSI IRQ nr. 15</div>
<div class="line">MSI test done</div>
<div class="line">BAR test done</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md694"></a>
See Also</h1>
<p><a class="el" href="DRIVERS_PCIE_PAGE.html">PCIE</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
