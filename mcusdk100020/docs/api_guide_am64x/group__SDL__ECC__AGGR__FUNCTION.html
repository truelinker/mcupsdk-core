<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="shortcut icon" href="favicon.png" type="image/png">    
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<title>AM64x MCU+ SDK: ECC_AGGR Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<style>
.tinav {
    background: #c00;
    /* height: 41.375px; */
    height: 30px;
    }
</style>    
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
  /* @license-end */
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="AM64x MCU+ SDK"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 40px;">
  <td id="projectlogo"><a href="https://www.ti.com"><img alt="Logo" src="ti_logo.svg"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AM64x MCU+ SDK
   &#160;<span id="projectnumber">10.00.00</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.html" method="get">
              <img id="MSearchSelect" src="search/mag.svg" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
</td>
 </tr>
 </tbody>
</table>
<div class=tinav></div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__SDL__ECC__AGGR__FUNCTION.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ECC_AGGR Functions<div class="ingroups"><a class="el" href="group__SDL__ECC__AGGR__API.html">APIs for SDL ECC (ECC_AGGR)</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Introduction</h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga1f7466c9a2745c342e9bf9b20f64f6f5"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga1f7466c9a2745c342e9bf9b20f64f6f5">SDL_ECC_initEsm</a> (const SDL_ESM_Inst esmInstType)</td></tr>
<tr class="memdesc:ga1f7466c9a2745c342e9bf9b20f64f6f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an module for usage with ECC module.  <a href="group__SDL__ECC__AGGR__FUNCTION.html#ga1f7466c9a2745c342e9bf9b20f64f6f5">More...</a><br /></td></tr>
<tr class="separator:ga1f7466c9a2745c342e9bf9b20f64f6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a3e77d0089427bae4e0ce94cdf0b143"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga5a3e77d0089427bae4e0ce94cdf0b143">SDL_ECC_init</a> (<a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac233021d13f25dc397424af5b5bdc28b">SDL_ECC_MemType</a> eccMemType, const <a class="el" href="structSDL__ECC__InitConfig__t.html">SDL_ECC_InitConfig_t</a> *pECCInitConfig)</td></tr>
<tr class="memdesc:ga5a3e77d0089427bae4e0ce94cdf0b143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes ECC module for ECC detection.  <a href="group__SDL__ECC__AGGR__FUNCTION.html#ga5a3e77d0089427bae4e0ce94cdf0b143">More...</a><br /></td></tr>
<tr class="separator:ga5a3e77d0089427bae4e0ce94cdf0b143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6846e8345f036e70e2e3643697a951f"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gab6846e8345f036e70e2e3643697a951f">SDL_ECC_initMemory</a> (<a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac233021d13f25dc397424af5b5bdc28b">SDL_ECC_MemType</a> eccMemType, <a class="el" href="group__SDL__ECC__AGGR__ENUM.html#ga0d731a39964dd93567cb3532002243b9">SDL_ECC_MemSubType</a> memSubType)</td></tr>
<tr class="memdesc:gab6846e8345f036e70e2e3643697a951f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes Memory to be ready for ECC error detection. Assumes ECC is already enabled.  <a href="group__SDL__ECC__AGGR__FUNCTION.html#gab6846e8345f036e70e2e3643697a951f">More...</a><br /></td></tr>
<tr class="separator:gab6846e8345f036e70e2e3643697a951f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc37c3496c3c42b4b3473840f04ba069"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gadc37c3496c3c42b4b3473840f04ba069">SDL_ECC_selfTest</a> (<a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac233021d13f25dc397424af5b5bdc28b">SDL_ECC_MemType</a> eccMemType, <a class="el" href="group__SDL__ECC__AGGR__ENUM.html#ga0d731a39964dd93567cb3532002243b9">SDL_ECC_MemSubType</a> memSubType, <a class="el" href="group__SDL__ECC__AGGR__ENUM.html#ga2fb3569c964c0a156c36f52bd4f0ac86">SDL_ECC_InjectErrorType</a> errorType, const <a class="el" href="structSDL__ECC__InjectErrorConfig__t.html">SDL_ECC_InjectErrorConfig_t</a> *pECCErrorConfig, uint32_t selfTestTimeOut)</td></tr>
<tr class="memdesc:gadc37c3496c3c42b4b3473840f04ba069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs self test by injecting and error and monitor response Assumes ECC is already enabled.  <a href="group__SDL__ECC__AGGR__FUNCTION.html#gadc37c3496c3c42b4b3473840f04ba069">More...</a><br /></td></tr>
<tr class="separator:gadc37c3496c3c42b4b3473840f04ba069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5979274875023a443b27b3b01168f27"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gaf5979274875023a443b27b3b01168f27">SDL_ECC_injectError</a> (<a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac233021d13f25dc397424af5b5bdc28b">SDL_ECC_MemType</a> eccMemType, <a class="el" href="group__SDL__ECC__AGGR__ENUM.html#ga0d731a39964dd93567cb3532002243b9">SDL_ECC_MemSubType</a> memSubType, <a class="el" href="group__SDL__ECC__AGGR__ENUM.html#ga2fb3569c964c0a156c36f52bd4f0ac86">SDL_ECC_InjectErrorType</a> errorType, const <a class="el" href="structSDL__ECC__InjectErrorConfig__t.html">SDL_ECC_InjectErrorConfig_t</a> *pECCErrorConfig)</td></tr>
<tr class="memdesc:gaf5979274875023a443b27b3b01168f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Injects ECC error at specified location Assumes ECC is already enabled.  <a href="group__SDL__ECC__AGGR__FUNCTION.html#gaf5979274875023a443b27b3b01168f27">More...</a><br /></td></tr>
<tr class="separator:gaf5979274875023a443b27b3b01168f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76910b19baf40bd7c85e7e77e08b548f"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga76910b19baf40bd7c85e7e77e08b548f">SDL_ECC_getStaticRegisters</a> (<a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac233021d13f25dc397424af5b5bdc28b">SDL_ECC_MemType</a> eccMemType, <a class="el" href="structSDL__ECC__staticRegs.html">SDL_ECC_staticRegs</a> *pStaticRegs)</td></tr>
<tr class="memdesc:ga76910b19baf40bd7c85e7e77e08b548f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the static registers for the specified ECC instance.  <a href="group__SDL__ECC__AGGR__FUNCTION.html#ga76910b19baf40bd7c85e7e77e08b548f">More...</a><br /></td></tr>
<tr class="separator:ga76910b19baf40bd7c85e7e77e08b548f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2e6218ddda539194cf00afe01b89ae7"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gac2e6218ddda539194cf00afe01b89ae7">SDL_ECC_getErrorInfo</a> (<a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac233021d13f25dc397424af5b5bdc28b">SDL_ECC_MemType</a> eccMemType, <a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a> intrSrc, <a class="el" href="structSDL__ECC__ErrorInfo__t.html">SDL_ECC_ErrorInfo_t</a> *pErrorInfo)</td></tr>
<tr class="memdesc:gac2e6218ddda539194cf00afe01b89ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the ECC error information for the specified memtype and interrupt source.  <a href="group__SDL__ECC__AGGR__FUNCTION.html#gac2e6218ddda539194cf00afe01b89ae7">More...</a><br /></td></tr>
<tr class="separator:gac2e6218ddda539194cf00afe01b89ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63ba6397a440a3a47dfb975bba0d9acb"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga63ba6397a440a3a47dfb975bba0d9acb">SDL_ECC_ackIntr</a> (<a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac233021d13f25dc397424af5b5bdc28b">SDL_ECC_MemType</a> eccMemType, <a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a> intrSrc)</td></tr>
<tr class="memdesc:ga63ba6397a440a3a47dfb975bba0d9acb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acknowledge the ECC interrupt.  <a href="group__SDL__ECC__AGGR__FUNCTION.html#ga63ba6397a440a3a47dfb975bba0d9acb">More...</a><br /></td></tr>
<tr class="separator:ga63ba6397a440a3a47dfb975bba0d9acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36463b8cc63856b9f93444a4437bfe28"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga36463b8cc63856b9f93444a4437bfe28">SDL_ECC_getESMErrorInfo</a> (SDL_ESM_Inst instance, uint32_t intSrc, <a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac233021d13f25dc397424af5b5bdc28b">SDL_ECC_MemType</a> *eccMemType, <a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a> *intrSrcType)</td></tr>
<tr class="memdesc:ga36463b8cc63856b9f93444a4437bfe28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the ECC error information for the specified ESM error. If it isn't an ECC error or the ECC error is not supported an error is returned.  <a href="group__SDL__ECC__AGGR__FUNCTION.html#ga36463b8cc63856b9f93444a4437bfe28">More...</a><br /></td></tr>
<tr class="separator:ga36463b8cc63856b9f93444a4437bfe28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fbb744d3c79356a24aeb3e896a057ae"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga7fbb744d3c79356a24aeb3e896a057ae">SDL_ECC_clearNIntrPending</a> (<a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac233021d13f25dc397424af5b5bdc28b">SDL_ECC_MemType</a> eccMemType, <a class="el" href="group__SDL__ECC__AGGR__ENUM.html#ga0d731a39964dd93567cb3532002243b9">SDL_ECC_MemSubType</a> memSubType, <a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a> intrSrc, <a class="el" href="group__SDL__ECC__AGGR__ENUM.html#ga6dffb98cb4d267d06430adec7bba1b6b">SDL_Ecc_AggrEDCErrorSubType</a> subType, uint32_t numEvents)</td></tr>
<tr class="memdesc:ga7fbb744d3c79356a24aeb3e896a057ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears N pending interrupts for the specified memtype, subtype and interrupt source.  <a href="group__SDL__ECC__AGGR__FUNCTION.html#ga7fbb744d3c79356a24aeb3e896a057ae">More...</a><br /></td></tr>
<tr class="separator:ga7fbb744d3c79356a24aeb3e896a057ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fe8bc6715b26c8cdbfd50eae3aa8603"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga2fe8bc6715b26c8cdbfd50eae3aa8603">SDL_ECC_applicationCallbackFunction</a> (<a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac233021d13f25dc397424af5b5bdc28b">SDL_ECC_MemType</a> eccMemType, uint32_t errorSrc, uint32_t address, uint32_t ramId, uint64_t bitErrorOffset, uint32_t bitErrorGroup)</td></tr>
<tr class="memdesc:ga2fe8bc6715b26c8cdbfd50eae3aa8603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Application provided external callback function for ECC handling Called inside the reference functions when ECC errors occur. NOTE: This is application supplied and not part of the SDL If not supplied by application this will result in an linker error.  <a href="group__SDL__ECC__AGGR__FUNCTION.html#ga2fe8bc6715b26c8cdbfd50eae3aa8603">More...</a><br /></td></tr>
<tr class="separator:ga2fe8bc6715b26c8cdbfd50eae3aa8603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3f817729da0420dfbe181dcac7f2471"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gae3f817729da0420dfbe181dcac7f2471">SDL_ECC_tpccParity</a> (<a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac233021d13f25dc397424af5b5bdc28b">SDL_ECC_MemType</a> eccMemType, uint32_t bitValue, uint32_t paramregvalue, uint32_t regval)</td></tr>
<tr class="memdesc:gae3f817729da0420dfbe181dcac7f2471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Injects TPCC Parity error.  <a href="group__SDL__ECC__AGGR__FUNCTION.html#gae3f817729da0420dfbe181dcac7f2471">More...</a><br /></td></tr>
<tr class="separator:gae3f817729da0420dfbe181dcac7f2471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga487ebb75e9964e49260817e5cb080d7d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga487ebb75e9964e49260817e5cb080d7d">SDL_ecc_aggrGetRevision</a> (const <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t *pRev)</td></tr>
<tr class="separator:ga487ebb75e9964e49260817e5cb080d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd92b4adf0d5805df18662b1e1c5cd92"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams</a> (const <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t *pNumRams)</td></tr>
<tr class="separator:gafd92b4adf0d5805df18662b1e1c5cd92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cdd85d792ede784563f8670b43cdf32"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga8cdd85d792ede784563f8670b43cdf32">SDL_ecc_aggrReadEccRamReg</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, uint32_t regOffset, uint32_t *pRegVal)</td></tr>
<tr class="separator:ga8cdd85d792ede784563f8670b43cdf32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bcf28a806952abc7ed596a045c04e96"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga4bcf28a806952abc7ed596a045c04e96">SDL_ecc_aggrReadEccRamWrapRevReg</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, uint32_t *pRegVal)</td></tr>
<tr class="separator:ga4bcf28a806952abc7ed596a045c04e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54f6fb74b621f7eab5f62392543bb3c6"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga54f6fb74b621f7eab5f62392543bb3c6">SDL_ecc_aggrReadEccRamCtrlReg</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, uint32_t *pRegVal)</td></tr>
<tr class="separator:ga54f6fb74b621f7eab5f62392543bb3c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59d2dd49c4c93da9a9bef8c979e6c3e8"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga59d2dd49c4c93da9a9bef8c979e6c3e8">SDL_ecc_aggrReadEccRamErrCtrlReg</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, uint32_t instSelect, uint32_t *pRegVal)</td></tr>
<tr class="separator:ga59d2dd49c4c93da9a9bef8c979e6c3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36c25ecf06d00cb6451b7cc4ce6056a8"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga36c25ecf06d00cb6451b7cc4ce6056a8">SDL_ecc_aggrReadEccRamErrStatReg</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, uint32_t instSelect, uint32_t *pRegVal)</td></tr>
<tr class="separator:ga36c25ecf06d00cb6451b7cc4ce6056a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79a143607703eb825b82b2ae4f21b649"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga79a143607703eb825b82b2ae4f21b649">SDL_ecc_aggrWriteEccRamReg</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, uint32_t regOffset, uint32_t val)</td></tr>
<tr class="separator:ga79a143607703eb825b82b2ae4f21b649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb77ded1c6fced05669f36d80b1cd4e0"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gadb77ded1c6fced05669f36d80b1cd4e0">SDL_ecc_aggrWriteEccRamCtrlReg</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, uint32_t val)</td></tr>
<tr class="separator:gadb77ded1c6fced05669f36d80b1cd4e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71bae87a953387630c5d686d15c234f9"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga71bae87a953387630c5d686d15c234f9">SDL_ecc_aggrWriteEccRamErrCtrlReg</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, uint32_t instSelect, uint32_t val)</td></tr>
<tr class="separator:ga71bae87a953387630c5d686d15c234f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed30558bf07c131f4ef70a104b9c75fb"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gaed30558bf07c131f4ef70a104b9c75fb">SDL_ecc_aggrWriteEccRamErrStatReg</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, uint32_t instSelect, uint32_t val)</td></tr>
<tr class="separator:gaed30558bf07c131f4ef70a104b9c75fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59f6dc0f4ee61957129476dcf2989ac0"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga59f6dc0f4ee61957129476dcf2989ac0">SDL_ecc_aggrConfigEccRam</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, bool bEnable, bool bEccCheck, bool bEnableRMW)</td></tr>
<tr class="separator:ga59f6dc0f4ee61957129476dcf2989ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2193fa2fc3659092468fd3f7d34b287"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gaf2193fa2fc3659092468fd3f7d34b287">SDL_ecc_aggrVerifyConfigEccRam</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, bool bEnable, bool bEccCheck, bool bEnableRMW)</td></tr>
<tr class="separator:gaf2193fa2fc3659092468fd3f7d34b287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53ae9672250cc052634421b34de0331d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga53ae9672250cc052634421b34de0331d">SDL_ecc_aggrGetEccRamErrorStatus</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, <a class="el" href="structSDL__Ecc__AggrEccRamErrorStatusInfo.html">SDL_Ecc_AggrEccRamErrorStatusInfo</a> *pEccErrorStatus)</td></tr>
<tr class="separator:ga53ae9672250cc052634421b34de0331d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a8b03aaf8e509fcf60aa363dcb93fbb"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga8a8b03aaf8e509fcf60aa363dcb93fbb">SDL_ecc_aggrForceEccRamError</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, const <a class="el" href="structSDL__Ecc__AggrErrorInfo.html">SDL_Ecc_AggrErrorInfo</a> *pEccForceError)</td></tr>
<tr class="separator:ga8a8b03aaf8e509fcf60aa363dcb93fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3d7dd50b8746a91d710fc804e6c7f4f"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gaa3d7dd50b8746a91d710fc804e6c7f4f">SDL_ecc_aggrAckIntr</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, <a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a> intrSrc)</td></tr>
<tr class="separator:gaa3d7dd50b8746a91d710fc804e6c7f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga415b73a48902d7d2263f7b1ede627780"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga415b73a48902d7d2263f7b1ede627780">SDL_ecc_aggrIsEccRamIntrPending</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, <a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a> intrSrc, bool *pIsPend)</td></tr>
<tr class="separator:ga415b73a48902d7d2263f7b1ede627780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8320e329b155a7e8e13104509a010671"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga8320e329b155a7e8e13104509a010671">SDL_ecc_aggrSetEccRamIntrPending</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, <a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a> intrSrc)</td></tr>
<tr class="separator:ga8320e329b155a7e8e13104509a010671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4ea124c43807001101e9aa63d0c521c"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gac4ea124c43807001101e9aa63d0c521c">SDL_ecc_aggrSetEccRamNIntrPending</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, <a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a> intrSrc, uint32_t numEvents)</td></tr>
<tr class="separator:gac4ea124c43807001101e9aa63d0c521c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1371231c7a8bb6d9b501bec2bc0363f3"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga1371231c7a8bb6d9b501bec2bc0363f3">SDL_ecc_aggrClrEccRamIntrPending</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, <a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a> intrSrc)</td></tr>
<tr class="separator:ga1371231c7a8bb6d9b501bec2bc0363f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2a1abd9224641cb30ccbfa487676539"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gae2a1abd9224641cb30ccbfa487676539">SDL_ecc_aggrClrEccRamNIntrPending</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, <a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a> intrSrc, uint32_t numEvents)</td></tr>
<tr class="separator:gae2a1abd9224641cb30ccbfa487676539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e879da096e53d75be140c185280e91c"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga7e879da096e53d75be140c185280e91c">SDL_ecc_aggrIsIntrPending</a> (const <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, <a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a> intrSrc, bool *pIsPend)</td></tr>
<tr class="separator:ga7e879da096e53d75be140c185280e91c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3228be72cf5ae3a8a29b9568a6709d37"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga3228be72cf5ae3a8a29b9568a6709d37">SDL_ecc_aggrIsAnyIntrPending</a> (const <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, bool *pIsPend)</td></tr>
<tr class="separator:ga3228be72cf5ae3a8a29b9568a6709d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf59636079aff6ba0368615abee362d66"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gaf59636079aff6ba0368615abee362d66">SDL_ecc_aggrEnableIntr</a> (const <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, <a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a> intrSrc)</td></tr>
<tr class="separator:gaf59636079aff6ba0368615abee362d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga181414a69152a8365a694bd8188fbcc5"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga181414a69152a8365a694bd8188fbcc5">SDL_ecc_aggrDisableIntr</a> (const <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, <a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a> intrSrc)</td></tr>
<tr class="separator:ga181414a69152a8365a694bd8188fbcc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c91cbaa03176e6debbe719c9e0ede79"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga5c91cbaa03176e6debbe719c9e0ede79">SDL_ecc_aggrEnableAllIntr</a> (const <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId)</td></tr>
<tr class="separator:ga5c91cbaa03176e6debbe719c9e0ede79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga122b80435ec40e0c48338f0277d85c52"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga122b80435ec40e0c48338f0277d85c52">SDL_ecc_aggrDisableAllIntr</a> (const <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId)</td></tr>
<tr class="separator:ga122b80435ec40e0c48338f0277d85c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2e801ae78ea619187cbdce792cfe35b"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gad2e801ae78ea619187cbdce792cfe35b">SDL_ecc_aggrEnableIntrs</a> (const <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, <a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a> intrSrc)</td></tr>
<tr class="separator:gad2e801ae78ea619187cbdce792cfe35b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb6719881e9194c28fb4cf1be7cd9170"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gacb6719881e9194c28fb4cf1be7cd9170">SDL_ecc_aggrDisableIntrs</a> (const <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, <a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a> intrSrc)</td></tr>
<tr class="separator:gacb6719881e9194c28fb4cf1be7cd9170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga555808e1bf039ab2222e7fb94a606f7b"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga555808e1bf039ab2222e7fb94a606f7b">SDL_ecc_aggrEnableAllIntrs</a> (const <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs)</td></tr>
<tr class="separator:ga555808e1bf039ab2222e7fb94a606f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b47f308f8ae4660723caf125a73f960"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga0b47f308f8ae4660723caf125a73f960">SDL_ecc_aggrDisableAllIntrs</a> (const <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs)</td></tr>
<tr class="separator:ga0b47f308f8ae4660723caf125a73f960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa566e02e16ebbb5355649a2706bf44e0"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gaa566e02e16ebbb5355649a2706bf44e0">SDL_ecc_aggrReadStaticRegs</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, <a class="el" href="structSDL__ECC__staticRegs.html">SDL_ECC_staticRegs</a> *pEccAggrStaticRegs)</td></tr>
<tr class="separator:gaa566e02e16ebbb5355649a2706bf44e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6c8ec50211c9b8485e2fc2b4076e34c"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gae6c8ec50211c9b8485e2fc2b4076e34c">SDL_ecc_aggrIntrEnableCtrl</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, const <a class="el" href="structSDL__ecc__aggrEnableCtrl.html">SDL_ecc_aggrEnableCtrl</a> *pEnableCtrl)</td></tr>
<tr class="separator:gae6c8ec50211c9b8485e2fc2b4076e34c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga315328ad1eda006e9c8729ad81fb2cb9"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga315328ad1eda006e9c8729ad81fb2cb9">SDL_ecc_aggrIntrStatusCtrl</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, const <a class="el" href="structSDL__ecc__aggrStatusCtrl.html">SDL_ecc_aggrStatusCtrl</a> *pStatusCtrl)</td></tr>
<tr class="separator:ga315328ad1eda006e9c8729ad81fb2cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fcf84d60a080c7f339f4e0d300cce4b"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga7fcf84d60a080c7f339f4e0d300cce4b">SDL_ecc_aggrIntrGetStatus</a> (const <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, <a class="el" href="structSDL__ecc__aggrStatusCtrl.html">SDL_ecc_aggrStatusCtrl</a> *pStatusCtrl)</td></tr>
<tr class="separator:ga7fcf84d60a080c7f339f4e0d300cce4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga1f7466c9a2745c342e9bf9b20f64f6f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f7466c9a2745c342e9bf9b20f64f6f5">&#9670;&nbsp;</a></span>SDL_ECC_initEsm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ECC_initEsm </td>
          <td>(</td>
          <td class="paramtype">const SDL_ESM_Inst&#160;</td>
          <td class="paramname"><em>esmInstType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an module for usage with ECC module. </p>
<p>============================================================================*</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">esmInstType</td><td>Instance of</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SDL_PASS : Success; SDL_FAIL for failures </dd></dl>

</div>
</div>
<a id="ga5a3e77d0089427bae4e0ce94cdf0b143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a3e77d0089427bae4e0ce94cdf0b143">&#9670;&nbsp;</a></span>SDL_ECC_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ECC_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac233021d13f25dc397424af5b5bdc28b">SDL_ECC_MemType</a>&#160;</td>
          <td class="paramname"><em>eccMemType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSDL__ECC__InitConfig__t.html">SDL_ECC_InitConfig_t</a> *&#160;</td>
          <td class="paramname"><em>pECCInitConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes ECC module for ECC detection. </p>
<p>============================================================================*</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eccMemType</td><td>ECC memory type </td></tr>
    <tr><td class="paramname">pECCInitConfig</td><td>Pointer to Ecc init configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SDL_PASS : Success; SDL_FAIL for failuresn </dd></dl>

</div>
</div>
<a id="gab6846e8345f036e70e2e3643697a951f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6846e8345f036e70e2e3643697a951f">&#9670;&nbsp;</a></span>SDL_ECC_initMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ECC_initMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac233021d13f25dc397424af5b5bdc28b">SDL_ECC_MemType</a>&#160;</td>
          <td class="paramname"><em>eccMemType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SDL__ECC__AGGR__ENUM.html#ga0d731a39964dd93567cb3532002243b9">SDL_ECC_MemSubType</a>&#160;</td>
          <td class="paramname"><em>memSubType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes Memory to be ready for ECC error detection. Assumes ECC is already enabled. </p>
<p>============================================================================</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eccMemType</td><td>ECC memory type </td></tr>
    <tr><td class="paramname">memSubType</td><td>Memory subtype</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SDL_PASS : Success; SDL_FAIL for failures </dd></dl>

</div>
</div>
<a id="gadc37c3496c3c42b4b3473840f04ba069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc37c3496c3c42b4b3473840f04ba069">&#9670;&nbsp;</a></span>SDL_ECC_selfTest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ECC_selfTest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac233021d13f25dc397424af5b5bdc28b">SDL_ECC_MemType</a>&#160;</td>
          <td class="paramname"><em>eccMemType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SDL__ECC__AGGR__ENUM.html#ga0d731a39964dd93567cb3532002243b9">SDL_ECC_MemSubType</a>&#160;</td>
          <td class="paramname"><em>memSubType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SDL__ECC__AGGR__ENUM.html#ga2fb3569c964c0a156c36f52bd4f0ac86">SDL_ECC_InjectErrorType</a>&#160;</td>
          <td class="paramname"><em>errorType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSDL__ECC__InjectErrorConfig__t.html">SDL_ECC_InjectErrorConfig_t</a> *&#160;</td>
          <td class="paramname"><em>pECCErrorConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>selfTestTimeOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs self test by injecting and error and monitor response Assumes ECC is already enabled. </p>
<p>============================================================================</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eccMemType</td><td>ECC memory type </td></tr>
    <tr><td class="paramname">memSubType</td><td>Memory subtype </td></tr>
    <tr><td class="paramname">errorType</td><td>ECC Self test type </td></tr>
    <tr><td class="paramname">pECCErrorConfig</td><td>Pointer to Error configuration </td></tr>
    <tr><td class="paramname">selfTestTimeOut</td><td>Number of retries before time out</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SDL_PASS : Success; SDL_FAIL for failures </dd></dl>

</div>
</div>
<a id="gaf5979274875023a443b27b3b01168f27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5979274875023a443b27b3b01168f27">&#9670;&nbsp;</a></span>SDL_ECC_injectError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ECC_injectError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac233021d13f25dc397424af5b5bdc28b">SDL_ECC_MemType</a>&#160;</td>
          <td class="paramname"><em>eccMemType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SDL__ECC__AGGR__ENUM.html#ga0d731a39964dd93567cb3532002243b9">SDL_ECC_MemSubType</a>&#160;</td>
          <td class="paramname"><em>memSubType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SDL__ECC__AGGR__ENUM.html#ga2fb3569c964c0a156c36f52bd4f0ac86">SDL_ECC_InjectErrorType</a>&#160;</td>
          <td class="paramname"><em>errorType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSDL__ECC__InjectErrorConfig__t.html">SDL_ECC_InjectErrorConfig_t</a> *&#160;</td>
          <td class="paramname"><em>pECCErrorConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Injects ECC error at specified location Assumes ECC is already enabled. </p>
<p>============================================================================</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eccMemType</td><td>ECC memory type </td></tr>
    <tr><td class="paramname">memSubType</td><td>Memory subtype </td></tr>
    <tr><td class="paramname">errorType</td><td>ECC error type </td></tr>
    <tr><td class="paramname">pECCErrorConfig</td><td>Pointer to Error configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SDL_PASS : Success; SDL_FAIL for failures </dd></dl>

</div>
</div>
<a id="ga76910b19baf40bd7c85e7e77e08b548f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76910b19baf40bd7c85e7e77e08b548f">&#9670;&nbsp;</a></span>SDL_ECC_getStaticRegisters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ECC_getStaticRegisters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac233021d13f25dc397424af5b5bdc28b">SDL_ECC_MemType</a>&#160;</td>
          <td class="paramname"><em>eccMemType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSDL__ECC__staticRegs.html">SDL_ECC_staticRegs</a> *&#160;</td>
          <td class="paramname"><em>pStaticRegs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the static registers for the specified ECC instance. </p>
<p>============================================================================</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eccMemType</td><td>ECC memory type </td></tr>
    <tr><td class="paramname">pStaticRegs</td><td>Pointer to Static registers structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SDL_PASS : Success; SDL_FAIL for failures </dd></dl>

</div>
</div>
<a id="gac2e6218ddda539194cf00afe01b89ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2e6218ddda539194cf00afe01b89ae7">&#9670;&nbsp;</a></span>SDL_ECC_getErrorInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ECC_getErrorInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac233021d13f25dc397424af5b5bdc28b">SDL_ECC_MemType</a>&#160;</td>
          <td class="paramname"><em>eccMemType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a>&#160;</td>
          <td class="paramname"><em>intrSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSDL__ECC__ErrorInfo__t.html">SDL_ECC_ErrorInfo_t</a> *&#160;</td>
          <td class="paramname"><em>pErrorInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the ECC error information for the specified memtype and interrupt source. </p>
<p>============================================================================</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eccMemType</td><td>ECC memory type </td></tr>
    <tr><td class="paramname">intrSrc</td><td>interrupt source </td></tr>
    <tr><td class="paramname">pErrorInfo</td><td>Pointer to the Error Information</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SDL_PASS : Success; SDL_FAIL for failures </dd></dl>

</div>
</div>
<a id="ga63ba6397a440a3a47dfb975bba0d9acb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63ba6397a440a3a47dfb975bba0d9acb">&#9670;&nbsp;</a></span>SDL_ECC_ackIntr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ECC_ackIntr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac233021d13f25dc397424af5b5bdc28b">SDL_ECC_MemType</a>&#160;</td>
          <td class="paramname"><em>eccMemType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a>&#160;</td>
          <td class="paramname"><em>intrSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acknowledge the ECC interrupt. </p>
<p>============================================================================</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eccMemType</td><td>ECC memory type </td></tr>
    <tr><td class="paramname">intrSrc</td><td>interrupt source</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SDL_PASS : Success; SDL_FAIL for failures </dd></dl>

</div>
</div>
<a id="ga36463b8cc63856b9f93444a4437bfe28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36463b8cc63856b9f93444a4437bfe28">&#9670;&nbsp;</a></span>SDL_ECC_getESMErrorInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ECC_getESMErrorInfo </td>
          <td>(</td>
          <td class="paramtype">SDL_ESM_Inst&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac233021d13f25dc397424af5b5bdc28b">SDL_ECC_MemType</a> *&#160;</td>
          <td class="paramname"><em>eccMemType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a> *&#160;</td>
          <td class="paramname"><em>intrSrcType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the ECC error information for the specified ESM error. If it isn't an ECC error or the ECC error is not supported an error is returned. </p>
<p>============================================================================</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>ESM instance </td></tr>
    <tr><td class="paramname">intSrc</td><td>ESM interrupt number </td></tr>
    <tr><td class="paramname">eccMemType</td><td>Pointer to the ECC memory type </td></tr>
    <tr><td class="paramname">intrSrcType</td><td>Pointer to the interrupt source type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SDL_PASS : Success; SDL_FAIL for failures </dd></dl>

</div>
</div>
<a id="ga7fbb744d3c79356a24aeb3e896a057ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fbb744d3c79356a24aeb3e896a057ae">&#9670;&nbsp;</a></span>SDL_ECC_clearNIntrPending()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ECC_clearNIntrPending </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac233021d13f25dc397424af5b5bdc28b">SDL_ECC_MemType</a>&#160;</td>
          <td class="paramname"><em>eccMemType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SDL__ECC__AGGR__ENUM.html#ga0d731a39964dd93567cb3532002243b9">SDL_ECC_MemSubType</a>&#160;</td>
          <td class="paramname"><em>memSubType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a>&#160;</td>
          <td class="paramname"><em>intrSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SDL__ECC__AGGR__ENUM.html#ga6dffb98cb4d267d06430adec7bba1b6b">SDL_Ecc_AggrEDCErrorSubType</a>&#160;</td>
          <td class="paramname"><em>subType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numEvents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears N pending interrupts for the specified memtype, subtype and interrupt source. </p>
<p>============================================================================</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eccMemType</td><td>ECC memory type </td></tr>
    <tr><td class="paramname">memSubType</td><td>Memory subtype </td></tr>
    <tr><td class="paramname">intrSrc</td><td>interrupt source </td></tr>
    <tr><td class="paramname">subType</td><td>error subtype (valid for EDC types only) </td></tr>
    <tr><td class="paramname">numEvents</td><td>number of pending interrupts to clear</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SDL_PASS : Success; SDL_FAIL for failures </dd></dl>

</div>
</div>
<a id="ga2fe8bc6715b26c8cdbfd50eae3aa8603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2fe8bc6715b26c8cdbfd50eae3aa8603">&#9670;&nbsp;</a></span>SDL_ECC_applicationCallbackFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SDL_ECC_applicationCallbackFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac233021d13f25dc397424af5b5bdc28b">SDL_ECC_MemType</a>&#160;</td>
          <td class="paramname"><em>eccMemType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>errorSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>bitErrorOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bitErrorGroup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Application provided external callback function for ECC handling Called inside the reference functions when ECC errors occur. NOTE: This is application supplied and not part of the SDL If not supplied by application this will result in an linker error. </p>
<p>============================================================================</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eccMemType</td><td>ECC Memory Type </td></tr>
    <tr><td class="paramname">errorSrc</td><td>Error source for the ECC error event. </td></tr>
    <tr><td class="paramname">address</td><td>Address at which the ECC error occurred. </td></tr>
    <tr><td class="paramname">ramId</td><td>RAM ID at which the ECC error occurred. </td></tr>
    <tr><td class="paramname">bitErrorOffset</td><td>Offset at which the ECC error occurred. </td></tr>
    <tr><td class="paramname">bitErrorGroup</td><td>group checker that reported the error (Interconnect ECC type only). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae3f817729da0420dfbe181dcac7f2471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3f817729da0420dfbe181dcac7f2471">&#9670;&nbsp;</a></span>SDL_ECC_tpccParity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ECC_tpccParity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac233021d13f25dc397424af5b5bdc28b">SDL_ECC_MemType</a>&#160;</td>
          <td class="paramname"><em>eccMemType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bitValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>paramregvalue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>regval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Injects TPCC Parity error. </p>
<p>============================================================================</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eccMemType</td><td>Memory type for ECC AGGR </td></tr>
    <tr><td class="paramname">bitValue</td><td>: Bit Value to set particular register </td></tr>
    <tr><td class="paramname">paramregvalue</td><td>select param register </td></tr>
    <tr><td class="paramname">regval</td><td>: value to be written into param register </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SDL_PASS : Success; SDL_EFAIL for failures </dd></dl>

</div>
</div>
<a id="ga487ebb75e9964e49260817e5cb080d7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga487ebb75e9964e49260817e5cb080d7d">&#9670;&nbsp;</a></span>SDL_ecc_aggrGetRevision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrGetRevision </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pRev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrGetRevision</b> </p>
<p><b>Description</b> <br  />
 This function returns the revision information for the ECC Aggregator</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 pRev A pointer (of type uint32_t) to hold the rev ID value of the ECC Aggregator module Revision information. See design specification for details.</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="gafd92b4adf0d5805df18662b1e1c5cd92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd92b4adf0d5805df18662b1e1c5cd92">&#9670;&nbsp;</a></span>SDL_ecc_aggrGetNumRams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrGetNumRams </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pNumRams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrGetNumRams</b> </p>
<p><b>Description</b> <br  />
 This function returns the number of RAMs serviced by this ECC Aggregator</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 pNumRams A pointer (of type uint32_t) to hold the value of number of RAMs serviced by this ECC Aggregator</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="ga8cdd85d792ede784563f8670b43cdf32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8cdd85d792ede784563f8670b43cdf32">&#9670;&nbsp;</a></span>SDL_ecc_aggrReadEccRamReg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrReadEccRamReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>regOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pRegVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrReadEccRamReg</b> </p>
<p><b>Description</b> <br  />
 This function reads the specified ECC wrapper register from the specific ECC RAM</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1) <br  />
 regOffset Byte offset of the ECC wrapper register to read (must be in the range of 0x10..0x24) <br  />
 pRegVal A pointer (of uint32_t) to hold the value of the specified ECC wrapper register</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the arguments such as ramId and/or regOffset are invalid</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="ga4bcf28a806952abc7ed596a045c04e96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4bcf28a806952abc7ed596a045c04e96">&#9670;&nbsp;</a></span>SDL_ecc_aggrReadEccRamWrapRevReg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrReadEccRamWrapRevReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pRegVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrReadEccRamWrapRevReg</b> </p>
<p><b>Description</b> <br  />
 This function reads the ECC wrapper revision register from the specific ECC RAM</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1)</p>
<p><br  />
 pRegVal A pointer (of type uint32_t) to hold the value of the ECC wrapper revision register</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="ga54f6fb74b621f7eab5f62392543bb3c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54f6fb74b621f7eab5f62392543bb3c6">&#9670;&nbsp;</a></span>SDL_ecc_aggrReadEccRamCtrlReg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrReadEccRamCtrlReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pRegVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrReadEccRamCtrlReg</b> </p>
<p><b>Description</b> <br  />
 This function reads the specified ECC wrapper control register from the specific ECC RAM</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1)</p>
<p><br  />
 pRegVal A pointer (of type uint32_t) to hold the value of the ECC control register</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="ga59d2dd49c4c93da9a9bef8c979e6c3e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59d2dd49c4c93da9a9bef8c979e6c3e8">&#9670;&nbsp;</a></span>SDL_ecc_aggrReadEccRamErrCtrlReg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrReadEccRamErrCtrlReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instSelect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pRegVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrReadEccRamErrCtrlReg</b> </p>
<p><b>Description</b> <br  />
 This function reads the specified ECC wrapper error control register from the specific ECC RAM</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1) <br  />
 instSelect Instance selector (0..1) of the specified register to read</p>
<p><br  />
 pRegVal A pointer (of type uint32_t) to hold the value of the ECC Error control register</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments </p>

</div>
</div>
<a id="ga36c25ecf06d00cb6451b7cc4ce6056a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36c25ecf06d00cb6451b7cc4ce6056a8">&#9670;&nbsp;</a></span>SDL_ecc_aggrReadEccRamErrStatReg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrReadEccRamErrStatReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instSelect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pRegVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrReadEccRamErrStatReg</b> </p>
<p><b>Description</b> <br  />
 This function reads the specified ECC wrapper error status register from the specific ECC RAM</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1) <br  />
 instSelect Instance selector (0..1) of the specified register to read</p>
<p><br  />
 pRegVal A pointer (of type uint32_t) to hold the value of the ECC error status register</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments </p>

</div>
</div>
<a id="ga79a143607703eb825b82b2ae4f21b649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79a143607703eb825b82b2ae4f21b649">&#9670;&nbsp;</a></span>SDL_ecc_aggrWriteEccRamReg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrWriteEccRamReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>regOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrWriteEccRamReg</b> </p>
<p><b>Description</b> <br  />
 This function writes a value into the specified ECC wrapper register in the specific ECC RAM</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1) <br  />
 regOffset Byte offset of the ECC wrapper register to write (must be in the range of 0x10..0x24) <br  />
 val The 32-bit value to write into the register</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="gadb77ded1c6fced05669f36d80b1cd4e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb77ded1c6fced05669f36d80b1cd4e0">&#9670;&nbsp;</a></span>SDL_ecc_aggrWriteEccRamCtrlReg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrWriteEccRamCtrlReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrWriteEccRamCtrlReg</b> </p>
<p><b>Description</b> <br  />
 This function write a value into the ECC wrapper control register in the specific ECC RAM</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1) <br  />
 val The 32-bit value to write into the register</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="ga71bae87a953387630c5d686d15c234f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71bae87a953387630c5d686d15c234f9">&#9670;&nbsp;</a></span>SDL_ecc_aggrWriteEccRamErrCtrlReg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrWriteEccRamErrCtrlReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instSelect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrWriteEccRamErrCtrlReg</b> </p>
<p><b>Description</b> <br  />
 This function writes a value into the specified ECC wrapper error control register in the specific ECC RAM</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1) <br  />
 instSelect Instance selector (0..1) of the specified register to write <br  />
 val The 32-bit value to write into the register</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="gaed30558bf07c131f4ef70a104b9c75fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed30558bf07c131f4ef70a104b9c75fb">&#9670;&nbsp;</a></span>SDL_ecc_aggrWriteEccRamErrStatReg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrWriteEccRamErrStatReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instSelect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrWriteEccRamErrStatReg</b> </p>
<p><b>Description</b> <br  />
 This function write a value into the specified ECC wrapper error status register in the specific ECC RAM</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1) <br  />
 instSelect Instance selector (0..1) of the specified register to write <br  />
 val The 32-bit value to write into the register</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="ga59f6dc0f4ee61957129476dcf2989ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59f6dc0f4ee61957129476dcf2989ac0">&#9670;&nbsp;</a></span>SDL_ecc_aggrConfigEccRam()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrConfigEccRam </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEccCheck</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnableRMW</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrConfigEccRam</b> </p>
<p><b>Description</b> <br  />
 This function is used to configure the ECC capabilities of the specified ECC RAM</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1) <br  />
 bEnable If true, then enable ECC generation. ECC is completely bypassed if both fEnable and fEccCheck are 0. <br  />
 bEccCheck If true, then enable ECC check. ECC is completely bypassed if both fEnable and fEccCheck are 0. <br  />
 bfEnableRMW If true, then enable read-modify-write on partial word writes</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="gaf2193fa2fc3659092468fd3f7d34b287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2193fa2fc3659092468fd3f7d34b287">&#9670;&nbsp;</a></span>SDL_ecc_aggrVerifyConfigEccRam()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrVerifyConfigEccRam </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEccCheck</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnableRMW</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrVerifyConfigEccRam</b> </p>
<p><b>Description</b> <br  />
 This function is used to verify the configure the ECC capabilities of the specified ECC RAM</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1) <br  />
 bEnable If true, then enable ECC generation. ECC is completely bypassed if both fEnable and fEccCheck are 0. <br  />
 bEccCheck If true, then enable ECC check. ECC is completely bypassed if both fEnable and fEccCheck are 0. <br  />
 bfEnableRMW If true, then enable read-modify-write on partial word writes</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success, indicates the configuration is successful <br  />
 SDL_EFAIL Failure, indicates the expected configuration failed <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 <a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga59f6dc0f4ee61957129476dcf2989ac0">SDL_ecc_aggrConfigEccRam()</a> is called previously with the same arguments</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="ga53ae9672250cc052634421b34de0331d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53ae9672250cc052634421b34de0331d">&#9670;&nbsp;</a></span>SDL_ecc_aggrGetEccRamErrorStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrGetEccRamErrorStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSDL__Ecc__AggrEccRamErrorStatusInfo.html">SDL_Ecc_AggrEccRamErrorStatusInfo</a> *&#160;</td>
          <td class="paramname"><em>pEccErrorStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrGetEccRamErrorStatus</b> </p>
<p><b>Description</b> <br  />
 This function is used to get the error status of the specified ECC Wrapper type RAM id</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1) <br  />
 pEccErrorStatus A pointer to a <a class="el" href="structSDL__Ecc__AggrEccRamErrorStatusInfo.html" title="This structure contains error status information returned by the SDL_ecc_aggrGetEccRamGetErrorStatus ...">SDL_Ecc_AggrEccRamErrorStatusInfo</a> structure containing returned error information</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="ga8a8b03aaf8e509fcf60aa363dcb93fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a8b03aaf8e509fcf60aa363dcb93fbb">&#9670;&nbsp;</a></span>SDL_ecc_aggrForceEccRamError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrForceEccRamError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSDL__Ecc__AggrErrorInfo.html">SDL_Ecc_AggrErrorInfo</a> *&#160;</td>
          <td class="paramname"><em>pEccForceError</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrForceEccRamError</b> </p>
<p><b>Description</b> <br  />
 This function is used to force an ECC error on the specified ECC Wrapper type RAM id</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1) <br  />
 pEccForceError A pointer to a <a class="el" href="structSDL__Ecc__AggrErrorInfo.html" title="This structure contains error forcing information used by the SDL_ecc_aggrForceEccRamError function.">SDL_Ecc_AggrErrorInfo</a> structure containing force error information</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="gaa3d7dd50b8746a91d710fc804e6c7f4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3d7dd50b8746a91d710fc804e6c7f4f">&#9670;&nbsp;</a></span>SDL_ecc_aggrAckIntr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrAckIntr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a>&#160;</td>
          <td class="paramname"><em>intrSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrAckIntr</b> </p>
<p><b>Description</b> <br  />
 This function is used to acknowledged a pending interrupt and to send the next interrupt to the host</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 intrSrc The interrupt source (SDL_ECC_AGGR_INTR_SRC_SINGLE_BIT or SDL_ECC_AGGR_INTR_SRC_DOUBLE_BIT) to acknowledge</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="ga415b73a48902d7d2263f7b1ede627780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga415b73a48902d7d2263f7b1ede627780">&#9670;&nbsp;</a></span>SDL_ecc_aggrIsEccRamIntrPending()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrIsEccRamIntrPending </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a>&#160;</td>
          <td class="paramname"><em>intrSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>pIsPend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrIsEccRamIntrPending</b> </p>
<p><b>Description</b> <br  />
 This function returns the pending interrupt status of the specified interrupt source from the specified ECC RAM</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1) <br  />
 intrSrc The interrupt source (SDL_ECC_AGGR_INTR_SRC_SINGLE_BIT, SDL_ECC_AGGR_INTR_SRC_DOUBLE_BIT, or SDL_ECC_ADDR_ERROR_TYPE_SUCCESSIVE_SINGLE_BITS)</p>
<p><br  />
 pIsPend A Pointer (of type bool) to hold the state as below true An interrupt of the specified type is pending false An interrupt of the specified type is not pending, or the ramId and/or intrSrc arguments are invalid</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="ga8320e329b155a7e8e13104509a010671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8320e329b155a7e8e13104509a010671">&#9670;&nbsp;</a></span>SDL_ecc_aggrSetEccRamIntrPending()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrSetEccRamIntrPending </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a>&#160;</td>
          <td class="paramname"><em>intrSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrSetEccRamIntrPending</b> </p>
<p><b>Description</b> <br  />
 This function is used to forceably set the pending status of the specified interrupt source on the specified ECC RAM</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1) <br  />
 intrSrc The interrupt source (SDL_ECC_AGGR_INTR_SRC_SINGLE_BIT, SDL_ECC_AGGR_INTR_SRC_DOUBLE_BIT, or SDL_ECC_ADDR_ERROR_TYPE_SUCCESSIVE_SINGLE_BITS)</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="gac4ea124c43807001101e9aa63d0c521c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4ea124c43807001101e9aa63d0c521c">&#9670;&nbsp;</a></span>SDL_ecc_aggrSetEccRamNIntrPending()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrSetEccRamNIntrPending </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a>&#160;</td>
          <td class="paramname"><em>intrSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numEvents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrSetEccRamNIntrPending</b> </p>
<p><b>Description</b> <br  />
 This function is used to forceably set the pending status of the specified interrupt source on the specified ECC RAM Note that multiple events can be triggerred in one call.</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1) <br  />
 intrSrc The interrupt source (SDL_ECC_AGGR_INTR_SRC_SINGLE_BIT, SDL_ECC_AGGR_INTR_SRC_DOUBLE_BIT, or SDL_ECC_ADDR_ERROR_TYPE_SUCCESSIVE_SINGLE_BITS) <br  />
 numEvents 1 - 3 are valid number of events to set; 0 or &gt; 3 invalid.</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="ga1371231c7a8bb6d9b501bec2bc0363f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1371231c7a8bb6d9b501bec2bc0363f3">&#9670;&nbsp;</a></span>SDL_ecc_aggrClrEccRamIntrPending()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrClrEccRamIntrPending </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a>&#160;</td>
          <td class="paramname"><em>intrSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrClrEccRamIntrPending</b> </p>
<p><b>Description</b> <br  />
 This function is used to clear the pending status of the specified interrupt source on the specified ECC RAM</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1) <br  />
 intrSrc The interrupt source (SDL_ECC_AGGR_INTR_SRC_SINGLE_BIT, SDL_ECC_AGGR_INTR_SRC_DOUBLE_BIT, or SDL_ECC_ADDR_ERROR_TYPE_SUCCESSIVE_SINGLE_BITS)</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="gae2a1abd9224641cb30ccbfa487676539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2a1abd9224641cb30ccbfa487676539">&#9670;&nbsp;</a></span>SDL_ecc_aggrClrEccRamNIntrPending()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrClrEccRamNIntrPending </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a>&#160;</td>
          <td class="paramname"><em>intrSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numEvents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrClrEccRamIntrPending</b> </p>
<p><b>Description</b> <br  />
 This function is used to clear the pending status of the specified interrupt source on the specified ECC RAM Note that multiple events can be cleared in one call.</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1) <br  />
 intrSrc The interrupt source (SDL_ECC_AGGR_INTR_SRC_SINGLE_BIT, SDL_ECC_AGGR_INTR_SRC_DOUBLE_BIT, or SDL_ECC_ADDR_ERROR_TYPE_SUCCESSIVE_SINGLE_BITS)</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="ga7e879da096e53d75be140c185280e91c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e879da096e53d75be140c185280e91c">&#9670;&nbsp;</a></span>SDL_ecc_aggrIsIntrPending()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrIsIntrPending </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a>&#160;</td>
          <td class="paramname"><em>intrSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>pIsPend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrIsIntrPending</b> </p>
<p><b>Description</b> <br  />
 This function returns the pending interrupt status for the specified ECC interrupt source from the ECC RAM specified by ramId.</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1) <br  />
 intrSrc The interrupt source (SDL_ECC_AGGR_INTR_SRC_SINGLE_BIT or SDL_ECC_AGGR_INTR_SRC_DOUBLE_BIT; valid only for the SDL_ecc_aggrIsIntrPending function)</p>
<p><br  />
 pIsPend A pointer (of type bool) to hold the status as below true An interrupt of the specified type is pending false An interrupt of the specified type is not pending, or the ramId and/or intrSrc arguments are invalid</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="ga3228be72cf5ae3a8a29b9568a6709d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3228be72cf5ae3a8a29b9568a6709d37">&#9670;&nbsp;</a></span>SDL_ecc_aggrIsAnyIntrPending()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrIsAnyIntrPending </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>pIsPend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrIsAnyIntrPending</b> </p>
<p><b>Description</b> <br  />
 This function returns the pending interrupt status for any interrupt source from the ECC RAM specified by ramId.</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1)</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="gaf59636079aff6ba0368615abee362d66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf59636079aff6ba0368615abee362d66">&#9670;&nbsp;</a></span>SDL_ecc_aggrEnableIntr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrEnableIntr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a>&#160;</td>
          <td class="paramname"><em>intrSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrEnableIntr</b> </p>
<p><b>Description</b> <br  />
 This function enables the interrupt for the specified interrupt source on the RAM specified by ramId</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1) <br  />
 intrSrc The interrupt source (SDL_ECC_AGGR_INTR_SRC_SINGLE_BIT or SDL_ECC_AGGR_INTR_SRC_DOUBLE_BIT)</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="ga181414a69152a8365a694bd8188fbcc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga181414a69152a8365a694bd8188fbcc5">&#9670;&nbsp;</a></span>SDL_ecc_aggrDisableIntr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrDisableIntr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a>&#160;</td>
          <td class="paramname"><em>intrSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrDisableIntr</b> </p>
<p><b>Description</b> <br  />
 This function disables the interrupt for the specified interrupt source on the RAM specified by ramId</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1) <br  />
 intrSrc The interrupt source (SDL_ECC_AGGR_INTR_SRC_SINGLE_BIT or SDL_ECC_AGGR_INTR_SRC_DOUBLE_BIT)</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="ga5c91cbaa03176e6debbe719c9e0ede79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c91cbaa03176e6debbe719c9e0ede79">&#9670;&nbsp;</a></span>SDL_ecc_aggrEnableAllIntr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrEnableAllIntr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrEnableAllIntr</b> </p>
<p><b>Description</b> <br  />
 This function enables the interrupts for all of the available interrupt sources on the RAM specified by ramId</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1)</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicates the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="ga122b80435ec40e0c48338f0277d85c52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga122b80435ec40e0c48338f0277d85c52">&#9670;&nbsp;</a></span>SDL_ecc_aggrDisableAllIntr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrDisableAllIntr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrDisableAllIntr</b> </p>
<p><b>Description</b> <br  />
 This function disables the interrupts for all of the available interrupt sources on the RAM specified by ramId</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1)</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicates the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="gad2e801ae78ea619187cbdce792cfe35b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2e801ae78ea619187cbdce792cfe35b">&#9670;&nbsp;</a></span>SDL_ecc_aggrEnableIntrs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrEnableIntrs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a>&#160;</td>
          <td class="paramname"><em>intrSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrEnableIntrs</b> </p>
<p><b>Description</b> <br  />
 This function enables the interrupt for the specified interrupt source on all ECC RAMs serviced by this aggregator</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 intrSrc The interrupt source (SDL_ECC_AGGR_INTR_SRC_SINGLE_BIT or SDL_ECC_AGGR_INTR_SRC_DOUBLE_BIT)</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicates the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="gacb6719881e9194c28fb4cf1be7cd9170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb6719881e9194c28fb4cf1be7cd9170">&#9670;&nbsp;</a></span>SDL_ecc_aggrDisableIntrs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrDisableIntrs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a>&#160;</td>
          <td class="paramname"><em>intrSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrDisableIntrs</b> </p>
<p><b>Description</b> <br  />
 This function disables the interrupts for the specified interrupt source on all ECC RAMs serviced by this aggregator</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 intrSrc The interrupt source (SDL_ECC_AGGR_INTR_SRC_SINGLE_BIT or SDL_ECC_AGGR_INTR_SRC_DOUBLE_BIT)</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicates the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="ga555808e1bf039ab2222e7fb94a606f7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga555808e1bf039ab2222e7fb94a606f7b">&#9670;&nbsp;</a></span>SDL_ecc_aggrEnableAllIntrs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrEnableAllIntrs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrEnableAllIntrs</b> </p>
<p><b>Description</b> <br  />
 This function enables the interrupts for all of the available interrupt sources on all ECC RAMs serviced by this aggregator</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicates the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="ga0b47f308f8ae4660723caf125a73f960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b47f308f8ae4660723caf125a73f960">&#9670;&nbsp;</a></span>SDL_ecc_aggrDisableAllIntrs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrDisableAllIntrs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrDisableAllIntrs</b> </p>
<p><b>Description</b> <br  />
 This function disables the interrupts for all of the available interrupt sources on all ECC RAMs serviced by this aggregator</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicates the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="gaa566e02e16ebbb5355649a2706bf44e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa566e02e16ebbb5355649a2706bf44e0">&#9670;&nbsp;</a></span>SDL_ecc_aggrReadStaticRegs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrReadStaticRegs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSDL__ECC__staticRegs.html">SDL_ECC_staticRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrStaticRegs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrReadStaticRegs</b> </p>
<p><b>Description</b> <br  />
 This function reads the static registers for ECC aggregator</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 pEccAggrStaticRegs A pointer (of type SDL_ECC_staticRegs*) to hold the static register values</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicates the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="gae6c8ec50211c9b8485e2fc2b4076e34c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6c8ec50211c9b8485e2fc2b4076e34c">&#9670;&nbsp;</a></span>SDL_ecc_aggrIntrEnableCtrl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrIntrEnableCtrl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSDL__ecc__aggrEnableCtrl.html">SDL_ecc_aggrEnableCtrl</a> *&#160;</td>
          <td class="paramname"><em>pEnableCtrl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrIntrEnableCtrl</b> </p>
<p><b>Description</b> <br  />
 This function reads the static registers for ECC aggregator</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 pEnableCtrl A pointer (of type SDL_ecc_aggrEnableCtrl*) to hold the interrupt enable control values</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicates the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="ga315328ad1eda006e9c8729ad81fb2cb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga315328ad1eda006e9c8729ad81fb2cb9">&#9670;&nbsp;</a></span>SDL_ecc_aggrIntrStatusCtrl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrIntrStatusCtrl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSDL__ecc__aggrStatusCtrl.html">SDL_ecc_aggrStatusCtrl</a> *&#160;</td>
          <td class="paramname"><em>pStatusCtrl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrIntrStatusCtrl</b> </p>
<p><b>Description</b> <br  />
 This function writes the ECC Aggregator Status registers for timeout and parity count values</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 pStatusCtrl A pointer (of type SDL_ecc_aggrStatusCtrl*) to hold the interrupt status control and count values</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicates the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="ga7fcf84d60a080c7f339f4e0d300cce4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fcf84d60a080c7f339f4e0d300cce4b">&#9670;&nbsp;</a></span>SDL_ecc_aggrIntrGetStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrIntrGetStatus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrStatusCtrl.html">SDL_ecc_aggrStatusCtrl</a> *&#160;</td>
          <td class="paramname"><em>pStatusCtrl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrIntrGetStatus</b> </p>
<p><b>Description</b> <br  />
 This function reads the ECC Aggregator Status registers for timeout and parity count values</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 pStatusCtrl A pointer (of type SDL_ecc_aggrStatusCtrl*) to read the timeout and parity count values</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicates the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
