<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="shortcut icon" href="favicon.png" type="image/png">    
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<title>AM64x MCU+ SDK: Enet Migration Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<style>
.tinav {
    background: #c00;
    /* height: 41.375px; */
    height: 30px;
    }
</style>    
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
  /* @license-end */
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="AM64x MCU+ SDK"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 40px;">
  <td id="projectlogo"><a href="https://www.ti.com"><img alt="Logo" src="ti_logo.svg"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AM64x MCU+ SDK
   &#160;<span id="projectnumber">10.00.00</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.html" method="get">
              <img id="MSearchSelect" src="search/mag.svg" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
</td>
 </tr>
 </tbody>
</table>
<div class=tinav></div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('enet_migration_guide_top.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Enet Migration Guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#enet_migration_guide_intro">Introduction</a></li>
<li class="level1"><a href="#NeedForSysconfig">Need for sysconfig</a></li>
<li class="level1"><a href="#EnetInitSeqChange">Enet Driver Initialization Sequence Change</a></li>
<li class="level1"><a href="#EnetDmaChOpenChange">Enet DMA channel open changes</a></li>
<li class="level1"><a href="#EnetIoctlChange">Runtime Control API (Enet_ioctl) change</a></li>
<li class="level1"><a href="#PacketTxRxChange">Packet Transmit/Receive API related changes</a><ul><ul><li class="level3"><a href="#autotoc_md2067">Scatter Gather list related change</a></li>
<li class="level3"><a href="#autotoc_md2068">DisableCacheOps related change</a></li>
<li class="level3"><a href="#autotoc_md2069">Checksum offload related change</a></li>
</ul>
</ul>
</li>
<li class="level1"><a href="#CustomBoardSupport">Custom Board Support</a><ul><ul><li class="level3"><a href="#autotoc_md2070">Board config C file</a></li>
<li class="level3"><a href="#autotoc_md2071">Ethernet MAC address Management</a></li>
<li class="level3"><a href="#autotoc_md2072">1. Using Syscfg GUI tool</a></li>
<li class="level3"><a href="#autotoc_md2073">2. Using Custom Board Option</a></li>
</ul>
</ul>
</li>
<li class="level1"><a href="#ExternalPhyManagement">External PHY management</a></li>
<li class="level1"><a href="#MemoryTuningNonLwip">Tuning memory usage of enet driver for non-lwip apps</a></li>
<li class="level1"><a href="#MemoryTuningLwip">Tuning memory usage of enet driver for lwip apps</a></li>
<li class="level1"><a href="#autotoc_md2074">Compatibilty Breaks During MCU+ SDK Version Update</a><ul><li class="level2"><a href="#autotoc_md2075">Updating to version 10.00</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="md_components_networking_enet_lld_enet_migration_guide"></a></p>
<h1><a class="anchor" id="enet_migration_guide_intro"></a>
Introduction</h1>
<hr  />
<p>Enet LLD Migration guide explains the rationale for syscfg integration and the associated changes needed in application</p>
<p><a class="el" href="enet_migration_guide_top.html">Back To Top</a></p>
<h1><a class="anchor" id="NeedForSysconfig"></a>
Need for sysconfig</h1>
<hr  />
<p>Enet LLD enables syscfg based module configuration. This impacts application using enet driver that are migrating from previous releases. The rationale for deep sysconfig integration with enet driver is listed:</p>
<ul>
<li>The Enet LLD driver contains core specific, board specific code. However in MCU+SDK all module libraries can only be SOC+ISA specific. There is no option to have core specific or board specific options when building a library. This required user of enet library to modify enet source code that is not built for the default core/board combo and recompile the enet library. This issue has been addressed by ensuring portions that are core or board specific are part of syscfg template that are compiled as part of application <br  />
</li>
<li>Migrating open params of a module from C based to Sysconfig generated has other advantages:<ul>
<li>Range check for all values at config time instead of runtime parameter checks<ul>
<li>This reduces code size on target by eliminating error checks and minimizes erroneous configuration</li>
</ul>
</li>
<li>Validation checks based on external module configuration like Clock config</li>
<li>Avoid uninitialized members in open params structure<ul>
<li>Syscfg generated code will correctly initialize all members of openParams.</li>
<li>Allows easier migration to new versions and maintain backward compatibility without requiring application code change.<ul>
<li>Although the same is typically done in C code by means of Enet_InitCfg API, the syscfg approach reduces target side code and ensure member initialization even if app fails to invoke Enet_InitCfg API</li>
</ul>
</li>
</ul>
</li>
<li>Allows creation of external module instances needed by enet lld without requiring application integrator to understand enet module external dependency. This simplifies system integration and reduces errors<ul>
<li>UDMA instance is created as shared instance by Enet Module</li>
<li>I2C instances needed for board config can be created as shared instance by Enet Module</li>
<li>PRU instance interrupt configuration for ICSSG can be done by Enet Syscfg Module <br  />
</li>
</ul>
</li>
<li>Allows sizing of data structures in enet driver based on application config<ul>
<li>The number of tx dma channels, rx dma channels, number of enet phy instances, enet resource manager configuration, number of packet buffers etc can be sized correctly based on application usecase rather than sizing them for a worst case if their allocation is determined by syscfg configuration</li>
<li>Enet LLD Driver library is built with close to zero r/w memory footprint<ul>
<li>All data structures needed by EnetLLD drivers are sysconfig generated and sized correctly<ul>
<li>For example : Enet_memInit (Enet LLD function) invokes Enet_memGetCfg (Sysconfig generated code) which returns data structure with number of packets, rings, desc and associated memory that is generated based on application configuration and is right sized</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Syscfg GUI allows presenting options in a scalable manner , showing only relevant options based on config and enables descriptive error msgs for wrong configuration.<ul>
<li>Example of using syscfg GUI to scalably present config options:<ul>
<li>If Enable Packet Pool Allocation option is not selected none of the other packet pool configuration options which are irrelevant are presented to the user <img src="PacketPoolConfig_EnablePacketPoolDisabled.png" alt="" class="inline" title="Enable Packet Pool Allocation Disabled"/>    {html: width=50%}</li>
<li>If Enable Packet Pool Allocation option is enabled the other packet pool configuration options are presented to the user <img src="PacketPoolConfig_EnablePacketPoolEnabled.png" alt="" class="inline" title="Enable Packet Pool Allocation Enabled"/>    {html: width=50%}</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><a class="el" href="enet_migration_guide_top.html">Back To Top</a></p>
<h1><a class="anchor" id="EnetInitSeqChange"></a>
Enet Driver Initialization Sequence Change</h1>
<hr  />
<p>Impact: The init sequence change impacts both ICSSG and CPSW peripherals on all SoCs</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Old Init Sequence  </th><th class="markdownTableHeadLeft">New Init Sequence   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><img src="OldInitSequence_lanes.png" alt="" class="inline" title="OldInitSequence"/>    {html: width=50%}  </td><td class="markdownTableBodyLeft"><img src="NewInitSequence_lanes.png" alt="" class="inline" title="NewInitSequence"/>    {html: width=50%}   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">1.Set default enet osal configuration: <a class="el" href="group__ENET__MAIN__API.html#gac4b4dfb4dbba42909aa63fd568c55046" title="Initialize OSAL configuration.">Enet_initOsalCfg()</a>  </td><td class="markdownTableBodyLeft">1.Implement function EnetApp_updateCpswOpenParams() or EnetApp_updateIcssgOpenParams() depending on peripheral type<br  />
This function allows application to set any Enet openParams as per application requirement   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">2.Set default enet utils configuration: <a class="el" href="group__ENET__MAIN__API.html#ga6370b438a831f249741d3fbd350b8463" title="Initialize utils configuration.">Enet_initUtilsCfg()</a>  </td><td class="markdownTableBodyLeft">2.Implement function EnetApp_initLinkArgs which allows application to set mac and phy params for each macPort enabled   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">3.Init Enet: Enet_init(osalCfg, utilsCfg)  </td><td class="markdownTableBodyLeft">3.Invoke EnetApp_driverOpen(enetType,instId)<br  />
return value of EnetApp_driverOpen is status indicating success/failure   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">4.Set default Enet_openParams <a class="el" href="group__ENET__MAIN__API.html#ga9fa168341383aac623bc20867e79d6b1" title="Initialize the peripheral configuration parameters.">Enet_initCfg()</a>  </td><td class="markdownTableBodyLeft">4.Application can get handle to Enet driver by invoking EnetApp_acquirehandleInfo() function   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">5.Update Enet open params with app specific configuration  </td><td class="markdownTableBodyLeft"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">6.Invoke Enet_open and get handle to Enet driver: hEnet = Enet_open(..openParams)  </td><td class="markdownTableBodyLeft"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">7.For each macPort<br  />
Init mac and phy link params<br  />
Open macPort  </td><td class="markdownTableBodyLeft"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">8.Create PHY state machine task which will periodically invoke Enet_periodicTick  </td><td class="markdownTableBodyLeft"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><a href="./txsg_test_initseq_original.c">txsg_test_initseq_original.c</a>  </td><td class="markdownTableBodyLeft"><a href="./txsg_test_initseq_modified.c">txsg_test_initseq_modified.c</a>   </td></tr>
</table>
<p>Note: If image is not clear please save the png image and zoom</p>
<p><b>Compare txsg_test_initseq_original.c vs txsg_test_initseq_modified.c in a source code comparison tool to see the differences</b></p>
<p><a class="el" href="enet_migration_guide_top.html">Back To Top</a></p>
<h1><a class="anchor" id="EnetDmaChOpenChange"></a>
Enet DMA channel open changes</h1>
<hr  />
<p>Impact: The DMA channel open change impacts both ICSSG and CPSW peripherals on all SoCs</p><ul>
<li>Only applications directly invoke Enet driver packet transmit and receive APIs are impacted<ul>
<li>LWIP based applications are not impacted</li>
</ul>
</li>
</ul>
<p>The <a class="el" href="group__ENET__DMA__API.html#gabca588621f4ee706b03fc679a28f7dab" title="Enet DMA open RX channel.">EnetDma_openRxCh()</a> and <a class="el" href="group__ENET__DMA__API.html#ga307c5cd4018bcbe9d5ed4a68ad45aff4" title="Enet DMA open TX channel.">EnetDma_openTxCh()</a> DMA channel open was previously application callable APIs Applications typically use EnetAppUtils wrapper APIs to open Tx and Rx DMA channels</p><ul>
<li>EnetAppUtils_openTxCh()</li>
<li>EnetAppUtils_openRxCh()</li>
<li>EnetAppUtils_openRxFlow()</li>
<li>EnetAppUtils_openRxFlowForChIdx()</li>
</ul>
<p>Supporting application invocable APIs for Tx and Rx DMA channel open required enet driver to support worst case number for Tx and Rx channels and associated rings,descriptors irrespective of actual number of channels used by application</p>
<p>Most application typically use 1 Tx and 1 Rx channel but the default enet library was built to support upto 8 Tx and 8 Rx channels resulting in wastage of memory</p>
<p>To ensure the DMA channel and associated rings are sized to correct value based on application usecase, DMA channel configuration is now supported via syscfg</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Sysconfig DMA channel config for AM263x/AWR294x/AM273x  </th><th class="markdownTableHeadLeft">Sysconfig DMA channel config for AM243x_AM64x   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><img src="DMA_syscfg_cpdma_socs.png" alt="" class="inline" title="CPDMASyscfg"/>    {html: width=50%}  </td><td class="markdownTableBodyLeft"><img src="DMA_syscfg_udma_socs.png" alt="" class="inline" title="UDMASyscfg"/>    {html: width=50%}   </td></tr>
</table>
<p>All application configurable DMA channels open params that were configurable via APIs EnetAppUtils_openTxCh/ EnetAppUtils_openRxCh are now configurable via syscfg GUI</p><ul>
<li>One Tx and Rx channel are created by default<ul>
<li>If application needs additional Tx and Rx channels it should instantiate additional channels via syscfg<ul>
<li>Refer mcu_plus_sdk/examples/networking/enet_layer2_multi_channel/&lt;soc-platform&gt;/r5fss0-0_freertos/example.syscfg</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>The syscfg generated EnetApp_driverOpen function internally opens all configured DMA channels.</p><ul>
<li>Application can no longer opens DMA channels.</li>
</ul>
<p>Application gets handle to DMA channel by passing the DMA channel instance identifier used in example.syscfg</p><ul>
<li>enet_cpsw1.txDmaChannel[0].$name = "ENET_DMA_TX_CH0" /* Instance identified for Tx Dma channel 0 */</li>
<li>enet_cpsw1.rxDmaChannel[0].$name = "ENET_DMA_RX_CH0" /* Instance identified for Rx Dma channel 0 */</li>
</ul>
<p>To get DMA channel handle application invokes</p><ul>
<li>EnetApp_getTxDmaHandle(ENET_DMA_TX_CH0, &amp;txInArgs, &amp;txChInfo);</li>
<li>EnetApp_getRxDmaHandle(ENET_DMA_RX_CH0, &amp;rxInArgs, &amp;rxChInfo);</li>
</ul>
<p><b>Compare txsg_test_dma_original.c vs txsg_test_dma_modified.c in a source code comparison tool to see the differences</b></p><ul>
<li><a href="./txsg_test_dma_original.c">txsg_test_dma_original.c</a></li>
<li><a href="./txsg_test_dma_modified.c">txsg_test_dma_modified.c</a></li>
</ul>
<p><a class="el" href="enet_migration_guide_top.html">Back To Top</a></p>
<h1><a class="anchor" id="EnetIoctlChange"></a>
Runtime Control API (Enet_ioctl) change</h1>
<hr  />
<p>Impact: The init sequence change impacts both ICSSG and CPSW peripherals on all SoCs</p>
<p>Rationale for change:</p><ul>
<li>Runtime control for Enet driver is supported via Enet_ioctl API call</li>
<li>The Enet_ioctl API takes a CMD and associated params<ul>
<li>Internally the Enet_ioctl was implemented as a switch..case statement .</li>
</ul>
</li>
<li>As all supported IOCTL cmds are implemented as a case statement, the linker will link in code associated with all supported IOCTLs cmd (~300 cmd) irrespective of whether the IOCTL cmd was invoked by application.<ul>
<li>This results in large code size in the final application even though the application may not be using all the IOCTL cmds.</li>
</ul>
</li>
<li>To resolve this issue, the Enet library has been modified to move to a model that ensures only IOCTL cmds invoked by application are linked into the final executable</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Old Enet_ioctl invocation method  </th><th class="markdownTableHeadLeft">New Enet_ioctl invocation method   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">status = Enet_ioctl(hEnet, coreId, IOCTL_CMD, &amp;ioctlPrms);  </td><td class="markdownTableBodyLeft"><a class="el" href="group__ENET__MAIN__API.html#ga239569ec6879e5b5c01390a0e4053c20" title="Helper macro used to first register IOCTL handler and then invoke the IOCTL.">ENET_IOCTL(hEnet, coreId, IOCTL_CMD, &amp;prms, ioctlReturnStatus)</a>;<br  />
ENET_IOCTL is a macro that first registers the handler function for the IOCTL cmd and then invokes the actual Enet_ioctl API.<br  />
This allows linker to link in only IOCTLs used by application into the executable   </td></tr>
</table>
<p><b>Note</b> Do not invoke Enet_ioctl API directly from application.</p><ul>
<li>It should result in compilation error due to missing prototype unless application is wrongly including some enet private header files.<ul>
<li>If Enet_ioctl API is invoked directly you will get a cmd failure</li>
</ul>
</li>
<li>The IOCTL_CMD <em>has</em> to be a ENET_IOCTL cmd enum and cannot be a variable.<ul>
<li>You will face linker error about undefined symbol if you use variable instead of enum for the IOCTL cmd param</li>
</ul>
</li>
</ul>
<p><b>Compare txsg_test_ioctl_original.c vs txsg_test_ioctl_modified.c in a source code comparison tool to see the differences</b></p><ul>
<li><a href="./txsg_test_ioctl_original.c">txsg_test_ioctl_original.c</a></li>
<li><a href="./txsg_test_ioctl_modified.c">txsg_test_ioctl_modified.c</a></li>
</ul>
<p><a class="el" href="enet_migration_guide_top.html">Back To Top</a></p>
<h1><a class="anchor" id="PacketTxRxChange"></a>
Packet Transmit/Receive API related changes</h1>
<hr  />
<h3><a class="anchor" id="autotoc_md2067"></a>
Scatter Gather list related change</h3>
<p>Impact: The Scatter Gather list change impacts CPSW peripherals on AM263x/AM273x/AWR294x</p><ul>
<li>Only applications directly invoke Enet driver packet <a class="el" href="group__ENET__DMA__API.html#gac80790c3fbf88c40ce547c41c6164ae6" title="Submit a queue of ready (full) packets to TX channel.">EnetDma_submitTxPktQ()</a> transmit APIs are impacted<ul>
<li>LWIP based applications are not impacted</li>
</ul>
</li>
</ul>
<p>Rationale for change:</p><ul>
<li>Support for transmit packets to be a scatter-gather list instead of a single contiguous packet has been added in SDK 8.2 release.<ul>
<li>Enabling scatter gather for Tx packets allows zero-copy packet transmission in lwip stack improving transmit throughput</li>
</ul>
</li>
</ul>
<p>EnetDma_Pkt is the packet structure passed to EnetDma_submitTxPktQ (packet transmit) and EnetDma_retrieveRxPktQ (packet receive API)</p><ul>
<li>This structure is modified to support scatter gather.</li>
<li>Application should invoke EnetDma_initPktInfo API to initialize EnetDma_Pkt structure to default values</li>
<li>If application does not use tx scatter gather feature for packet transmission it should set<ul>
<li>EnetDma_Pkt.bufPtrFilledLen = EnetDma_Pkt.txTotalPktLen = length of tx packet</li>
</ul>
</li>
<li>If application uses the tx scatter gather feature please refer API documentation of EnetDma_Pkt and refer mcu_plus_sdk/examples/networking/enet_tx_scatter_gather/txsg_test.c for example usage</li>
</ul>
<h3><a class="anchor" id="autotoc_md2068"></a>
DisableCacheOps related change</h3>
<p>Impact: The disableCacheOps change impacts CPSW peripherals on AM263x/AM273x/AWR294x</p><ul>
<li>Applications directly invoke Enet driver packet <a class="el" href="group__ENET__DMA__API.html#gac80790c3fbf88c40ce547c41c6164ae6" title="Submit a queue of ready (full) packets to TX channel.">EnetDma_submitTxPktQ()</a> transmit APIs are impacted</li>
<li>UDP based LWIP applications are impacted</li>
</ul>
<p>Rationale for change:</p><ul>
<li>By default Enet driver will perform cache coherency operation on packet before submitting to enet DMA engine for packet transmission.</li>
<li>As a performance optimization application may not want the cache coherency operation to be performed on the packet payload by driver as the packet payload may not have been accessed by CPU (generated by HWA engine) or application may have handled the cache coherency operation on the payload itself</li>
</ul>
<p>If application is non-lwip based and application does not want to use this feature, it should invoke <a class="el" href="group__ENET__DMA__API.html#ga5167ef84b46cf4bb88791fe562af2628" title="Initialize packet information structure.">EnetDma_initPktInfo()</a> API to initialize EnetDma_Pkt structure to default values where EnetDma_Pkt.disableCacheOps is set to FALSE for packets to be transmitted. It can then update rest of the fields in EnetDma_initPktInfo to required values.</p>
<p>If application is lwip based based and UDP packets are transmitted, application should perform cache coherency operation on payload before submitting the packet for transmission. This is because zero copy is enabled for UDP packet transmission and cache operation in driver are disabled for UDP payload portions.</p><ul>
<li>Refer mcu_plus_sdk/examples/networking/lwip/enet_lwip_cpsw/udp_iperf.c: CacheP_wbInv function call for illustrative usage</li>
</ul>
<h3><a class="anchor" id="autotoc_md2069"></a>
Checksum offload related change</h3>
<p>Impact: The checksum offload change impacts CPSW peripheral based applications on AM263x</p><ul>
<li>Only applications directly invoke Enet driver packet <a class="el" href="group__ENET__DMA__API.html#gac80790c3fbf88c40ce547c41c6164ae6" title="Submit a queue of ready (full) packets to TX channel.">EnetDma_submitTxPktQ()</a> transmit APIs are impacted<ul>
<li>LWIP based applications are not impacted</li>
</ul>
</li>
</ul>
<p>Rationale for change:</p><ul>
<li>CPSW peripheral supports computation of UDP and TCP checksum in hardware. This feature is called checksum offload and is enabled in SDK 8.4 release for AM263x This feature requires addition of a new EnetDma_Pkt.chkSumInfo field in EnetDma_Pkt</li>
</ul>
<p>EnetDma_Pkt is the packet structure passed to EnetDma_submitTxPktQ (packet transmit) and EnetDma_retrieveRxPktQ (packet receive API) As this structure is modified to support checksum offload by adding chkSumInfo , chkSumInfo should be initialized correctly by application</p>
<p>For application that directly invoke Enet driver packet transmit and receive APIs the application should set EnetDma_Pkt.chkSumInfo = 0 This will ensure the CPSW checksum offload feature is not exercised wrongly</p>
<p><a class="el" href="enet_migration_guide_top.html">Back To Top</a></p>
<h1><a class="anchor" id="CustomBoardSupport"></a>
Custom Board Support</h1>
<hr  />
<p> The MCU+SDK enet driver supports a set of boards for each SoC out of the box</p><ul>
<li>Refer MCU+SDK release notes for platforms/board supported for each SoC</li>
</ul>
<p>The board specific portion of the enet code is auto generated in the file ti_board_config.c for supported boards</p>
<p>For porting enet based applications to custom board the following need to be done: Enable "Custom Board" syscfg option  <style>div.image img[src="CustomBoardSyscfg.png"]{width:30%}</style> </p><div class="image">
<img src="CustomBoardSyscfg.png" alt=""/>
</div>
<ul>
<li>Enabling “Custom Board” will prevent auto generation of board specific code.</li>
<li>A C file will have to be then written that is specific to the board.</li>
</ul>
<h3><a class="anchor" id="autotoc_md2070"></a>
Board config C file</h3>
<p>The board specific file should contain the following</p><ul>
<li><b>const EnetPhy_DrvInfoTbl gEnetPhyDrvTbl</b>: This is a table of ENET PHY drivers supported on the board. Refer Enet custom PHY integration guide for details on how to populate this table <a class="el" href="enetphy_guide_top.html">Ethernet PHY Integration Guide</a></li>
<li><b>EnetBoard_setupPorts()</b>: This function should setup any board level muxes and configure any SoC level RGMII internal delay/ RMII configuration for the specific port.<ul>
<li>Refer API documentation for mcu_plus_sdk/source/networking/enet/utils/include/enet_board.h for details of function and arguments</li>
</ul>
</li>
<li><b>EnetBoard_getPhyCfg()</b>: This function should return the ETHPHY specific configuration for a given port including any extended phy configuration<ul>
<li>Refer API documentation for mcu_plus_sdk/source/networking/enet/utils/include/enet_board.h for details of function and arguments</li>
</ul>
</li>
<li><b>EnetBoard_getMacAddrList()</b>: This function should populate any board specific MAC addresses that are available on board eeprom. If the board does not have any board specific macAddresses this function should set argument <code>*pAvailMacEntries = 0</code></li>
<li><b>EnetBoard_getId()</b>: This function should return the board id. This is not used anywhere outside this file so the board id returned will depend on the implementation of EnetBoard_setupPorts()/EnetBoard_getPhyCfg() for the custom board if it refers the boardId to determine PHY config/setup ports.</li>
<li>Refer mcu_plus_sdk/examples/networking/enet_layer2_multi_channel<ul>
<li>enet_custom_board_config.c for example illustrating custom board integration</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="autotoc_md2071"></a>
Ethernet MAC address Management</h3>
<p>Typically, one unique MAC address in burnt into efuse during device fabrication. Furthermore, additional MAC addresses are programmed in EEPROM on evaluation boards (EVM and launchpads) that are supported by TI.</p>
<p>There are two ways by which you can set the custom MAC address.</p>
<h3><a class="anchor" id="autotoc_md2072"></a>
1. Using Syscfg GUI tool</h3>
<p>An option is provided in Syscfg GUI tool to force custom MAC address instead of taking from EEPROM/EFUSE.</p>
<p>To use this option: +Oopen syscfg GUI tool.</p><ul>
<li>Go to "TI"-&gt;"ENET(CPSW)" (or "ENET(ICSS)")-&gt;"System integration config".</li>
<li>Change "MAC Address Assignment Method" to "Manual Entry" and fill the mac address in "MAC Address List" option.</li>
</ul>
<p><img src="enet_mac_addr_config_manual.png" alt="" class="inline" title="MACAddressManualEntry"/>   </p>
<ul>
<li>Keeping "MAC Address Assignment Method" to "Auto Assign", shall use the MAC address from EEPROM and EFUSE.</li>
</ul>
<p><img src="enet_mac_addr_config_auto.png" alt="" class="inline" title="MACAddressAuto Assign"/>   </p>
<p>Please note that"Auto Assign" is not supported on AM273x and AWR294x due to EVM limitation.</p>
<h3><a class="anchor" id="autotoc_md2073"></a>
2. Using Custom Board Option</h3>
<p>On your custom board EEPROM may not be available or it is not used to keep MAC address, then please follow below steps to set MAC address- <br  />
</p><ol type="1">
<li>Select custom board as per <a class="el" href="enet_migration_guide_top.html#CustomBoardSupport">previous section</a></li>
<li>In your specific custom board specific .c file (eg.: enet_custom_board_config.c), refer to funtion <code>s()</code> implementation as below-</li>
</ol>
<div class="fragment"><div class="line"> void EnetBoard_getMacAddrList(uint8_t macAddr[][ENET_MAC_ADDR_LEN],</div>
<div class="line">                              uint32_t maxMacEntries,</div>
<div class="line">                              uint32_t *pAvailMacEntries)</div>
<div class="line">{</div>
<div class="line">    int32_t status = ENET_SOK;</div>
<div class="line">    uint32_t macAddrCnt;</div>
<div class="line">    uint32_t i;</div>
<div class="line">    uint8_t macAddrBuf[ENET_BOARD_NUM_MACADDR_MAX * ENET_MAC_ADDR_LEN];</div>
<div class="line">    uint8_t numMacMax  = 0;</div>
<div class="line"> </div>
<div class="line">    /* Fill the MAC Address */</div>
<div class="line">    macAddrBuf[ENET_MAC_ADDR_LEN*0] = {0xF4, 0x84, 0x4C, 0xFB, 0xC0, 0x5C};</div>
<div class="line">    macAddrBuf[ENET_MAC_ADDR_LEN*1] = {0xF4, 0x84, 0x4C, 0xFB, 0xC0, 0x5D};</div>
<div class="line">    numMacMax = 2;</div>
<div class="line">    macAddrCnt = EnetUtils_min(numMacMax, maxMacEntries);</div>
<div class="line">    EnetAppUtils_assert(pAvailMacEntries != NULL);</div>
<div class="line">    for (i = 0U; i &lt; macAddrCnt; i++)</div>
<div class="line">    {</div>
<div class="line">        memcpy(macAddr[i], &amp;macAddrBuf[i * ENET_MAC_ADDR_LEN], ENET_MAC_ADDR_LEN);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    *pAvailMacEntries = macAddrCnt;</div>
<div class="line"> </div>
<div class="line">    if (macAddrCnt == 0U)</div>
<div class="line">    {</div>
<div class="line">        EnetAppUtils_print(&quot;EnetBoard_getMacAddrList Failed - IDK not present\n&quot;);</div>
<div class="line">        EnetAppUtils_assert(false);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="el" href="enet_migration_guide_top.html">Back To Top</a></p>
<h1><a class="anchor" id="ExternalPhyManagement"></a>
External PHY management</h1>
<hr  />
<p> External PHY management allows application plugging in its own PHY state machine and manage PHY drivers outside of Enet LLD</p><ul>
<li>PHY control and PHY statemachine handling is disabled in Ethernet driver</li>
<li>MDIO is still owned by Ethernet Driver and MDIO IOCTLs should be used to access the PHYs<ul>
<li>mcu_plus_sdk/examples/networking/lwip/enet_lwip_cpsw/extPhyMgmt/enetextphy_phymdio_dflt.c</li>
</ul>
</li>
<li>External PHY management is enabled via syscfg option <img src="ExternalPHYManagementSyscfg.png" alt="" class="inline" title="ExternalPhyManagementSyscfg"/>    {html: width=50%}</li>
<li>Application should register for MDIO link event interrupt if MDIO manual mode is not enabled<ul>
<li>Application should create a periodic polling task to check link state if MDIO manual mode is enabled<ul>
<li>This is because MDIO link event interrupt is not supported in MDIO manual mode (bitbanging mode)</li>
</ul>
</li>
</ul>
</li>
<li>Application should invoke below IOCTLs to inform Enet driver of link up/down events<ul>
<li>ENET_PER_IOCTL_HANDLE_EXTPHY_LINKUP_EVENT</li>
<li>ENET_PER_IOCTL_HANDLE_EXTPHY_LINKDOWN_EVENT</li>
</ul>
</li>
<li>Refer example application for extphy demonstration<ul>
<li>mcu_plus_sdk/examples/networking/lwip/enet_lwip_cpsw</li>
</ul>
</li>
</ul>
<p>Note: The external PHY sample example does not implement a real state m/c. Intention is to show Enet driver interaction with externally managed PHY and not implement a full featured external PHY</p>
<p><a class="el" href="enet_migration_guide_top.html">Back To Top</a></p>
<h1><a class="anchor" id="MemoryTuningNonLwip"></a>
Tuning memory usage of enet driver for non-lwip apps</h1>
<hr  />
<p>Syscfg integration allows the enet driver rwdata memory footprint to be sized based on application configuration Key params that are useful for tuning the rw data memory are</p><ul>
<li>Maximum number of packets for Tx and Rx Dma channel. This is configurable via syscfg</li>
<li>For non-lwip application , the enet library packet pool allocation can be enabled<ul>
<li>On enabling Packet Pool allocation ,the application can configure the size of large,medium and small pools and the number of packets in each pool</li>
<li><img src="PacketPoolConfigSyscfg.png" alt="" class="inline" title="PacketPoolConfigSyscfg"/>    {html: width=50%}</li>
</ul>
</li>
</ul>
<p><a class="el" href="enet_migration_guide_top.html">Back To Top</a></p>
<h1><a class="anchor" id="MemoryTuningLwip"></a>
Tuning memory usage of enet driver for lwip apps</h1>
<hr  />
<p> This release does not support similar syscfg based configuration of packet pools for lwip based examples. This will be addressed in the future releases. In the current release for lwip based application to tune memory the following option exists</p><ul>
<li>Set maximum number of packets for Tx and Rx Dma channel. This is configurable via syscfg</li>
<li>Update mcu_plus_sdk/source/networking/lwip/lwip-config/<code>&lt;soc&gt;</code>/lwippools.h as per application requirement</li>
<li>Update mcu_plus_sdk/source/networking/lwip/lwip-config/<code>&lt;soc&gt;</code>/lwipopts.h<ul>
<li>PBUF_POOL_SIZE : This determines number of Rx packets.<ul>
<li>The Rx Dma channel max number of packets should be updated if this value is modified</li>
</ul>
</li>
</ul>
</li>
<li><b>Changes to lwipopts.h and lwippools require recompilation of library</b><ul>
<li>gmake -s -f makefile.<code>&lt;soc&gt;</code> libs-scrub <code>#Clean all libraries</code></li>
<li>gmake -s -f makefile.<code>&lt;soc&gt;</code> libs PROFILE:=debug/release <code>#Rebuild all libraries</code></li>
</ul>
</li>
</ul>
<p><a class="el" href="enet_migration_guide_top.html">Back To Top</a></p>
<h1><a class="anchor" id="autotoc_md2074"></a>
Compatibilty Breaks During MCU+ SDK Version Update</h1>
<h2><a class="anchor" id="autotoc_md2075"></a>
Updating to version 10.00</h2>
<p><a class="el" href="enet_mcupsdk_10_00_update.html">MCU PLUS SDK Version Updating from 09.02 or earlier the latest</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
