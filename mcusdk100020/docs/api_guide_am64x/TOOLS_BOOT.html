<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="shortcut icon" href="favicon.png" type="image/png">    
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<title>AM64x MCU+ SDK: Booting Tools</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<style>
.tinav {
    background: #c00;
    /* height: 41.375px; */
    height: 30px;
    }
</style>    
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
  /* @license-end */
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="AM64x MCU+ SDK"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 40px;">
  <td id="projectlogo"><a href="https://www.ti.com"><img alt="Logo" src="ti_logo.svg"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AM64x MCU+ SDK
   &#160;<span id="projectnumber">10.00.00</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.html" method="get">
              <img id="MSearchSelect" src="search/mag.svg" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
</td>
 </tr>
 </tbody>
</table>
<div class=tinav></div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('TOOLS_BOOT.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Booting Tools </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md2490">Introduction</a></li>
<li class="level1"><a href="#autotoc_md2491">Important files and folders</a></li>
<li class="level1"><a href="#autotoc_md2492">Out2RPRC</a></li>
<li class="level1"><a href="#autotoc_md2493">Multi-core Image Gen</a></li>
<li class="level1"><a href="#TOOLS_BOOT_SIGNING">Signing Scripts</a></li>
<li class="level1"><a href="#autotoc_md2494">XIP Image Generator Tool</a></li>
<li class="level1"><a href="#UART_BOOTLOADER_PYTHON_SCRIPT">UART Bootloader Python Script</a></li>
<li class="level1"><a href="#USB_BOOTLOADER">USB Bootloader Python Script</a></li>
<li class="level1"><a href="#LINUX_APPIMAGE_GEN_TOOL">Linux Appimage Generator Tool</a></li>
<li class="level1"><a href="#SOC_ID_PARSER">SoC ID parser Python Script</a></li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="md_components_tools_tools_boot"></a></p>
<dl class="section note"><dt>Note</dt><dd>To see the exact sequence of steps in which applications and secondary bootloader (SBL) are converted from compiler generated .out files to boot images, see the makefile <code>makefile_ccs_bootimage_gen</code> that is included in every example and secondary bootloader (SBL) CCS project.</dd>
<dd>
If you are using makefile based build, then see the file named <code>makefile</code> in the example folder.</dd></dl>
<h1><a class="anchor" id="autotoc_md2490"></a>
Introduction</h1>
<p>This section describes the various tools that are used to create boot images for all the SDK applications</p>
<h1><a class="anchor" id="autotoc_md2491"></a>
Important files and folders</h1>
<table class="doxtable">
<tr>
<th>Folder/Files </th><th>Description  </th></tr>
<tr>
<td colspan="2" bgcolor="#F0F0F0">${SDK_INSTALL_PATH}/tools/boot/ </td></tr>
<tr>
<td>multicoreImageGen/ </td><td>Tool to combine multiple RPRC into a single binary  </td></tr>
<tr>
<td>out2rprc/ </td><td>Tool to convert compiler generated ELF .out for a CPU to a compact and loadable binary representation, called RPRC.  </td></tr>
<tr>
<td>sbl_prebuilt/ </td><td>Pre-built secondary bootloader (SBL) images and flash configuration files for different supported EVMs, see also <a class="el" href="TOOLS_FLASH.html">Flashing Tools</a>  </td></tr>
<tr>
<td>signing/ </td><td><p class="starttd">Security signing scripts need to create boot images that can be booted by ROM bootloader (RBL) </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>xipGen/ </td><td><p class="starttd">Tool to split a RPRC file generated from <code>out2rprc</code> into two files containing non-XIP and XIP sections. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>uart_bootloader.py </td><td>Python script used to send the SBL and appimage binaries over UART using XMODEM protocol in UART boot mode  </td></tr>
<tr>
<td>uart_uniflash.py </td><td>Python script used to flash SBL and applications to EVM flash using UART. See <a class="el" href="TOOLS_FLASH.html">Flashing Tools</a> for more details.  </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md2492"></a>
Out2RPRC</h1>
<ul>
<li>This tool converts the application executable (.out) into custom TI RPRC (.rprc) image - an image loadable by the secondary bootloader (SBL).</li>
<li>This tool strips out the initialized sections from the executable file (*.out) and places them in a compact format that the SBL can understand.</li>
<li>The output RPRC file is typically much smaller than the original executable (*.out) file.</li>
<li>The RPRC files are intermediate files in a format that is consumed by <code>MulticoreImageGen</code> tool that generates the final binary that is flashed (<code>*.appimage</code>)</li>
<li>The RPRC file format contains header to various sections in the executable like section run address, size and a overall header which mentions the number of sections and the start offset to the first section.</li>
<li>The RPRC magic word is <code>0x43525052</code> - which is ASCII equivalent for <code>RPRC</code></li>
<li>Shown below is the file header and section format for RPRC files.</li>
</ul>
<p> <style>div.image img[src="tools_rprc_format.png"]{width:40%}</style> </p><div class="image">
<img src="tools_rprc_format.png" alt=""/>
<div class="caption">
RPRC File Format</div></div>
<ul>
<li>Given below are the structs used in the bootloader library to parse an RPRC image</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>Bootloader_RprcFileHeader_s</div>
<div class="line">{</div>
<div class="line">    uint32_t <a class="code" href="tisci__boardcfg_8h.html#a8c61e64b8675498cee79c59d3f8131e2">magic</a>;</div>
<div class="line">    uint32_t entry;</div>
<div class="line">    uint32_t rsvdAddr;</div>
<div class="line">    uint32_t sectionCount;</div>
<div class="line">    uint32_t <a class="code" href="tisci__core_8h.html#ab6d7b6f8c2ceaba7acda80aaf05f4899">version</a>;</div>
<div class="line"> </div>
<div class="line">} Bootloader_RprcFileHeader;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>Bootloader_RprcSectionHeader_s</div>
<div class="line">{</div>
<div class="line">    uint32_t <a class="code" href="csl__udmap__tr_8h.html#a0e89cf6b9f6cd3125470b1bed2b823df">addr</a>;</div>
<div class="line">    uint32_t rsvdAddr;</div>
<div class="line">    uint32_t <a class="code" href="tisci__boardcfg_8h.html#aaba88b24a21a6c70c895c0d55f4a69a0">size</a>;</div>
<div class="line">    uint32_t rsvdCrc;</div>
<div class="line">    uint32_t <a class="code" href="tisci__boardcfg_8h.html#aad7157e0fe920ef2330a54b72fa978dc">rsvd</a>;</div>
<div class="line"> </div>
<div class="line">} Bootloader_RprcSectionHeader;</div>
</div><!-- fragment --><ul>
<li>This tool is provided as a minified JS script. To convert the application executable into RPRC image file, it can be used as <div class="fragment"><div class="line">cd ${SDK_INSTALL_PATH}/tools/boot/out2rprc</div>
<div class="line">${NODE} elf2rprc.js {input application executable file (.out)}</div>
</div><!-- fragment --></li>
<li>RPRC mandates that the sections in the application image should be 8-byte aligned. Make sure that this is taken care in the linker.cmd file. Sample: <div class="fragment"><div class="line">GROUP {</div>
<div class="line">        .text.hwi: palign(8)</div>
<div class="line">        .text.cache: palign(8)</div>
<div class="line">        .text.mpu: palign(8)</div>
<div class="line">        .text.boot: palign(8)</div>
<div class="line">        .text:abort: palign(8) /* this helps in loading symbols when using XIP mode */</div>
<div class="line">    } &gt; OCRAM</div>
</div><!-- fragment --></li>
</ul>
<h1><a class="anchor" id="autotoc_md2493"></a>
Multi-core Image Gen</h1>
<ul>
<li>This tool converts the RPRC files created for each CPU into a single combined multicore application image that can be booted by the secondary bootloader (SBL)</li>
<li>Shown below is the file format for multicore image files.</li>
</ul>
<p> <style>div.image img[src="tools_multicore_format.png"]{width:60%}</style> </p><div class="image">
<img src="tools_multicore_format.png" alt=""/>
<div class="caption">
Multi-core Image File Format</div></div>
<ul>
<li>Given below are the structs used in the bootloader library for parsing multicore images:</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>Bootloader_MetaHeaderStart_s</div>
<div class="line">{</div>
<div class="line">    uint32_t magicStr;</div>
<div class="line">    uint32_t numFiles;</div>
<div class="line">    uint32_t devId;</div>
<div class="line">    uint32_t <a class="code" href="tisci__boardcfg_8h.html#aad7157e0fe920ef2330a54b72fa978dc">rsvd</a>;</div>
<div class="line"> </div>
<div class="line">} Bootloader_MetaHeaderStart;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>Bootloader_MetaHeaderCore_s</div>
<div class="line">{</div>
<div class="line">    uint32_t coreId;</div>
<div class="line">    uint32_t imageOffset;</div>
<div class="line"> </div>
<div class="line">} Bootloader_MetaHeaderCore;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>Bootloader_MetaHeaderEnd_s</div>
<div class="line">{</div>
<div class="line">    uint32_t <a class="code" href="tisci__boardcfg_8h.html#aad7157e0fe920ef2330a54b72fa978dc">rsvd</a>;</div>
<div class="line">    uint32_t magicStringEnd;</div>
<div class="line"> </div>
<div class="line">} Bootloader_MetaHeaderEnd;</div>
</div><!-- fragment --><ul>
<li>The number of core meta headers present is equal to the number of cores included.</li>
<li>The meta header magic word is <code>0x5254534D</code> - which is ASCII equivalent for <code>MSTR</code></li>
<li>In Windows or Linux, use the following command to convert RPRC images into a multicore <code>.appimage</code> file <div class="fragment"><div class="line">cd ${SDK_INSTALL_PATH}/tools/boot/multicoreImageGen</div>
<div class="line">${NODE} multicoreImageGen.js --devID {DEV_ID} --out {Output image file (.appimage)} {core 1 rprc file}@{core 1 id} [ {core n rprc file}@{core n id} ... ]</div>
</div><!-- fragment --></li>
<li>In case of AM64X, <code>DEV_ID</code> is <code>55</code>.</li>
<li>The various core ID to be used are as below.</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">CORE  </th><th class="markdownTableHeadNone">CORE ID   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">r5fss0-0  </td><td class="markdownTableBodyNone">4   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">r5fss0-1  </td><td class="markdownTableBodyNone">5   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">r5fss1-0  </td><td class="markdownTableBodyNone">6   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">r5fss1-1  </td><td class="markdownTableBodyNone">7   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">m4fss0-0  </td><td class="markdownTableBodyNone">14   </td></tr>
</table>
<h1><a class="anchor" id="TOOLS_BOOT_SIGNING"></a>
Signing Scripts</h1>
<ul>
<li>To run these scripts, one needs <code>openssl</code> installed as mentioned here, <a class="el" href="SDK_DOWNLOAD_PAGE.html#INSTALL_OPENSSL">OpenSSL</a></li>
<li>Signing scripts are a collection of scripts needed to sign ROM images (image booted by ROM - mostly the SBL) and application images (image booted by the SBL)</li>
<li>The RBL requires the boot image (mostly SBL), to be signed always, even if we are not using secure boot.</li>
<li>We follow a combined boot method for ROM images. Here the ROM Bootloader (RBL) boots the SBL, SYSFW and BOARDCFG together. The boot image would be a binary concatenation of x509 Certificate, SBL, SYSFW, BOARDCFG (and the SYSFW inner certificate in case of HS device) binary blobs. We use a python script to generate this final boot image. This script has a dependency on <code>openssl</code> as mentioned before, so make sure you've installed it. To generate a combined boot image, one can do as below:</li>
<li>For GP devices <div class="fragment"><div class="line">cd ${SDK_INSTALL_PATH}/source/security/security_common/tools/boot/signing</div>
<div class="line">${PYTHON} rom_image_gen.py --swrv 1 --sbl-bin &lt;path-to-sbl-binary&gt; --sysfw-bin &lt;path-to-sysfw-binary&gt; --boardcfg-blob &lt;path-to-boardcfg-binary-blob&gt; --sbl-loadaddr ${SBL_RUN_ADDRESS} --sysfw-loadaddr ${SYSFW_LOAD_ADDR} --bcfg-loadaddr ${BOARDCFG_LOAD_ADDR} --key ${BOOTIMAGE_CERT_KEY} --rom-image &lt;path-to-output-image&gt;</div>
</div><!-- fragment --></li>
<li>For HS devices, we have to pass the HS SYSFW binaries and also the SYSFW inner certificate to the signing script. <div class="fragment"><div class="line">cd ${SDK_INSTALL_PATH}/source/security/security_common/tools/boot/signing</div>
<div class="line">${PYTHON} rom_image_gen.py --swrv 1 --sbl-bin &lt;path-to-sbl-binary&gt; --sysfw-bin &lt;path-to-sysfw-binary&gt; --sysfw-inner-cert &lt;path-to-sysfw-inner-cert-binary&gt; --boardcfg-blob &lt;path-to-boardcfg-binary-blob&gt; --sbl-loadaddr ${SBL_RUN_ADDRESS} --sysfw-loadaddr ${SYSFW_LOAD_ADDR} --bcfg-loadaddr ${BOARDCFG_LOAD_ADDR} --key ${BOOTIMAGE_CERT_KEY} --debug DBG_FULL_ENABLE --rom-image &lt;path-to-output-image&gt;</div>
</div><!-- fragment --></li>
<li>By default SBLs provided in SDK are signed with full debug enable since this is needed for development. You can see from <code>--debug</code> switch used above. Once moved to production please remove this switch from the makefile.</li>
<li>For SBL images or examples which is loaded by SBL, we use a different signing script. This is solely because of the x509 certificate template differences between ROM and SYSFW. In GP devices appimages are not signed. The signing happens only in HS devices. The script usage is: <div class="fragment"><div class="line">cd ${SDK_INSTALL_PATH}/source/security/security_common/tools/boot/signing</div>
<div class="line">$(PYTHON) appimage_x509_cert_gen.py --bin &lt;path-to-the-binary&gt; --authtype 1 --key &lt;signing-key-derived-from-devconfig&gt; --output &lt;output-image-name&gt;</div>
</div><!-- fragment --></li>
<li>In the case of encryption, two extra options are also passed to the script like so: <div class="fragment"><div class="line">cd ${SDK_INSTALL_PATH}/source/security/security_common/tools/boot/signing</div>
<div class="line">$(PYTHON) appimage_x509_cert_gen.py --bin &lt;path-to-the-binary&gt; --authtype 1 --key &lt;signing-key-derived-from-devconfig&gt; --enc y --enckey &lt;encryption-key-derived-from-devconfig&gt; --output &lt;output-image-name&gt;</div>
</div><!-- fragment --></li>
<li>These scripts are invoked in makefiles, and the image generation happens automatically along with the example build. So mostly these scripts need not be manually run.<ul>
<li>Here,<ul>
<li><code>SBL_RUN_ADDRESS</code> is <code>0x70000000</code></li>
<li>In the case of GP device, <code>BOOTIMAGE_CERT_KEY</code> is <code>rom_degenerateKey.pem</code></li>
<li>In the case of HS device, <code>BOOTIMAGE_CERT_KEY</code> is <code>custMpk_am64x_am243x.pem</code>. For more details about this see <a class="el" href="SECURE_BOOT.html">Enabling Secure Boot</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>These scripts are invoked in makefiles, and the image generation happens automatically along with the example build. So mostly these scripts need not be manually run. If the user build-system is different from TI's makefile system, it needs to be ensured that the same is followed as part of the post build steps. The devconfig has ENC_SBL_ENABLED=yes and that is why for HS-SE devices, the SBL image is encrypted by default.</p>
<h1><a class="anchor" id="autotoc_md2494"></a>
XIP Image Generator Tool</h1>
<ul>
<li>This tool, splits a input RPRC application file, into two RPRC files,<ul>
<li>First RPRC file, containing non-XIP sections and the application entry point</li>
<li>Second RPRC file, containing XIP sections. Here, adjacent sections are merged into one section</li>
</ul>
</li>
<li>The final number of sections in both RPRC files taken together can be less than the sections in the input file due to section merging in the XIP RPRC file.</li>
</ul>
<p> <style>div.image img[src="tools_xip_gen.png"]{width:60%}</style> </p><div class="image">
<img src="tools_xip_gen.png" alt=""/>
<div class="caption">
XIP Image Generation Tool flow</div></div>
<ul>
<li>The non-XIP RPRC file should be flashed and booted via SBL as usual</li>
<li>The XIP RPRC file should be flashed via the SDK flash writer, using the command <code>--flash-xip</code>, the flash writer in this case will flash sections at the flash address mentioned in the RPRC section header.</li>
<li>To see the detailed options supported by the tool, run this tool with the option <code>--help</code>. Example, output in Windows is shown below,</li>
</ul>
<div class="fragment"><div class="line">&gt; cd {SDK_INSTALL_PATH}/tools/boot/xipGen</div>
<div class="line">&gt; xipGen.exe</div>
<div class="line"> </div>
<div class="line">  XIP Image Creation Tool  - (c) Texas Instruments 2021, created on Apr 19 2021</div>
<div class="line"> </div>
<div class="line">  Usage: xipGen [options]</div>
<div class="line"> </div>
<div class="line">  Description,</div>
<div class="line">  This tool, splits a input RPRC application file, into two RPRC files,</div>
<div class="line">  - First RPRC file, containing non-XIP sections. The application entry point is assumed</div>
<div class="line">      to be in non-XIP region.</div>
<div class="line">  - Second RPRC file, containing XIP sections. The RPRC entry point is set to 0 and</div>
<div class="line">      adjacent XIP sections are merged</div>
<div class="line"> </div>
<div class="line">  Note, the final number of sections in both RPRC files taken together can be less</div>
<div class="line">  than the sections in the input file due to section merging in the XIP RPRC file.</div>
<div class="line"> </div>
<div class="line">  The non-XIP RPRC file should be flashed and booted via SBL as usual</div>
<div class="line"> </div>
<div class="line">  The XIP RPRC file should be flashed via the SDK flash writer, the flash writer will</div>
<div class="line">  flash sections at the flash address mentioned in the RPRC sections</div>
<div class="line"> </div>
<div class="line">  Options,</div>
<div class="line">  --input, -i : input RPRC file,</div>
<div class="line">  --output, -o : output RPRC file of non-XIP sections,</div>
<div class="line">  --output-xip, -x : output RPRC file of XIP sections,</div>
<div class="line">  --flash-start-addr, -f : XIP flash address space start, specified in hex. If not specified 0x60000000 is used</div>
<div class="line">  --flash-size, -s : XIP flash address space size in units of mega bytes, specified as integer. If not specified 256 MB is used</div>
<div class="line">  --verbose, -v : Verbose prints are enabled during the tool execution</div>
<div class="line">  --help, -h : Shows this help</div>
</div><!-- fragment --><h1><a class="anchor" id="UART_BOOTLOADER_PYTHON_SCRIPT"></a>
UART Bootloader Python Script</h1>
<ul>
<li>This script is used in UART boot mode for sending the SBL and appimage binaries to the EVM via UART using XMODEM protocol</li>
<li>Make sure that python3 and its dependent modules are installed in the host machine as mentioned in <a class="el" href="SDK_DOWNLOAD_PAGE.html#INSTALL_PYTHON3">Python3</a></li>
<li>Booting via UART is slow, but is useful if application loading via CCS or OSPI boot is not an option</li>
<li>Make sure the UART port used for terminal is identified as mentioned in <a class="el" href="EVM_SETUP_PAGE.html#CCS_UART_TERMINAL">Setup UART Terminal</a></li>
<li>Make sure you have the EVM power cable and UART cable connected as shown in <a class="el" href="EVM_SETUP_PAGE.html#EVM_CABLES">Cable Connections</a></li>
<li>To boot applications using this script, <b>POWER OFF the EVM</b></li>
<li>Switch to <a class="el" href="EVM_SETUP_PAGE.html#BOOTMODE_UART">UART BOOT MODE</a>.</li>
<li><b>POWER ON the EVM</b></li>
<li>To confirm that the board is in UART boot mode, open the UART terminal and confirm that you see the character 'C' getting printed on the console every 2-3 seconds.</li>
<li>Now close the terminal. This is important as the script won't be able to function properly if the UART terminal is open.</li>
<li>Open a command prompt and run the below command to send the SBL and application binary to the EVM <div class="fragment"><div class="line">cd ${SDK_INSTALL_PATH}/tools/boot</div>
<div class="line">python uart_bootloader.py -p COM&lt;x&gt; --bootloader=sbl_prebuilt/{board}/sbl_uart.release.tiimage --file=&lt; path to multicore appimage of application binary &gt;</div>
</div><!-- fragment --></li>
<li>When you execute this, the script first sends the uart bootloader, and then the multicore appimage</li>
<li>After the multicore appimage is successfully parsed, the uart bootloader sends an acknowledgment to the script and waits for 5 seconds before running the application binary</li>
<li>Upon receiving the ack, the script will exit successfully</li>
<li>Connect to the UART terminal within 5 seconds to see logs from the application</li>
<li>Below are the logs of the script after all the files have been sent <div class="fragment"><div class="line">Sending the UART bootloader sbl_prebuilt/{board}/sbl_uart.release.tiimage ...</div>
<div class="line">Sent bootloader sbl_prebuilt/{board}/sbl_uart.release.tiimage of size 243975 bytes in 23.94s.</div>
<div class="line"> </div>
<div class="line">Sending the application ../../examples/drivers/udma/udma_memcpy_polling/{board}/r5fss0-0_nortos/ti-arm-clang/udma_memcpy_polling.release.appimage ...</div>
<div class="line">Sent application ../../examples/drivers/udma/udma_memcpy_polling/{board}/r5fss0-0_nortos/ti-arm-clang/udma_memcpy_polling.release.appimage of size 99580 bytes in 11.74s.</div>
<div class="line">[STATUS] Application load SUCCESS !!!</div>
<div class="line">Connect to UART in 2 seconds to see logs from UART !!!</div>
</div><!-- fragment --></li>
</ul>
<h1><a class="anchor" id="USB_BOOTLOADER"></a>
USB Bootloader Python Script</h1>
<ul>
<li>This script is used in DFU boot mode for sending the SBL and appimage binaries to the EVM via USB DFU.</li>
<li>Make sure that <a class="el" href="SDK_DOWNLOAD_PAGE.html#INSTALL_DFU_UTIL">dfu-util</a> tool is installed properly and the DFU enumeration is verified.</li>
<li>Make sure that python3 and its dependent modules are installed in the host machine as mentioned in <a class="el" href="SDK_DOWNLOAD_PAGE.html#INSTALL_PYTHON3">Python3</a></li>
<li>Change the boot mode to DFU boot mode <a class="el" href="EVM_SETUP_PAGE.html">EVM Setup</a></li>
<li><b>POWER cycle the EVM</b></li>
<li>Open a command prompt and run the below command to send the SBL and application binary to the EVM <div class="fragment"><div class="line">cd ${SDK_INSTALL_PATH}/tools/boot</div>
<div class="line">python usb_bootloader.py --bootloader=sbl_prebuilt/{board}/sbl_dfu.release.hs_fs.tiimage --file=&lt; path to multicore appimage of application binary</div>
</div><!-- fragment --></li>
<li>When you execute this, the script first sends the SBL USB bootloader, and then the multicore appimage</li>
<li>Connect to the UART terminal to see the booting information</li>
<li>Below are the logs of the script after all the files have been sent</li>
</ul>
<div class="fragment"><div class="line">INFO: Bootloader_loadSelfCpu:207: CPU r5f0-0 is initialized to 800000000 Hz !!!</div>
<div class="line">INFO: Bootloader_loadSelfCpu:207: CPU r5f0-1 is initialized to 800000000 Hz !!!</div>
<div class="line">[BOOTLOADER_PROFILE] Boot Media       : USB DFU</div>
<div class="line">[BOOTLOADER_PROFILE] Boot Image Size  : 114 KB</div>
<div class="line">[BOOTLOADER_PROFILE] Cores present    :</div>
<div class="line">m4f0-0</div>
<div class="line">r5f1-0</div>
<div class="line">r5f1-1</div>
<div class="line">r5f0-0</div>
<div class="line">r5f0-1</div>
<div class="line">[BOOTLOADER PROFILE] CPU load                         :     200191us</div>
<div class="line">[BOOTLOADER_PROFILE] SBL Total Time Taken             :     200192us</div>
<div class="line"> </div>
<div class="line">Image loading done, switching to application ...</div>
<div class="line">INFO: Bootloader_runCpu:155: CPU m4f0-0 is initialized to 400000000 Hz !!!</div>
<div class="line">INFO: Bootloader_runCpu:155: CPU r5f1-0  is initialized to 800000000 Hz !!!</div>
<div class="line">INFO: Bootloader_runCpu:155: CPU r5f1-1 is initialized to 800000000 Hz !!!</div>
<div class="line">INFO: Bootloader_runSelfCpu:217: All done, reseting self ...</div>
<div class="line"> </div>
<div class="line">[IPC NOTIFY ECHO] Message exchange started by main core !!!</div>
<div class="line">[m4f0-0]     0.030020s : [IPC NOTIFY ECHO] Remote Core waiting for messages from main core ... !!!</div>
<div class="line">[r5f0-1]     0.002099s : [IPC NOTIFY ECHO] Remote Core waiting for messages from main core ... !!!</div>
<div class="line">[r5f0-1]     2.338054s : [IPC NOTIFY ECHO] Remote core has echoed all messages !!!</div>
<div class="line">[r5f1-0]     0.022147s : [IPC NOTIFY ECHO] Remote Core waiting for messages from main core ... !!!</div>
<div class="line">[r5f1-0]     2.358900s : [IPC NOTIFY ECHO] Remote core has echoed all messages !!!</div>
<div class="line">[r5f1-1]     0.015147s : [IPC NOTIFY ECHO] Remote Core waiting for messages from main core ... !!!</div>
<div class="line">[r5f1-1]     2.351658s : [IPC NOTIFY ECHO] Remote core has echoed all messages !!!</div>
<div class="line">[IPC NOTIFY ECHO] All echoed messages received by main core from 4 remote cores !!!</div>
<div class="line">[IPC NOTIFY ECHO] Messages sent to each core = 1000000</div>
<div class="line">[IPC NOTIFY ECHO] Number of remote cores = 4</div>
<div class="line">All tests have passed!!</div>
<div class="line">[m4f0-0]     3.568946s : [IPC NOTIFY ECHO] Remote core has echoed all messages !!!</div>
</div><!-- fragment --><ul>
<li>Refer <a class="el" href="EXAMPLES_DRIVERS_SBL_DFU.html">SBL DFU</a></li>
</ul>
<h1><a class="anchor" id="LINUX_APPIMAGE_GEN_TOOL"></a>
Linux Appimage Generator Tool</h1>
<ul>
<li>This tool generates a Linux Appimage by taking the Linux binaries (ATF, OPTEE, SPL) as input and generates a Linux appimage containing the input Linux binaries.</li>
<li>The input file location can be mentioned in the <code>config.mak</code> file located at {SDK_INSTALL_PATH}/tools/boot/linuxAppimageGen<ul>
<li><code>PSDK_LINUX_PREBUILT_IMAGES=/board-support/prebuilt-images</code></li>
</ul>
</li>
<li>The input file names for ATF, OPTEE and SPL can also be mentioned in the <code>config.mak</code> file.<ul>
<li><code>#Input linux binaries</code><br  />
 <code>ATF_BIN_NAME=bl31.bin</code><br  />
 <code>OPTEE_BIN_NAME=bl32.bin</code><br  />
 <code>SPL_BIN_NAME=u-boot-spl.bin-am64xx-evm</code><br  />
</li>
</ul>
</li>
<li>The load address for ATF, OPTEE and SPL need to be mentioned in the <code>config.mak</code> file.<ul>
<li><code>#Linux image load address</code><br  />
 <code>ATF_LOAD_ADDR=0x0701a0000</code><br  />
 <code>OPTEE_LOAD_ADDR=0x9e800000</code><br  />
 <code>SPL_LOAD_ADDR=0x80080000</code><br  />
</li>
</ul>
</li>
<li>The output appimage name can be mentioned in the <code>config.mak</code> file.<ul>
<li><code>#Output appimage name</code><br  />
 <code>LINUX_BOOTIMAGE_NAME=linux.appimage</code><br  />
</li>
</ul>
</li>
<li>Run the makefile at {SDK_INSTALL_PATH}/tools/boot/linuxAppimageGen to generate the Linux appimage<ul>
<li>For Windows <div class="fragment"><div class="line">cd ${SDK_INSTALL_PATH}/tools/boot/linuxAppimageGen</div>
<div class="line">gmake -s all</div>
</div><!-- fragment --></li>
<li>For Linux <div class="fragment"><div class="line">cd ${SDK_INSTALL_PATH}/tools/boot/linuxAppimageGen</div>
<div class="line">make -s all</div>
</div><!-- fragment --></li>
</ul>
</li>
<li>The Linux appimage wil be generated at {SDK_INSTALL_PATH}/tools/boot/linuxAppimageGen after running the makefile</li>
</ul>
<h1><a class="anchor" id="SOC_ID_PARSER"></a>
SoC ID parser Python Script</h1>
<ul>
<li>Boot ROM reports SoC ID on UART console of the device when UART boot mode is selected. It reports on both GP and HS devices and it provides insights into device configuration which would be helpful for debugs.</li>
<li>uart_boot_socid.py is a python3 based parser to convert the hexadecimal numbers reported by ROM to human readable text, below are the steps involved to use this parser. This will be helpful in debugging the device boot issue. This will also help to see important information about device like device type, prime/non-prime, key count, key revision, MPK hash etc.</li>
<li>Make sure python3 is installed as mentioned in <a class="el" href="SDK_DOWNLOAD_PAGE.html#INSTALL_PYTHON3">Python3</a></li>
<li><b>Steps to use the parser:</b><ul>
<li>Copy the soc id reported in UART console</li>
<li>pass the copied id to the script either as a plain string or saving it into a file</li>
<li>execute the script <div class="fragment"><div class="line">$python uart_boot_socid.py -d am64x --string=&lt;copied soc id&gt;</div>
<div class="line">or</div>
<div class="line">$python uart_boot_socid.py -d am64x --file=soc_id.txt</div>
</div><!-- fragment --></li>
</ul>
</li>
<li>Example Output: <div class="fragment"><div class="line">-----------------------</div>
<div class="line">SoC ID Header Info:</div>
<div class="line">-----------------------</div>
<div class="line">NumBlocks            : 2</div>
<div class="line">-----------------------</div>
<div class="line">SoC ID Public ROM Info:</div>
<div class="line">-----------------------</div>
<div class="line">SubBlockId           : 1</div>
<div class="line">SubBlockSize         : 26</div>
<div class="line">DeviceName           : am64x</div>
<div class="line">DeviceType           : HSSE</div>
<div class="line">DMSC ROM Version     : [0, 2, 0, 0]</div>
<div class="line">R5 ROM Version       : [0, 2, 0, 0]</div>
<div class="line">-----------------------</div>
<div class="line">SoC ID Secure ROM Info:</div>
<div class="line">-----------------------</div>
<div class="line">Sec SubBlockId       : 2</div>
<div class="line">Sec SubBlockSize     : 166</div>
<div class="line">Sec Prime            : 0</div>
<div class="line">Sec Key Revision     : 1</div>
<div class="line">Sec Key Count        : 1</div>
<div class="line">Sec TI MPK Hash      : b018658ad99dc903c8c9bfb27b12751099920a042ad1dfea7b7ba57369f15546de285edde6a7b39a8bdc40a27b237f8fb1e57f245e80b929c1e28b024aa2ecc6</div>
<div class="line">Sec Cust MPK Hash    : 1f6002b07cd9b0b7c47d9ca8d1aae57b8e8784a12f636b2b760d7d98a18f189760dfd0f23e2b0cb10ec7edc7c6edac3d9bdfefe0eddc3fff7fe9ad875195527d</div>
<div class="line">Sec Unique ID        : 01f22176afca3a82692ce53b2738b8c982f7538602871e0bdb7dc2f7668d04b2</div>
</div><!-- fragment --> </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div class="ttc" id="atisci__boardcfg_8h_html_a8c61e64b8675498cee79c59d3f8131e2"><div class="ttname"><a href="tisci__boardcfg_8h.html#a8c61e64b8675498cee79c59d3f8131e2">magic</a></div><div class="ttdeci">uint16_t magic</div><div class="ttdef"><b>Definition:</b> tisci_boardcfg.h:0</div></div>
<div class="ttc" id="atisci__boardcfg_8h_html_aaba88b24a21a6c70c895c0d55f4a69a0"><div class="ttname"><a href="tisci__boardcfg_8h.html#aaba88b24a21a6c70c895c0d55f4a69a0">size</a></div><div class="ttdeci">uint16_t size</div><div class="ttdef"><b>Definition:</b> tisci_boardcfg.h:1</div></div>
<div class="ttc" id="acsl__udmap__tr_8h_html_a0e89cf6b9f6cd3125470b1bed2b823df"><div class="ttname"><a href="csl__udmap__tr_8h.html#a0e89cf6b9f6cd3125470b1bed2b823df">addr</a></div><div class="ttdeci">uint64_t addr</div><div class="ttdef"><b>Definition:</b> csl_udmap_tr.h:3</div></div>
<div class="ttc" id="atisci__boardcfg_8h_html_aad7157e0fe920ef2330a54b72fa978dc"><div class="ttname"><a href="tisci__boardcfg_8h.html#aad7157e0fe920ef2330a54b72fa978dc">rsvd</a></div><div class="ttdeci">uint8_t rsvd[3]</div><div class="ttdef"><b>Definition:</b> tisci_boardcfg.h:3</div></div>
<div class="ttc" id="atisci__core_8h_html_ab6d7b6f8c2ceaba7acda80aaf05f4899"><div class="ttname"><a href="tisci__core_8h.html#ab6d7b6f8c2ceaba7acda80aaf05f4899">version</a></div><div class="ttdeci">uint16_t version</div><div class="ttdef"><b>Definition:</b> tisci_core.h:2</div></div>
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
