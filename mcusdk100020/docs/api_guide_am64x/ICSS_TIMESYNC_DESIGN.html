<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="shortcut icon" href="favicon.png" type="image/png">    
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<title>AM64x MCU+ SDK: ICSS TimeSync Design</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<style>
.tinav {
    background: #c00;
    /* height: 41.375px; */
    height: 30px;
    }
</style>    
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
  /* @license-end */
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="AM64x MCU+ SDK"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 40px;">
  <td id="projectlogo"><a href="https://www.ti.com"><img alt="Logo" src="ti_logo.svg"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AM64x MCU+ SDK
   &#160;<span id="projectnumber">10.00.00</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.html" method="get">
              <img id="MSearchSelect" src="search/mag.svg" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
</td>
 </tr>
 </tbody>
</table>
<div class=tinav></div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('ICSS_TIMESYNC_DESIGN.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">ICSS TimeSync Design </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md2134">Terms and Abbreviations</a></li>
<li class="level1"><a href="#autotoc_md2135">Timer</a></li>
<li class="level1"><a href="#autotoc_md2136">Sync Signal Generation</a></li>
<li class="level1"><a href="#ICSS_TIMESYNC_DESIGN_TIMESTAMPING">Timestamping</a></li>
<li class="level1"><a href="#autotoc_md2137">State Machine</a></li>
<li class="level1"><a href="#autotoc_md2138">Synchronization</a><ul><li class="level2"><a href="#autotoc_md2139">Determination of Sync Period</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md2140">Delay Calculation</a><ul><li class="level2"><a href="#ICSS_TIMESYNC_LINE_DELAY_CALCULATION">Line Delay Calculation for E2E mode</a></li>
<li class="level2"><a href="#autotoc_md2141">Peer Delay Calculation for P2P mode</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md2142">Syntonization</a></li>
<li class="level1"><a href="#autotoc_md2143">Reset</a></li>
<li class="level1"><a href="#autotoc_md2144">Forwarding Rules</a></li>
<li class="level1"><a href="#autotoc_md2145">OS Components</a><ul><li class="level2"><a href="#ICSS_TIMESYNC_DESIGN_INTERRUPTS">Interrupts</a></li>
<li class="level2"><a href="#autotoc_md2146">Tasks</a></li>
<li class="level2"><a href="#autotoc_md2147">Semaphores</a></li>
<li class="level2"><a href="#autotoc_md2148">Events</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="md_components_networking_icss_timesync_design"></a></p>
<h1><a class="anchor" id="autotoc_md2134"></a>
Terms and Abbreviations</h1>
<table class="doxtable">
<tr>
<th>Term/Abbreviation </th><th>Expansion  </th></tr>
<tr>
<td>PRU-ICSS </td><td>Programmable Real-Time Unit Industrial Communication Subsystem  </td></tr>
<tr>
<td>PTP </td><td>Precision Time Protocol  </td></tr>
<tr>
<td>E2E </td><td>End to End  </td></tr>
<tr>
<td>P2P </td><td>Peer to Peer  </td></tr>
<tr>
<td>TC </td><td>Transparent Clock  </td></tr>
<tr>
<td>OC </td><td>Ordinary clock  </td></tr>
<tr>
<td>Time Source </td><td>PTP Time Source  </td></tr>
<tr>
<td>Receiver </td><td><p class="starttd">PTP Receiver </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>RCF </td><td>Syntonization/(Frequency Compensation) factor  </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md2135"></a>
Timer</h1>
<p>ICSS TimeSync Driver uses the 64-bit free running IEP Timer inside PRU-ICSS running at 200 MHz as the base timer for all synchronization related activities. PRU-ICSS has the capability to timestamp entry and exit of a frame based on this timer.</p>
<h1><a class="anchor" id="autotoc_md2136"></a>
Sync Signal Generation</h1>
<p>Sync signal is enabled in IEP with a sync pulse width that is relative to the sync signal generation interval. This sync is equivalent to the 1PPS output and should not be confused with PTP Sync frame. For the sync signal generation CMP1 is programmed to a value ranging from 1ms to 1 second. Firmware checks this event and re-programs it after every hit to ensure that accurate sync pulses are generated. The sync interval must not be configured such that the 1000000000 ns or 1 seconds is not an integral multiple of it. This will lead to sync signal generation which is not at the second boundary, this might impact synchronizing other devices using the sync output.</p>
<h1><a class="anchor" id="ICSS_TIMESYNC_DESIGN_TIMESTAMPING"></a>
Timestamping</h1>
<p>The timestamps are read from 64-bit free running IEP Timer inside PRU-ICSS running at 200 MHz. The timer has a resolution of 5 ns. The Rx and Tx timestamps are stored in PRU-ICSS Shared RAM. For Rx timestamps there is another mechanism where the timestamps are appended to the end of the frame being sent to host, this method isn't available for all protocols. In the driver, this mode is controlled by the user configurable variable <code>timestamp_from_shared_ram</code> (in structure <a class="el" href="structTimeSync__Config__t.html">TimeSync_Config_t</a>).</p>
<p>For Rx, both Start of Frame (SOF) and Start of Frame Delimiter (SFD) timestamping is possible using IEP. For Tx, only SOF timestamp is available. Since PTP/1588 specifies that SFD time stamps are to be used we store the RX SFD time stamp for all frames and add 640ns to the Tx SOF time stamp, the underlying assumption being that the preamble length is 8 bytes. This is correct because PRU-ICSS inserts it's own preamble and CRC instead of copying from the received frames. It is also important to compensate the PHY delay and other known delay parameters in timestamps for accurate timing. For this purpose, <code>txPhyLatency</code> and <code>rxPhyLatency</code> (which are a part of the configuration structure <a class="el" href="structTimeSync__Config__t.html">TimeSync_Config_t</a>) should be configured properly during initialization.</p>
<p>Following are details on timestamping availability for different PTP packets :</p><ul>
<li>Sync : Rx and Tx timestamps</li>
<li>Follow Up : No timestamping</li>
<li>Announce : No timestamping</li>
<li>Delay Response : No timestamping</li>
<li>Delay Request : Entry and exit timestamping is done in nanoseconds. Exit timestamp is used in delay calculations while entry timestamp is used for bridge delay calculation.</li>
<li>Peer Delay Request : Rx and Tx timestamps</li>
<li>Peer Delay Response : Rx and Tx timestamps</li>
<li>Peer Delay Response Follow Up : No timestamp</li>
</ul>
<h1><a class="anchor" id="autotoc_md2137"></a>
State Machine</h1>
<p>The PTP state machine has the following states:</p>
<ol type="1">
<li>Enabled</li>
<li>BMCA has run and Time Source has been determined</li>
<li>First adjustment done</li>
<li>Line/Peer delay computed</li>
<li>Sync interval computed</li>
<li>Ready for adjustment. This happens once previous states have been triggered.</li>
<li>Synchronized. Average clock drift has gone below a specified threshold.</li>
<li>Error (Announce timeout, very large adjustment, sync interval too large, missed sync frame)</li>
</ol>
<p>When the firmware receives PTP packets initially, it puts all Announce and Management frames in highest priority queue and no sync signal is generated (until sync Time Source is determined). RCF value used is the default 1.0. Once BMCA has determined the Time Source, it's MAC ID should be provided to firmware using <a class="el" href="group__NETWORKING__ICSS__TIMESYNC__MODULE.html#gacc6d5a7aed0c6574d98c34e859817463">TimeSync_updateParentAddress</a>. The firmware checks against this MAC ID to put Sync frames in Host queue, Announce and Management frames are always forwarded to Host. Clock synchronization starts and RCF is computed along with other values.</p>
<p>The <code>stateMachine</code> variable is part of TimeSync runtime variable <a class="el" href="structtimeSync__RuntimeVar__t.html">timeSync_RuntimeVar_t</a> which is a part of <a class="el" href="structTimeSync__ParamsHandle.html">TimeSync_ParamsHandle</a>. It has 5 states:</p>
<ol type="1">
<li>First adjustment done</li>
<li>Line/Peer delay computed</li>
<li>Sync interval computed</li>
<li>Ready for Sync</li>
<li>Synchronized</li>
</ol>
<p>They correspond to states 3-7 of the states described earlier. States 1, 2 and 8 are implicit states.</p>
<h1><a class="anchor" id="autotoc_md2138"></a>
Synchronization</h1>
<p>Synchronization is about ensuring that the local clock on both Time Source and receiver reflect the same value (after adjustment for path delay). This is done by</p><ol type="1">
<li>Copying the value of clock directly at first (also called the "Initial adjustment")</li>
<li>Calculating the drift every time a sync frame comes and then adjusting the local clock to take care of the drift.</li>
</ol>
<p>Synchronization is done in the Sync frame context and adjustment must be complete by the time next Sync packet arrives. To calculate the drift the assumption is that seconds field is synchronized and hence only nanoseconds field is compared to find the drift irrespective of the sync interval. Exception is when there is a wraparound and Seconds field is not the same, this can happen when the receiver is so far from the Time Source that seconds field increments by the time Sync frame reaches it. Actual synchronization is done by the function <a class="el" href="icss__timeSync_8h.html#afa613964ff1cb3ae68de9bab806ea900">TimeSync_synchronizeClock</a> which computes the current offset from the Time Source and calls the function <a class="el" href="group__NETWORKING__ICSS__TIMESYNC__MODULE.html#ga77c2531f5d442d3b83f1627f5996b135">TimeSync_adjTimeSlowComp</a> to adjust the IEP counter using slow compensation mechanism.</p>
<h2><a class="anchor" id="autotoc_md2139"></a>
Determination of Sync Period</h2>
<ul>
<li>Sync frame interval is determined in the driver from Sync frames. The driver waits for at least 3 sync timestamps to do this.</li>
<li>Driver also checks if there is a large difference in the known Sync Period and the observed value, if it is determined that Sync interval has changed, then state machine is initialized and PTP receiver has to sync all over again.</li>
<li>Driver monitors if the time base has changed significantly (by 1 s or more). This excludes special cases such as leap59 and leap60. Such a condition triggers state machine to be initialized again and PTP receiver has to sync all over again.</li>
<li>The sync frame interval is determined in the same function which calculates RCF. <a class="el" href="icss__timeSync_8h.html#aa19f1b0ec370b0212e9a250b4121afc9">TimeSync_calcRcfAndSyncInterval</a> does this calculation.</li>
</ul>
<h1><a class="anchor" id="autotoc_md2140"></a>
Delay Calculation</h1>
<h2><a class="anchor" id="ICSS_TIMESYNC_LINE_DELAY_CALCULATION"></a>
Line Delay Calculation for E2E mode</h2>
<p>Line delay refers to the delay between PTP Time Source and Receiver. The line delay is calculated in response to the Delay request frame which is sent every time a Sync frame is received. This behavior is not mandated by the standard but is chosen for simplicity.</p>
<p>The API used for this is <a class="el" href="icss__timeSync_8h.html#ac7944cefa4707e8f5613ca1f9d7cd398">TimeSync_lineDelayCalc</a>. It is called once the firmware receives a Delay Response packet meant for the receiver. This processing is done in the function <a class="el" href="icss__timeSync_8h.html#ac1e95b27793362b2d6248d0b9095a5e2">TimeSync_processDelayResFrame</a>.</p>
<p>The calculation of line delay (time distance between two nodes) is required for finding out things like clock drift and frequency syntonization factor (RCF). The mechanism for Line Delay is roughly the same for both Delay Request and Peer Delay packets.</p>
<p>The basic concept to understand here is that we want to find out the time it takes for a packet to traverse between the nodes. This is done by sending a packet from one node to another (usually from Time Source to receiver), which is called a sync packet. The sync packet contains a timestamp that indicates when it left the Time Source. This is present either in the correction field or the timestamp. If the device is incapable of providing an accurate timestamp in the sync packet, a follow up packet is sent which contains this information.</p>
<p>Upon receipt of the follow up information the receiver sends a Delay Request packet which again is timestamped like the sync packet with the exit timestamp. When a delay request is received at the Time Source, a Delay Response is sent meant only for that receiver which issued the Delay Request (Delay Response is tagged with Receiver information). The Delay Response contains the time at which Delay Request was received at the Time Source.</p>
<p>The entire process is depicted in the diagram below.</p>
<div class="image">
<img src="ICSS_TIMESYNC_lineDelayCalculation.png" alt=""/>
</div>
<p>The timestamps are respectively indicated by t1, t2, t3 and t4.</p>
<p>Line delay is calculated as <code>Mean Path Delay = (Forward Delay + Reverse Delay) / 2 = ((t2 – t1) + (t4 – t3))/ 2</code></p>
<p>Since on both receiver and Time Source the counters are free counters, it makes more sense to re-arrange the computation like this. <code>Mean Path Delay = ((t4 - t1) – (t3 – t2))/2</code></p>
<h2><a class="anchor" id="autotoc_md2141"></a>
Peer Delay Calculation for P2P mode</h2>
<p>Peer delay refers to the time delay between adjacent PTP nodes in a P2P network. The API for this is <a class="el" href="icss__timeSync_8h.html#a2a869683af6571dd04d97b383c20d75e">TimeSync_peerDelayCalc</a>. It is called inside the function <a class="el" href="icss__timeSync_8h.html#ab64de5336932889cc234176f21363dc4">TimeSync_processPdelayRespFrame</a> which processes the peer delay response frame. As soon as a response is detected the peer delay calculation runs, it is run for both the ports. For an adjacent node requesting a Pdelay Response the receiver gives a 2-step response. Upon receiving the Pdelay Request, it's Rx timestamp is stored and when Pdelay Response goes out, it's Tx timestamp is used to calculate the resident time. This resident time is reflected in the correction field of Pdelay Response.</p>
<p>The main differences compared to E2E mode is that Peer Delay Request/Response messages are used instead of Delay Request/Response messages and Sync packets are not required.</p>
<p>Since Peer to Peer Requests are meant for adjacent nodes, it is important that these packets are dropped and not forwarded.</p>
<h1><a class="anchor" id="autotoc_md2142"></a>
Syntonization</h1>
<p>Syntonization is accounting for the frequency difference between Time Source and Receiver. This is done by</p>
<ol type="1">
<li>Keeping track of timestamps of two alternate Sync frames (not consecutive).</li>
<li>Taking the difference in arrival timestamp (as recorded on receiver), let's call this "receiver time".</li>
<li>Taking the difference in origin timestamp (as recorded on Time Source), let's call this "Time Source time".</li>
</ol>
<p>The RCF or syntonization factor is computed as RCF = Time Source time/receiver time. Any delay computed on receiver is then multiplied by this factor.</p>
<p>For example if Time Source is running twice as fast as receiver then RCF will be 2 and any delay computed on receiver will get multiplied by this value to reflect time in terms of Time Source. In reality the RCF rarely goes out of the range 0.99-1.01 and any value outside this should be interpreted as an error.</p>
<p>Timestamps are recorded and Syntonization is done in a PTP task context and not inside Sync frame processing. The function which calculates RCF is <a class="el" href="icss__timeSync_8h.html#aa19f1b0ec370b0212e9a250b4121afc9">TimeSync_calcRcfAndSyncInterval</a>.</p>
<p>If we consider the image shown in <a class="el" href="ICSS_TIMESYNC_DESIGN.html#ICSS_TIMESYNC_LINE_DELAY_CALCULATION">Line Delay Calculation for E2E mode</a>, RCF is calculated as follows.</p>
<p>T3 is the sync transmit timestamp from Time Source and T4 is the sync receive timestamp on receiver. T3' is T3 measured again in future (same for T4). &lsquo;RCF = (T3&rsquo; – T3) / (T4' – T4)<code> </code>Mean Path Delay (compensated) = Mean Path Delay * rcf;`</p>
<h1><a class="anchor" id="autotoc_md2143"></a>
Reset</h1>
<p>This section talks about the ICSS TimeSync driver reset. The various PTP variables and state machine inside the driver require a reset every time an exception occurs. <a class="el" href="group__NETWORKING__ICSS__TIMESYNC__MODULE.html#ga0ecd71c8cf84fc9ee69373dba314d9c2">TimeSync_reset</a> can be called for this reset.</p>
<p>The steps performed during this reset are</p>
<ol type="1">
<li>Call the sync loss callback function <a class="el" href="icss__timeSyncApi_8h.html#a03937c26648618344a47df6998dc6798">TimeSync_SyncLossCallBack_t</a></li>
<li>Disable firmware by calling the function <a class="el" href="group__NETWORKING__ICSS__TIMESYNC__MODULE.html#gaaf53bd1fb03574a6522cb12d162362a3">TimeSync_drvDisable</a></li>
<li>Clear all internal structures used by ICSS TimeSync driver</li>
<li>Following memory locations in PRU-ICSS Shared RAM need to be reset to 0<ul>
<li>SYNC_MASTER_MAC_OFFSET</li>
<li>TIMESYNC_TC_RCF_OFFSET is set to 1024</li>
</ul>
</li>
<li><code>stateMachine</code> set to 0</li>
<li><code>rcf</code> set to 1.0</li>
<li>Neighbor rate ratio or nrr for both ports set to 1.0</li>
<li>Runtime variables <code>clockDrift</code> and <code>syncTimeoutInterval</code> set to 10000</li>
<li>Offset Algo variables <code>driftThreshold</code> set to init value <a class="el" href="group__NETWORKING__ICSS__TIMESYNC__MODULE.html#gadd05aa20f728c6e4d40ba655da209e6c">TIMESYNC_OFFSET_STABLE_ALGO_THRESHOLD</a></li>
<li>Call the PTP stack callback function <a class="el" href="icss__timeSyncApi_8h.html#a37893687b02fc503c9e4c807ab7c70fa">TimeSync_stackResetCallback_t</a>. This callback can be registered by PTP stack to get a reset notification.</li>
<li>Enable firmware by calling <a class="el" href="group__NETWORKING__ICSS__TIMESYNC__MODULE.html#ga79a380fdc7ccc4428bbaf6852cc7d6ff">TimeSync_drvEnable</a></li>
</ol>
<p>The reset is called under the followng conditions</p>
<ol type="1">
<li>Sync frame missed : When a sync frame is missed this is detected by the sync timeout mechanism. Three consecutive misses leads to a reset.</li>
<li>Current offset out of range : Whenever absolute offset exceeds a threshold, reset is triggered. This comparison is done in the function <a class="el" href="icss__timeSync_8h.html#afa613964ff1cb3ae68de9bab806ea900">TimeSync_synchronizeClock</a>. The threshold of change is set by the macro <a class="el" href="icss__timeSync_8h.html#a88b89939f699357296deecf17abee3f9">OFFSET_THRESHOLD_FOR_RESET</a>, value is in nanoseconds.</li>
</ol>
<h1><a class="anchor" id="autotoc_md2144"></a>
Forwarding Rules</h1>
<p>PTP frames have a common format but the implementation varies widely depending on the Annex or Profile in use. ICSS TimeSync driver supports following profile:</p>
<ol type="1">
<li>PTP over UDP in E2E mode: PTP packets are encapsulated inside UDP and the delay measurement scheme is End to End. In this scheme all wire delays are measured relative to the Time Source. This support is bundled with EtherNet/IP firmware.</li>
</ol>
<p>The forwarding rules for different frame types are as follows. Here forward means to Host as well as to the other port if link is available unless mentioned specifically.</p>
<ol type="1">
<li>Announce : Forward without correction</li>
<li>Sync : Forward with correction</li>
<li>Follow Up : Forward without correction</li>
<li>Delay Request : Forward with correction and Tx only</li>
<li>Delay Response : Forward without correction if it's not a delay response corresponding to our delay request and don't send to Host. If the delay response matches our delay request then send to host and don't forward.</li>
<li>Management messages : Forward without correction</li>
</ol>
<h1><a class="anchor" id="autotoc_md2145"></a>
OS Components</h1>
<p>This section describes the OS entities used by ICSS TimeSync. All initialization is again done in the function <code>TimeSync_isrAndTaskInit</code>.</p>
<h2><a class="anchor" id="ICSS_TIMESYNC_DESIGN_INTERRUPTS"></a>
Interrupts</h2>
<ul>
<li>Tx <a class="el" href="structTimestamp.html" title="The Timestamp type represents a positive time with respect to the epoch.">Timestamp</a> Interrupt for Host : This interrupt is registered based the value provided in <code>txIntNum</code> which is a part of configuration structure <a class="el" href="structTimeSync__Config__t.html">TimeSync_Config_t</a>. This interrupt is mapped to the ISR <code>TimeSync_txTSIsr</code>.</li>
<li>Rx Interrupt : All incoming PTP frames are handled through the regular Rx interrupt registered by ICSS-EMAC (See <a class="el" href="ICSS_EMAC_DESIGN.html#ICSS_EMAC_DESIGN_INTERRUPTS">Interrupts</a> section in <a class="el" href="ICSS_EMAC_DESIGN.html">ICSS-EMAC Design</a> for more details). <a class="el" href="group__NETWORKING__ICSS__TIMESYNC__MODULE.html#ga0d9348a67c56e2431736a2824cdfcf55">TimeSync_processPTPFrame</a> must be called for processing PTP frames. Firmware will use highest priority queue for PTP frames. As mentioned in <a class="el" href="ICSS_EMAC_DESIGN.html#ICSS_EMAC_DESIGN_DATA_PATH_RX">Rx Data Path</a>, <code>rxRTCallBack</code> needs to be registered to process these frames in queues. Therefore, either <a class="el" href="group__NETWORKING__ICSS__TIMESYNC__MODULE.html#ga0d9348a67c56e2431736a2824cdfcf55">TimeSync_processPTPFrame</a> must be registered as <code>rxRTCallBack</code>, or if different types of frames (other than PTP) are coming on the high priority queues, then application must differentiate PTP frames in <code>rxRTCallBack</code> and then call the <a class="el" href="group__NETWORKING__ICSS__TIMESYNC__MODULE.html#ga0d9348a67c56e2431736a2824cdfcf55">TimeSync_processPTPFrame</a> API for PTP frames.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>All PTP frames are sent by firmware on the highest priority queue to the host.</dd></dl>
<h2><a class="anchor" id="autotoc_md2146"></a>
Tasks</h2>
<p>ICSS TimeSync driver uses a multitude of tasks to send/process frames, act as a watchdog and for book keeping.</p>
<table class="doxtable">
<tr>
<th>Task Function Name </th><th>Description  </th></tr>
<tr>
<td><code>TimeSync_PdelayReqSendTask</code> </td><td>Send Peer Delay Requests periodically on both ports. Delay is configurable. Only applicable for P2P configuration.  </td></tr>
<tr>
<td><code>TimeSync_delayReqSendTask</code> </td><td>Send Delay requests to PTP Time Source. This is currently done for every Sync frame. Pends indefinitely on <code>delayReqTxSemObject</code> semaphore. Only applicable for E2E configuration.  </td></tr>
<tr>
<td><code>TimeSync_TxTSTask_P1</code> </td><td>Process Tx timestamp for Port 1. Pends on an event posted by Tx ISR indefinitely.  </td></tr>
<tr>
<td><code>TimeSync_TxTSTask_P2</code> </td><td>Same as above but for Port 2.  </td></tr>
<tr>
<td><code>TimeSync_NRT_Task</code> </td><td>NRT stands for non real time. Processes Peer delay frames in the background and calculate peer delay.  </td></tr>
<tr>
<td><code>TimeSync_BackgroundTask</code> </td><td>Checks for Sync timeout and performs offset stabilization.  </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md2147"></a>
Semaphores</h2>
<table class="doxtable">
<tr>
<th>Name </th><th>Description  </th></tr>
<tr>
<td><code>delayReqTxSemObject</code> </td><td>This is posted when a Sync frame is received. It enables a suspended task to send Delay Request frame to PTP Time Source. Only applicable for E2E configuration.  </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md2148"></a>
Events</h2>
<p>ICSS TimeSync driver uses a lot of events to process PTP frames. All events are in pairs, one each for physical port.</p>
<table class="doxtable">
<tr>
<th>Name </th><th>Description </th><th>Corresponding Event IDs  </th></tr>
<tr>
<td><code>txTSAvailableEvtObject</code> </td><td>Posted by the Tx ISR to indicate that a timestamp is available and processing can be completed </td><td><code>eventIdSync</code> and <code>eventIdPdelayResp</code>  </td></tr>
<tr>
<td><code>ptpPdelayResEvtObject</code> </td><td>Used to process Peer Delay Response and Peer Delay Response Follow Up messages </td><td><code>eventIdPdelayResp</code> and <code>eventIdPdelayRespFlwUp</code>  </td></tr>
<tr>
<td><code>ptpPdelayReqEvtObject</code> </td><td>Used to process Pdelay request messages and send a response </td><td><code>eventIdPdelayReq</code>  </td></tr>
<tr>
<td><code>ptpSendFollowUpEvtObject</code> </td><td>Used to generate Follow up frame in case of forced 2-step mode </td><td><code>eventIdSync</code> and <code>eventIdFlwUpGenerated</code>  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>All the interrupts, tasks and semaphores created in an application can be checked using the ROV. For more details, see <a href="@VAR_MCU_SDK_DOCS_PATH/ROV_INTRO_PAGE.html#PRUICSS_INTC">Using SDK with Real-time Object View (ROV)</a>. </dd></dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
